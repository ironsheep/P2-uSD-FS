{{┌──────────────────────────────────────────┐
│ SD card driver V3 (Multi-File Handles)   │  Verified with Panasonic 512MB SD
│ Original: Chris Gadd, V3: S.M. Moraco    │                PNY 8GB SDHC
│ Copyright (c) 2023 Chris Gadd            │                SanDisk Extreme 32GB SDHC                                       3V3
│ See end of file for terms of use.        │                GSKILL 32GB Micro SDHC                                              ┌─────┐
└──────────────────────────────────────────┘  cards must be formatted as FAT32                                               │   ┤ Read / write        ├─────┐
─┼───┤ CS                  │     │
sd.mount(CS,MOSI,MISO,SCK)                            ' mount SD card                                                      ─┼───┤ MOSI                │     │
sd.newDirectory(string("folder1"))                    ' create a new directory                                               │ ┌─┤ Gnd                 │     │
sd.changeDirectory(string("folder1"))                 ' switch to newly created directory                                    └─┼─┤ Vcc                 │     │
sd.newFile(string("fileA.txt"))                       ' create a new file, leaves file open for writing                    ───┼─┤ SCK                 │     │
sd.writeString(string("this is file A"))              ' write to newly created file                                            ┣─┤ Gnd                 │     │
sd.closeFile()                                        ' close file, update filesize information                            ───┼─┤ MISO                │     │
│ ┤ IRQ                 │     │
sd.openFile(string("fileA.txt"))                      ' open file in current directory                                         │ ┤ Card detect         │     │
-or-                                                  ' -or-                                                                   │ ┤ Write protect       ├─────┘
sd.openFile(string("/folder1/fileA.txt"))             ' open file from path (1st "/" resets directory to root)                 │ └─┳───────────────────┘
sd.read(@buffer,sd.fileSize())                        ' read opened file into buffer                                              
debug(zstr(@buffer))
 ═══════════════════════════════════════════════════════════════════════════════
 CONDITIONAL COMPILATION - Optional Feature Modules
 ═══════════════════════════════════════════════════════════════════════════════
 Default: MINIMAL driver (core file operations only)
 To enable optional features, use #PRAGMA EXPORTDEF in your top-level file:
   #PRAGMA EXPORTDEF SD_INCLUDE_RAW        ' Raw sector access
   #PRAGMA EXPORTDEF SD_INCLUDE_REGISTERS  ' Card register access (CID/CSD/SCR)
   #PRAGMA EXPORTDEF SD_INCLUDE_SPEED      ' High-speed mode control
   #PRAGMA EXPORTDEF SD_INCLUDE_DEBUG      ' Debug/diagnostic methods & CRC getters
   OBJ
       sd : "micro_sd_fat32_fs"
 Or define SD_INCLUDE_ALL to include everything:
   #PRAGMA EXPORTDEF SD_INCLUDE_ALL
 ═══════════════════════════════════════════════════════════════════════════════
 ═══════════════════════════════════════════════════════════════════════════
 Struct type definitions for card registers, filesystem structures, and
 directory entries. Exported automatically to consumer objects via OBJ.
 All structs are packed (Spin2 default) - offsets match hardware/on-disk layouts.
 ═══════════════════════════════════════════════════════════════════════════

Object "micro_sd_fat32_fs" Interface:
  (Requires Spin2 Language v45)

PUB null()
PUB start(_cs, _mosi, _miso, _sck) : result
PUB stop()
PUB error() : status
PUB getLastCMD13() : r2
PUB getLastCMD13Error() : r2
PUB getLastReceivedCRC() : crc
PUB getLastCalculatedCRC() : crc
PUB getLastSentCRC() : crc
PUB getCRCMatchCount() : count
PUB getCRCMismatchCount() : count
PUB setCRCValidation(enabled)
PUB mount(_cs, _mosi, _miso, _sck) : result
PUB initCardOnly(_cs, _mosi, _miso, _sck) : result
PUB cardSizeSectors() : result
PUB testCMD13() : r2_response
PUB writeSectorRaw(sector, p_buffer) : result
PUB readSectorRaw(sector, p_buffer) : result
PUB readSectorsRaw(start_sector, count, p_buffer) : result
PUB writeSectorsRaw(start_sector, count, p_buffer) : result
PUB readCIDRaw(p_buf) : result
PUB readCSDRaw(p_buf) : result
PUB readSCRRaw(p_buf) : result
PUB getOCR() : ocr
PUB readVBRRaw(p_buf) : result
PUB attemptHighSpeed() : hs_ok
PUB getSPIFrequency() : hz
PUB getCardMaxSpeed() : hz
PUB getManufacturerID() : mid
PUB getReadTimeout() : ms
PUB getWriteTimeout() : ms
PUB isHighSpeedActive() : active
PUB checkCMD6Support() : supported
PUB checkHighSpeedCapability() : capable
PUB newFile(name_ptr) : result
PUB newDirectory(name_ptr) : result
PUB openFile(name_ptr) : result
PUB changeDirectory(name_ptr) : result
PUB closeFile()
PUB unmount() : result
PUB sync() : result
PUB openFileRead(p_path) : handle
PUB openFileWrite(p_path) : handle
PUB createFileNew(p_path) : handle
PUB closeFileHandle(handle) : result
PUB readHandle(handle, p_buffer, count) : bytes_read
PUB writeHandle(handle, p_buffer, count) : bytes_written
PUB seekHandle(handle, position) : result
PUB tellHandle(handle) : position
PUB eofHandle(handle) : is_eof
PUB fileSizeHandle(handle) : size
PUB syncHandle(handle) : result
PUB syncAllHandles() : result
PUB deleteFile(name_ptr) : result
PUB rename(old_name, new_name) : result
PUB moveFile(name_ptr, dest_folder) : result
PUB freeSpace() : result
PUB setDate(year, month, day, hour, minute, second)
PUB read(p_buffer, count) : result
PUB readByte(address) : result
PUB write(p_buffer, count) : result
PUB writeByte(char) : result
PUB writeString(p_str) : result
PUB readDirectory(entry) : result
PUB openDirectory(p_path) : handle
PUB readDirectoryHandle(handle) : p_entry
PUB closeDirectoryHandle(handle)
PUB seek(pos) : result
PUB fileName() : result
PUB attributes() : result
PUB volumeLabel() : result
PUB setVolumeLabel(p_label) : result
PUB debugDumpRootDir()
PUB syncDirCache()
PUB debugGetRootSec() : result
PUB debugGetDirSec() : result
PUB debugGetVbrSec() : result
PUB debugGetFatSec() : result
PUB debugGetSecPerFat() : result
PUB debugClearRootDir() : result
PUB debugGetReadSectorDiag(p_sector, p_buftype, p_token, p_b0, p_b1, p_b2, p_b3, p_pbuf)
PUB debugGetReadSectorDiagExt(p_before0, p_before1, p_before2, p_before3, p_spi_period)
PUB debugReadSectorSlow(sector, p_buffer) : result
PUB fileSize() : result
PUB setSPISpeed(freq)
PUB displaySector()
PUB displayEntry()
PUB displayFAT(cluster)

__________
PUB null()

 This is not a top-level object - placeholder to indicate driver must be instantiated as OBJ.
 MULTI-COG LIFECYCLE METHODS
 ═══════════════════════════════════════════════════════════════════════════

___________________________________________
PUB start(_cs, _mosi, _miso, _sck) : result

 Start worker cog (singleton) - initialize SD card driver and launch dedicated worker cog.
 This method is idempotent - calling multiple times is safe.
 @param _cs - Chip select pin number
 @param _mosi - Master Out Slave In pin number
 @param _miso - Master In Slave Out pin number
 @param _sck - Serial clock pin number
 @returns result - Cog ID (0-7) on success, -1 on failure

__________
PUB stop()

 Stop worker cog - cleanly shut down the worker cog and release resources.
 Safe to call even if not started.

____________________
PUB error() : status

 Get last error for this cog - returns the error code from the most recent operation.
 Thread-safe: each cog has its own error slot.
 @returns status - Error code from the most recent operation on this cog

_______________________
PUB getLastCMD13() : r2

 Get last CMD13 result (R1 in high byte, STATUS in low byte).
 Value is from most recent CMD13, regardless of success/failure.
 @returns r2 - Combined R2 response word

____________________________
PUB getLastCMD13Error() : r2

 Get last CMD13 error - returns last non-zero CMD13 result (preserved until next error).
 Useful for diagnostics - shows most recent error even after recovery.
 @returns r2 - Last non-zero R2 response word

______________________________
PUB getLastReceivedCRC() : crc

 Get CRC-16 from last sector read - returns the 16-bit CRC received from the SD card
 after the most recent sector read operation. Use for validating CRC algorithm.
 @returns crc - 16-bit CRC the card calculated and sent

________________________________
PUB getLastCalculatedCRC() : crc

 Get CRC-16 calculated from data - returns the 16-bit CRC we calculated from received data.
 Should match getLastReceivedCRC() if data transfer was clean.
 @returns crc - 16-bit CRC calculated from data

__________________________
PUB getLastSentCRC() : crc

 Get CRC-16 sent with last write - returns the 16-bit CRC we calculated and sent.
 @returns crc - 16-bit CRC sent with the last write operation

______________________________
PUB getCRCMatchCount() : count

 Get count of CRC matches - returns number of sector reads where CRC matched.
 @returns count - Number of sector reads where calculated CRC matched received CRC

_________________________________
PUB getCRCMismatchCount() : count

 Get count of CRC mismatches - returns number of sector reads where CRC did NOT match.
 Non-zero indicates data corruption occurred during transfer.
 @returns count - Number of sector reads where CRC did not match

_____________________________
PUB setCRCValidation(enabled)

 Enable/disable CRC validation for sector reads.
 When enabled, each sector read validates CRC and updates match/mismatch counts.
 @param enabled - TRUE (non-zero) enables CRC checking, FALSE (0) disables

___________________________________________
PUB mount(_cs, _mosi, _miso, _sck) : result

 Mount SD card (multi-cog safe) - starts worker cog and mounts filesystem.
 Supports MODE_RAW -> MODE_FILESYSTEM upgrade (card already initialized).
 @param _cs - Chip select pin number
 @param _mosi - Master Out Slave In pin number
 @param _miso - Master In Slave Out pin number
 @param _sck - Serial clock pin number
 @returns result - TRUE on success, FALSE on failure

__________________________________________________
PUB initCardOnly(_cs, _mosi, _miso, _sck) : result

 Initialize SD card without mounting filesystem - for raw sector access.
 Use this for low-level operations like formatting. Does NOT read filesystem.
 Starts worker cog and initializes card for raw sector access (MODE_RAW).
 @param _cs - Chip select pin number
 @param _mosi - Master Out Slave In pin number
 @param _miso - Master In Slave Out pin number
 @param _sck - Serial clock pin number
 @returns result - TRUE if card initialized successfully, FALSE otherwise

______________________________
PUB cardSizeSectors() : result

 Get total sectors on card via worker cog.
 Must call initCardOnly() or mount() first.
 @returns result - Total number of 512-byte sectors on the card

_____________________________
PUB testCMD13() : r2_response

 TEST ONLY: Send CMD13 and return raw R2 response.
 For testing/validation of CMD13 (SEND_STATUS) functionality.
 NOTE: This is a diagnostic method - not for normal operation.
 @returns r2_response - R2 response word ($0000=OK, $FFFF=timeout, other=error)
 @local r1 - R1 response byte
 @local status - Status byte from R2

_____________________________________________
PUB writeSectorRaw(sector, p_buffer) : result

 Write a sector at absolute LBA address - low-level for formatting/partitioning.
 Bypasses filesystem. Requires initCardOnly() or mount() first.
 @param sector - Absolute LBA sector number
 @param p_buffer - Pointer to 512 bytes of data to write
 @returns result - TRUE on success, FALSE on failure

____________________________________________
PUB readSectorRaw(sector, p_buffer) : result

 Read a sector at absolute LBA address - low-level for verification.
 Bypasses filesystem. Requires initCardOnly() or mount() first.
 @param sector - Absolute LBA sector number
 @param p_buffer - Pointer to 512-byte buffer to receive data
 @returns result - TRUE on success, FALSE on failure

__________________________________________________________
PUB readSectorsRaw(start_sector, count, p_buffer) : result

 Read multiple consecutive sectors - multi-block read using CMD18.
 More efficient than calling readSectorRaw() in a loop.
 @param start_sector - First sector to read (absolute LBA)
 @param count - Number of sectors to read
 @param p_buffer - Pointer to buffer (must be count * 512 bytes)
 @returns result - Number of sectors successfully read

___________________________________________________________
PUB writeSectorsRaw(start_sector, count, p_buffer) : result

 Write multiple consecutive sectors - multi-block write using CMD25.
 More efficient than calling writeSectorRaw() in a loop.
 @param start_sector - First sector to write (absolute LBA)
 @param count - Number of sectors to write
 @param p_buffer - Pointer to buffer with data (must be count * 512 bytes)
 @returns result - Number of sectors successfully written
 CARD IDENTIFICATION METHODS (for diagnostic tools)
 These methods provide raw register access for card characterization.
 Call initCardOnly() or mount() before using these methods.
 SD card registers are big-endian (MSB-first). Single-byte fields can be
 read directly, but multi-byte fields need endian conversion on the P2
 (little-endian). Currently done with manual shift/OR patterns.
 TODO: With {Spin2_v52} compiler, use ENDIANL() and ENDIANW() for
   multi-byte big-endian fields:
     psn := ENDIANL(LONG[@cid_buf + 9])   ' CID serial number
     mdt := ENDIANW(WORD[@cid_buf + 13])   ' CID manufacturing date
   Also consider STRUCT (available at v45+) to define cid_t, csd_t, scr_t
   types here and export them for consumer objects.
 ═══════════════════════════════════════════════════════════════════════════

______________________________
PUB readCIDRaw(p_buf) : result

 Read CID register (16 bytes) into buffer.
 Contains manufacturer ID, product name, serial number, and manufacturing date.
 Routes through worker cog which owns the SPI pins.
 @param p_buf - Pointer to cid_t buffer to receive CID data
 @returns result - TRUE on success, FALSE on failure
 @local status - Command status

______________________________
PUB readCSDRaw(p_buf) : result

 Read CSD register (16 bytes) into buffer.
 Contains card capacity, speed, and features.
 Routes through worker cog which owns the SPI pins.
 @param p_buf - Pointer to csd_t buffer to receive CSD data
 @returns result - TRUE on success, FALSE on failure
 @local status - Command status

______________________________
PUB readSCRRaw(p_buf) : result

 Read SCR register (8 bytes) into buffer.
 Contains SD spec version and bus widths.
 Routes through worker cog which owns the SPI pins.
 @param p_buf - Pointer to scr_t buffer to receive SCR data
 @returns result - TRUE on success, FALSE on failure
 @local status - Command status

__________________
PUB getOCR() : ocr

 Get cached OCR register value - Operating Conditions Register from card init.
 Contains card capacity status (CCS) and voltage range.
 @returns ocr - 32-bit OCR value, or 0 if card not initialized

______________________________
PUB readVBRRaw(p_buf) : result

 Read Volume Boot Record (512 bytes) into buffer.
 Card must be mounted for this method to work (VBR location determined at mount).
 @param p_buf - Pointer to 512-byte buffer to receive VBR data
 @returns result - TRUE on success, FALSE if not mounted

______________________________
PUB attemptHighSpeed() : hs_ok

 Attempt to enable 50 MHz high-speed mode with verification.
 Queries capability, switches mode, verifies with sector read/write.
 Safe to call - will not break operation on failure.
 @returns hs_ok - TRUE if 50 MHz active, FALSE if fell back to 25 MHz
 @local test_buf - Test data buffer (128 longs = 512 bytes)
 @local verify_buf - Verification buffer (128 longs = 512 bytes)
 @local i - Loop counter
 @local mismatch - Count of mismatched longs

__________________________
PUB getSPIFrequency() : hz

 Get current SPI clock frequency in Hz.
 @returns hz - Current SPI clock frequency in Hz

__________________________
PUB getCardMaxSpeed() : hz

 Get card's reported maximum speed from CSD TRAN_SPEED field.
 @returns hz - Card's maximum speed in Hz

_____________________________
PUB getManufacturerID() : mid

 Get card manufacturer ID (MID) from CID register.
 Common IDs: $03=SanDisk, $1D=PNY/AData, $27=Samsung.
 @returns mid - Manufacturer ID byte

_________________________
PUB getReadTimeout() : ms

 Get read timeout from CSD register in milliseconds.
 SDHC/SDXC: Fixed 100ms per spec. SDSC: Calculated from TAAC/NSAC.
 @returns ms - Read timeout in milliseconds

__________________________
PUB getWriteTimeout() : ms

 Get write timeout from CSD register in milliseconds.
 SDHC/SDXC: Fixed 250ms per spec. SDSC: Read timeout * R2W_FACTOR.
 @returns ms - Write timeout in milliseconds

________________________________
PUB isHighSpeedActive() : active

 Check if high-speed mode is active (running at 50 MHz).
 @returns active - TRUE if running at 50 MHz or higher

__________________________________
PUB checkCMD6Support() : supported

 Check if card supports CMD6 command - reads SCR for SD spec version.
 CMD6 supported by SD 2.0 and later cards (SD_SPEC >= 2).
 @returns supported - TRUE if CMD6 is available
 @local scr - SCR register data (2 longs = 8 bytes)
 @local sd_spec - SD spec version from SCR

________________________________________
PUB checkHighSpeedCapability() : capable

 Check if card reports high-speed capability - queries function group 1.
 Uses CMD6 mode 0 (check without switch).
 Requires CMD6 support - call checkCMD6Support() first.
 @returns capable - TRUE if high-speed function is supported
 @local status - CMD6 status structure (16 longs = 64 bytes)

______________________________
PUB newFile(name_ptr) : result

 Create and open a new file (multi-cog safe) in current directory.
 @param name_ptr - Pointer to null-terminated filename string
 @returns result - TRUE on success, FALSE if file exists or error

___________________________________
PUB newDirectory(name_ptr) : result

 Create a new directory (multi-cog safe) in current directory.
 @param name_ptr - Pointer to null-terminated directory name string
 @returns result - TRUE on success, FALSE if directory exists or error

_______________________________
PUB openFile(name_ptr) : result

 Open file (multi-cog safe) - opens existing file for reading/writing.
 @param name_ptr - Pointer to null-terminated filename string
 @returns result - TRUE on success, FALSE if not found

______________________________________
PUB changeDirectory(name_ptr) : result

 Change directory (multi-cog safe) - changes current directory.
 @param name_ptr - Pointer to null-terminated directory name string
 @returns result - TRUE on success, FALSE if not found

_______________
PUB closeFile()

 Close file (multi-cog safe) - closes currently open file, flushing pending writes.

______________________
PUB unmount() : result

 Unmount SD card (multi-cog safe) - cleanly unmounts, flushing data and updating FSInfo.
 @returns result - TRUE on success

___________________
PUB sync() : result

 Flush buffers (multi-cog safe) - flushes pending writes without closing file.
 Use to checkpoint data during long operations.
 @returns result - TRUE on success

_________________________________
PUB openFileRead(p_path) : handle

 Open file for reading (V3 multi-file) - opens existing file and returns handle.
 Multiple files can be open simultaneously with independent positions.
 Use closeFileHandle() when done.
 @param p_path - Pointer to null-terminated path string
 @returns handle - File handle (0 to MAX_OPEN_FILES-1) on success, negative error code on failure

__________________________________
PUB openFileWrite(p_path) : handle

 Open file for writing/append (V3 multi-file) - opens for appending.
 Position is set to end of file. Only one write handle per file allowed.
 Use closeFileHandle() when done to flush data.
 @param p_path - Pointer to null-terminated path string
 @returns handle - File handle (0 to MAX_OPEN_FILES-1) on success, negative error code on failure

__________________________________
PUB createFileNew(p_path) : handle

 Create new file for writing (V3 multi-file) - creates and opens for writing.
 Returns error if file exists.
 Use closeFileHandle() when done to flush data and finalize size.
 @param p_path - Pointer to null-terminated path string
 @returns handle - File handle (0 to MAX_OPEN_FILES-1) on success, negative error code on failure

____________________________________
PUB closeFileHandle(handle) : result

 Close file handle (V3 multi-file) - closes handle, flushing pending writes.
 For write handles, updates directory with final file size.
 After close, handle is invalid and slot is available for reuse.
 @param handle - File handle to close
 @returns result - SUCCESS (0) on success, negative error code on failure

____________________________________________________
PUB readHandle(handle, p_buffer, count) : bytes_read

 Read from file handle (V3 multi-file) - reads up to count bytes into buffer.
 Returns actual bytes read (may be less at EOF). Returns 0 at EOF.
 Position advances by the number of bytes read.
 @param handle - Valid read handle
 @param p_buffer - Pointer to destination buffer
 @param count - Maximum bytes to read
 @returns bytes_read - Bytes actually read (0 at EOF), negative on error

________________________________________________________
PUB writeHandle(handle, p_buffer, count) : bytes_written

 Write to file handle (V3 multi-file) - writes count bytes from buffer.
 File grows as needed with automatic cluster allocation.
 Position advances by the number of bytes written.
 @param handle - Valid write handle
 @param p_buffer - Pointer to source data
 @param count - Bytes to write
 @returns bytes_written - Bytes actually written, negative on error

_________________________________________
PUB seekHandle(handle, position) : result

 Seek to position in file (V3 multi-file) - seeks to absolute byte position.
 Position must be <= file size (cannot seek past EOF).
 @param handle - Valid file handle
 @param position - Absolute byte position to seek to
 @returns result - SUCCESS (0) on success, negative error code on failure

_________________________________
PUB tellHandle(handle) : position

 Get current position (V3 multi-file) - returns current byte position in file.
 @param handle - Valid file handle
 @returns position - Current position (0-based), negative on error

______________________________
PUB eofHandle(handle) : is_eof

 Check if at end of file (V3 multi-file) - returns TRUE if at or past EOF.
 @param handle - Valid file handle
 @returns is_eof - TRUE if at EOF, FALSE if not, negative on error

_________________________________
PUB fileSizeHandle(handle) : size

 Get file size (V3 multi-file) - returns total size in bytes.
 For write handles, reflects current size including pending writes.
 @param handle - Valid file handle
 @returns size - File size in bytes, negative on error

_______________________________
PUB syncHandle(handle) : result

 Flush handle to disk (V3 multi-file) - flushes pending writes and updates directory.
 File remains open for further operations.
 @param handle - Valid file handle
 @returns result - SUCCESS (0) on success, negative error code on failure

_____________________________
PUB syncAllHandles() : result

 Flush all handles to disk (V3 multi-file) - flushes all open write handles.
 Useful before risky operations or for periodic safety.
 @returns result - SUCCESS (0) on success

_________________________________
PUB deleteFile(name_ptr) : result

 Delete file (multi-cog safe) - deletes file from current directory.
 @param name_ptr - Pointer to null-terminated filename string
 @returns result - TRUE on success, FALSE if not found or protected

_______________________________________
PUB rename(old_name, new_name) : result

 Rename file or directory (multi-cog safe).
 @param old_name - Pointer to current name string
 @param new_name - Pointer to new name string
 @returns result - TRUE on success, FALSE if source not found or dest exists

____________________________________________
PUB moveFile(name_ptr, dest_folder) : result

 Move file to another directory (multi-cog safe).
 @param name_ptr - Pointer to filename to move
 @param dest_folder - Pointer to destination folder name
 @returns result - TRUE on success, FALSE on error

________________________
PUB freeSpace() : result

 Get free space in sectors (multi-cog safe).
 This may take a while on large cards.
 @returns result - Number of free sectors on the card

___________________________________________________
PUB setDate(year, month, day, hour, minute, second)

 Set the current date and time for new files/folders.
 @param year - Year (e.g., 2024)
 @param month - Month (1-12)
 @param day - Day (1-31)
 @param hour - Hour (0-23)
 @param minute - Minute (0-59)
 @param second - Second (0-59)

__________________________________
PUB read(p_buffer, count) : result

 Read bytes from file (multi-cog safe) - reads up to count bytes.
 @param p_buffer - Pointer to destination buffer
 @param count - Maximum bytes to read
 @returns result - Number of bytes actually read

______________________________
PUB readByte(address) : result

 Read single byte from file (multi-cog safe) - seeks to address and reads one byte.
 @param address - Byte offset to read from
 @returns result - Byte value read, or 0 on error
 @local byte_buf - Buffer for single byte read

___________________________________
PUB write(p_buffer, count) : result

 Write bytes to file (multi-cog safe) - writes count bytes to open file.
 @param p_buffer - Pointer to source data
 @param count - Number of bytes to write
 @returns result - Command result status

____________________________
PUB writeByte(char) : result

 Write single byte to file (multi-cog safe).
 @param char - Byte value to write
 @returns result - Command result status

_______________________________
PUB writeString(p_str) : result

 Write string to file (multi-cog safe) - writes null-terminated string.
 @param p_str - Pointer to null-terminated string
 @returns result - Command result status

_________________________________
PUB readDirectory(entry) : result

 Read directory entry (multi-cog safe) - iterates through directory entries.
 @param entry - Entry index to read (0-based)
 @returns result - Pointer to entry_buffer on success, 0 if entry doesn't exist

__________________________________
PUB openDirectory(p_path) : handle

 Open directory for enumeration (multi-cog safe) - returns handle for iterating entries.
 Use readDirectoryHandle() to get entries, closeDirectoryHandle() when done.
 Pass "" or "." to enumerate calling cog's current working directory.
 Handles share the existing file handle pool (MAX_OPEN_FILES total).
 @param p_path - Pointer to null-terminated path string
 @returns handle - Handle on success, negative error code on failure

_________________________________________
PUB readDirectoryHandle(handle) : p_entry

 Read next entry from directory handle (multi-cog safe) - returns pointer to entry data.
 Skips deleted, LFN, and hidden/system entries automatically.
 After each call, use fileName() and attributes() to inspect the returned entry.
 @param handle - Directory handle from openDirectory()
 @returns p_entry - Pointer to entry_buffer on success, 0 at end of directory

________________________________
PUB closeDirectoryHandle(handle)

 Close directory handle (multi-cog safe) - releases handle back to pool.
 @param handle - Directory handle from openDirectory()

______________________
PUB seek(pos) : result

 Seek to position in file (multi-cog safe) - sets file position.
 @param pos - Byte position from start of file
 @returns result - TRUE on success, FALSE if pos is beyond end of file

_______________________
PUB fileName() : result

 Return the 8.3 filename of the currently opened file.
 @returns result - Pointer to filename string
 @local p_temp - Pointer to temporary filename buffer
 @local i - Loop counter for parsing

_________________________
PUB attributes() : result

 Return the attribute byte of the currently opened file.
 @returns result - FAT attribute byte

__________________________
PUB volumeLabel() : result

 Return pointer to volume label string.
 @returns result - Pointer to volume label (11 chars + null)

____________________________________
PUB setVolumeLabel(p_label) : result

 Set the volume label on the mounted SD card.
 Updates both the BPB and root directory volume label entry.
 @param p_label - Pointer to new volume label string (max 11 chars)
 @returns result - TRUE on success, FALSE on failure

______________________
PUB debugDumpRootDir()

 DEBUG: Dump root directory entries to debug output.
 This is a diagnostic function for debugging. It reads the root directory
 and prints each entry's first 11 bytes (filename) and first cluster.
 Called from test cog so output appears in headless logs.
 @local sec - Current sector being read
 @local i - Entry index counter
 @local p_entry - Pointer to current directory entry

__________________
PUB syncDirCache()

 Force directory cache invalidation - invalidates the directory sector cache.
 The next read will re-fetch from card.
 Use after file operations to ensure consistency when multiple files are accessed.
 This is safe to call from any cog (just sets a DAT variable to -1).

______________________________
PUB debugGetRootSec() : result

 DEBUG: Return root_sec for diagnostic.
 @returns result - Root directory sector number

_____________________________
PUB debugGetDirSec() : result

 DEBUG: Return calling cog's current directory sector for diagnostic.
 @returns result - Current directory sector number for calling cog

_____________________________
PUB debugGetVbrSec() : result

 DEBUG: Return VBR sector for diagnostic.
 @returns result - Volume Boot Record sector number

_____________________________
PUB debugGetFatSec() : result

 DEBUG: Return FAT sector for diagnostic.
 @returns result - FAT start sector number

________________________________
PUB debugGetSecPerFat() : result

 DEBUG: Return sectors per FAT for diagnostic.
 @returns result - Number of sectors per FAT

________________________________
PUB debugClearRootDir() : result

 DEBUG: Clear root directory (fixes corruption).
 Clears the root directory by writing zeros to root_sec.
 Use this to fix a corrupted root directory.
 WARNING: This DELETES all files and folders!
 @returns result - 0 on success, -1 on error

________________________________________________________________________________________
PUB debugGetReadSectorDiag(p_sector, p_buftype, p_token, p_b0, p_b1, p_b2, p_b3, p_pbuf)

 DEBUG: Get readSector diagnostic data - copies diagnostic data from last readSector call.
 Call this after readSectorRaw() to see what happened inside readSector.
 @param p_sector - Pointer to receive last sector number
 @param p_buftype - Pointer to receive last buffer type
 @param p_token - Pointer to receive last token ($FE on success)
 @param p_b0 - Pointer to receive buffer byte 0
 @param p_b1 - Pointer to receive buffer byte 1
 @param p_b2 - Pointer to receive buffer byte 2
 @param p_b3 - Pointer to receive buffer byte 3
 @param p_pbuf - Pointer to receive buffer pointer

_______________________________________________________________________________________
PUB debugGetReadSectorDiagExt(p_before0, p_before1, p_before2, p_before3, p_spi_period)

 DEBUG: Get extended readSector diagnostic data - buffer state BEFORE streamer and SPI timing.
 @param p_before0 - Pointer to receive buffer byte 0 before streamer
 @param p_before1 - Pointer to receive buffer byte 1 before streamer
 @param p_before2 - Pointer to receive buffer byte 2 before streamer
 @param p_before3 - Pointer to receive buffer byte 3 before streamer
 @param p_spi_period - Pointer to receive SPI period value

__________________________________________________
PUB debugReadSectorSlow(sector, p_buffer) : result

 DEBUG: Read sector byte-by-byte (no streamer) - for comparison with streamer.
 This is SLOW but useful for debugging streamer issues.
 Requires worker cog to be running (SPI pins configured).
 NOTE: This runs in Cog0 and requires SPI smart pins to be configured for this cog.
       It will NOT work with the normal V3 driver architecture.
       This is for DIAGNOSTIC USE ONLY.
 @param sector - Sector number to read
 @param p_buffer - Pointer to 512-byte destination buffer
 @returns result - 0 on success, -1 on timeout/error
 @local data - (unused in wrapper)
 @local i - (unused in wrapper)
 @local timeout - (unused in wrapper)

_______________________
PUB fileSize() : result

 Return the size of the currently opened file in bytes.
 @returns result - File size from directory entry

_____________________
PUB setSPISpeed(freq)

 Set SPI clock frequency - configure SPI clock speed for sysclk-independent operation.
 Made public for speed characterization testing.
 Using P_TRANSITION mode: X = half-period (time between transitions)
 Reference: ManAtWork SpiFlash.spin2
 Formula: half_period = clkfreq / (freq * 2)
 For 400 kHz: half_period = 320M / 800k = 400 clocks
 For 25 MHz: half_period = 320M / 50M = 6.4 -> minimum 4
 @param freq - Target SPI frequency in Hz (e.g., 400_000 or 25_000_000)
 @local half_period - Calculated half-period in system clocks
 @local actual_freq - Actual achieved frequency

___________________
PUB displaySector()

 Display sector in buffer - prints hex dump with ASCII representation.
 @local address - Current byte offset in buffer
 @local char - Current character being processed
 @local ascii_ptr - Pointer to ASCII representation string
 @local i - Loop counter

__________________
PUB displayEntry()

 Display directory entry - prints hex dump of entry_buffer with ASCII representation.
 @local address - Current byte offset in entry
 @local char - Current character being processed
 @local ascii_ptr - Pointer to ASCII representation string
 @local i - Loop counter

_______________________
PUB displayFAT(cluster)

 Display FAT sector containing cluster number - reads and displays FAT entries.
 @param cluster - Cluster number to display FAT sector for


┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                                   TERMS OF USE: MIT License                                                  │
├──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation    │
│files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,    │
│modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software│
│is furnished to do so, subject to the following conditions:                                                                   │
│                                                                                                                              │
│The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.│
│                                                                                                                              │
│THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE          │
│WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR         │
│COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,   │
│ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                         │
└──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
