'' =================================================================================================
''
''   File....... SD_demo_shell.spin2
''   Purpose.... Interactive command-line shell for SD card filesystem
''   Author..... Stephen M Moraco
''               Copyright (c) 2026 Iron Sheep Productions, LLC
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... FEB 2026
''   Updated.... 07 FEB 2026
''
'' =================================================================================================
''
''   Interactive shell for exploring SD card filesystem operations.
''   Supports both DOS-style (dir, type, del) and Unix-style (ls, cat, rm) commands.
''
''   Connect via serial terminal at 2,000,000 baud (2 Mbit).
''   Type 'help' for list of available commands.
''
'' =================================================================================================

CON { timing }

  CLK_FREQ = 270_000_000                                        ' system freq as a constant
  MS_001   = CLK_FREQ / 1_000                                   ' ticks in 1ms
  US_001   = CLK_FREQ / 1_000_000                               ' ticks in 1us

  _clkfreq = CLK_FREQ                                           ' set system clock


CON { terminal }

'  BR_TERM  = 230_400                                            ' terminal baud rate
  BR_TERM  = 2_000_000                                            ' terminal baud rate


CON { SD card pins - P2 Edge Module }

  SD_CS    = 60  { O }                                          ' directly directly directly chip select
  SD_SCK   = 61  { O }                                          ' serial clock
  SD_MOSI  = 59  { O }                                          ' master out, slave in
  SD_MISO  = 58  { I }                                          ' master in, slave out


CON { fixed io pins }

  PGM_RX   = 63  { I }                                          ' programming / debug
  PGM_TX   = 62  { O }


CON { constants }

  #true,  ON, OFF
  #false, NO, YES

  MAX_PATH    = 128                                             ' max path length
  SECTOR_SIZE = 512                                             ' SD sector size
  BUFFER_SIZE = 512                                             ' read/write buffer


CON { FAT32 structure constants }

  ' FAT32 structure signatures
  MBR_SIGNATURE               = $AA55
  PARTITION_TYPE_FAT32_LBA    = $0C
  FSINFO_SIG1                 = $41615252      ' "RRaA"
  FSINFO_SIG2                 = $61417272      ' "rrAa"
  FSINFO_TRAIL_SIG            = $AA550000      ' Trail signature
  EXT_BOOT_SIG                = $29            ' Extended boot signature

  ' FAT entry constants
  FAT_MASK        = $0FFFFFFF     ' Lower 28 bits (cluster value)
  FAT_EOC_MIN     = $0FFFFFF8     ' Minimum end-of-chain marker
  FAT_EOC         = $0FFFFFFF     ' Standard EOC
  FAT_FREE        = $00000000     ' Free cluster
  FAT_BAD         = $0FFFFFF7     ' Bad cluster marker

  ' Bitmap capacity (256KB covers up to 2M clusters)
  BITMAP_LONGS        = 65536             ' 256KB
  MAX_BITMAP_CLUSTERS = BITMAP_LONGS * 32 ' 2,097,152 clusters

  ' Safety limits
  MAX_DIR_DEPTH       = 16
  MAX_CHAIN_LENGTH    = 2_000_000

  ' Bench test parameters
  BENCH_SECTOR_BASE   = 1_000_000         ' Safe area past filesystem
  BENCH_SECTOR_RANGE  = 10_000            ' Range of test sectors


CON { parser }

  CLI_BUF_SIZE = 128                                            ' command input buffer size
  CLI_MAX_TKNS =  10                                            ' max tokens per command


CON { command enums }

  #0, CMD_UNKNOWN, CMD_HELP, CMD_VERSION, CMD_CLS, CMD_CLEAR
  CMD_MOUNT, CMD_UNMOUNT, CMD_EJECT, CMD_FORMAT
  CMD_STATS, CMD_INFO, CMD_DIR, CMD_LS
  CMD_CD, CMD_PWD, CMD_MKDIR
  CMD_TYPE, CMD_CAT, CMD_HEXDUMP, CMD_HD
  CMD_REN, CMD_MV, CMD_COPY, CMD_CP
  CMD_DEL, CMD_RM, CMD_RMDIR
  CMD_DEMO, CMD_CARD, CMD_CID
  CMD_BENCHMARK, CMD_PERF, CMD_TOUCH
  CMD_AUDIT, CMD_FSCK, CMD_BENCH
  CMD_LABEL, CMD_VOL


'' Enable full driver features for card info display
#PRAGMA EXPORTDEF SD_INCLUDE_ALL

OBJ

  sd     : "SD_card_driver"                                     '   SD card filesystem driver
  serial : "isp_serial_singleton"                               '   serial IO for terminal (singleton)


VAR { application }

  byte  buffer[BUFFER_SIZE]                                     ' general purpose buffer
  byte  pathbuf[MAX_PATH]                                       ' path buffer
  byte  cwd[MAX_PATH]                                           ' current working directory
  byte  ntokens                                                 ' number of parsed tokens
  byte  mounted                                                 ' mount status flag


VAR { audit/fsck/bench }

  byte  buf2[SECTOR_SIZE]                                       ' comparison buffer
  byte  fatBuf[SECTOR_SIZE]                                     ' FAT sector cache

  ' FAT cache state
  long  fatBufSector                                            ' cached FAT1 sector (-1 = none)
  long  fatBufDirty                                             ' TRUE if fatBuf needs writing

  ' Filesystem geometry (populated by readGeometry)
  long  geoPartStart                                            ' partition start sector
  long  geoSecPerFat                                            ' sectors per FAT
  long  geoSecPerClus                                           ' sectors per cluster
  long  geoTotalClus                                            ' total data clusters
  long  geoTotalSec                                             ' total sectors
  long  geoReservedSec                                          ' reserved sectors
  long  geoFat1Start                                            ' FAT1 first sector
  long  geoFat2Start                                            ' FAT2 first sector
  long  geoDataStart                                            ' data region first sector
  long  geoRootClus                                             ' root directory cluster

  ' Audit/FSCK statistics
  long  passCount                                               ' tests passed
  long  failCount                                               ' tests failed
  long  repairCount                                             ' repairs made
  long  errorCount                                              ' errors found
  long  warningCount                                            ' warnings issued
  long  dirCount                                                ' directories scanned
  long  fileCount                                               ' files scanned
  long  scanDepth                                               ' current recursion depth
  long  bitmapCapable                                           ' TRUE if card fits in bitmap

  ' Shared pool: FSCK bitmap or bench read buffer (256KB)
  long  sharedPool[BITMAP_LONGS]


VAR { parser }

  byte  cliBuf[CLI_BUF_SIZE]                                    ' command input buffer
  byte  cliIdx                                                  ' current position in buffer
  long  tkPtrs[CLI_MAX_TKNS]                                    ' pointers to parsed tokens


PUB main() | len, eCmd

  setup()
  serial.tx(serial.CLS)
  serial.fstr0(@"* Press return to start...\r\n")
  wait_for_terminal(false, 0)

  serial.tx(serial.CLS)
  serial.fstr0(@"P2 SD Card Filesystem Shell\r\n")
  serial.fstr0(@"- type 'help' for commands\r\n")
  serial.fstr0(@"\r\n")

  ' Initialize current working directory
  bytemove(@cwd, @"/", 2)
  mounted := false

  repeat
    show_prompt()                                               ' prompt user
    len := get_command()                                        ' get input
    if (len > 0)                                                ' if command entered
      ntokens := parse()                                        ' parse and count tokens
      if (ntokens)                                              ' if !0 tokens
        eCmd := idCommand(lcstr(token(0)))                      ' lookup command enum
        run_command(eCmd)                                       ' run command code


PUB get_command() : len | c

'' Enter command from terminal window

  parserReset()                                                 ' prep for new entry

  repeat
    c := serial.rx()                                            ' get char from serial
    c := (c == 9) ? " " : c                                    ' convert tab to space
    if enqueue(c)                                               ' add to input buffer
      quit                                                      '  if terminated, we're done

  return cliIdx                                                 ' report length of input


PUB show_prompt()

'' Display command prompt with current directory

  if (mounted)
    serial.fstr1(@"\rSD:%s> ", @cwd)
  else
    serial.fstr0(@"\rSD:(unmounted)> ")


CON { command handlers }


PUB run_command(eCmd)

'' Run command identified by enum value eCmd

  if (eCmd == CMD_UNKNOWN)
    serial.fstr1(@"'%s' is not recognized as a command\r\n", token(0))
    return

  case eCmd
    CMD_HELP                : show_help()
    CMD_VERSION             : show_version()
    CMD_CLS, CMD_CLEAR      : do_cls()
    CMD_MOUNT               : do_mount()
    CMD_UNMOUNT, CMD_EJECT  : do_unmount()
    CMD_FORMAT              : do_format()
    CMD_STATS, CMD_INFO     : do_stats()
    CMD_DIR, CMD_LS         : do_dir()
    CMD_CD                  : do_cd()
    CMD_PWD                 : do_pwd()
    CMD_MKDIR               : do_mkdir()
    CMD_TYPE, CMD_CAT       : do_type()
    CMD_HEXDUMP, CMD_HD     : do_hexdump()
    CMD_REN, CMD_MV         : do_rename()
    CMD_COPY, CMD_CP        : do_copy()
    CMD_DEL, CMD_RM         : do_delete()
    CMD_RMDIR               : do_rmdir()
    CMD_DEMO                : do_demo()
    CMD_CARD, CMD_CID       : do_card_info()
    CMD_BENCHMARK, CMD_PERF, CMD_BENCH : do_bench()
    CMD_TOUCH               : do_touch()
    CMD_AUDIT               : do_audit()
    CMD_FSCK                : do_fsck()
    CMD_LABEL, CMD_VOL      : do_label()
    other                   : not_implemented()


PUB show_help()

'' Show available commands

  if (ntokens <> 1)
    bad_syntax()
    return

  serial.str(@s_Help)


PUB show_version()

'' Show driver version info

  if (ntokens <> 1)
    bad_syntax()
    return

  serial.fstr0(@"SD Card Driver - Iron Sheep Productions\r\n")
  serial.fstr1(@"SPI Frequency: %d Hz\r\n", sd.getSPIFrequency())


PUB do_cls()

'' Clear terminal window

  if (ntokens <> 1)
    bad_syntax()
    return

  serial.tx(serial.CLS)


PUB do_mount() | result

'' Mount SD card filesystem

  if (ntokens <> 1)
    bad_syntax()
    return

  if (mounted)
    serial.fstr0(@"SD card is already mounted\r\n")
    return

  serial.fstr0(@"Mounting SD card...\r\n")
  result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)

  if (result)
    mounted := true
    bytemove(@cwd, @"/", 2)                                     ' reset to root
    serial.fstr0(@"Mounted successfully\r\n")
    show_card_summary()
  else
    serial.fstr1(@"Mount failed, error: %d\r\n", sd.error())


PUB do_unmount()

'' Unmount SD card filesystem

  if (ntokens <> 1)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  sd.unmount()
  mounted := false
  serial.fstr0(@"SD card unmounted\r\n")


PUB do_format()

'' Format SD card (dangerous!)

  if (ntokens <> 1)
    bad_syntax()
    return

  serial.fstr0(@"WARNING: Format will erase ALL data on the SD card!\r\n")
  serial.fstr0(@"This feature is not yet implemented in this shell.\r\n")
  serial.fstr0(@"Use SD_format_utility.spin2 instead.\r\n")


PUB do_stats() | free_sectors, total_sectors, free_mb, total_mb

'' Display filesystem statistics

  if (ntokens <> 1)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  total_sectors := sd.cardSizeSectors()
  free_sectors := sd.freeSpace()

  total_mb := total_sectors / 2048                              ' sectors to MB (512 * 2048 = 1MB)
  free_mb := free_sectors / 2048

  serial.fstr0(@"\r\n--- SD Card Statistics ---\r\n")
  serial.fstr2(@"Total size:    %d sectors (%d MB)\r\n", total_sectors, total_mb)
  serial.fstr2(@"Free space:    %d sectors (%d MB)\r\n", free_sectors, free_mb)
  serial.fstr1(@"Volume label:  %s\r\n", sd.volumeLabel())
  serial.fstr1(@"SPI frequency: %d Hz\r\n", sd.getSPIFrequency())


PUB do_dir() | dh, result, count, total_size, attrib, size, p_name

'' List directory contents using handle-based directory enumeration

  if (ntokens > 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  serial.fstr1(@"\r\n Directory of %s\r\n\r\n", @cwd)
  serial.fstr0(@"  Attr      Size  Name\r\n")
  serial.fstr0(@"  ----  --------  --------------------------------\r\n")

  dh := sd.openDirectory(@".")
  if (dh < 0)
    serial.fstr1(@"  Error opening directory: %d\r\n", dh)
    return

  count := 0
  total_size := 0

  repeat
    result := sd.readDirectoryHandle(dh)
    if (result == 0)                                            ' no more entries
      quit

    p_name := sd.fileName()
    if (byte[p_name] == 0)                                      ' empty name, skip
      next

    attrib := sd.attributes()
    size := sd.fileSize()

    ' Format attributes
    serial.fstr0(@"  ")
    serial.tx((attrib & $10) ? "D" : "-")                         ' directory
    serial.tx((attrib & $01) ? "R" : "-")                         ' read-only
    serial.tx((attrib & $02) ? "H" : "-")                         ' hidden
    serial.tx((attrib & $04) ? "S" : "-")                         ' system

    if (attrib & $10)                                           ' directory
      serial.fstr1(@"    <DIR>  %s\r\n", p_name)
    else
      serial.fstr2(@"  %8d  %s\r\n", size, p_name)
      total_size += size

    count++

  sd.closeDirectoryHandle(dh)

  serial.fstr0(@"\r\n")
  serial.fstr2(@"  %d file(s), %d bytes\r\n", count, total_size)
  serial.fstr1(@"  %d bytes free\r\n", sd.freeSpace() * SECTOR_SIZE)


PUB do_cd() | p_path

'' Change current directory

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_path := token(1)

  ' Handle special cases
  if (strcomp(p_path, @"/") or strcomp(p_path, @"\\"))
    ' Go to root
    sd.changeDirectory(@"/")
    bytemove(@cwd, @"/", 2)
    return

  if (strcomp(p_path, @".."))
    ' Go up one level
    go_up_directory()
    return

  ' Try to change to specified directory
  if (sd.changeDirectory(p_path))
    update_cwd(p_path)
  else
    serial.fstr1(@"Directory not found: %s\r\n", p_path)


PUB do_pwd()

'' Print working directory

  if (ntokens <> 1)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  serial.fstr1(@"%s\r\n", @cwd)


PUB do_mkdir() | p_name, result

'' Create new directory

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_name := token(1)
  result := sd.newDirectory(p_name)

  if (result)
    serial.fstr1(@"Created directory: %s\r\n", p_name)
  else
    serial.fstr1(@"Failed to create directory: %s\r\n", p_name)


PUB do_type() | p_filename, handle, bytes_read, total, c, i

'' Display contents of text file

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_filename := token(1)
  handle := sd.openFileRead(p_filename)

  if (handle < 0)
    serial.fstr1(@"File not found: %s\r\n", p_filename)
    return

  serial.fstr0(@"\r\n")
  total := 0

  repeat
    bytes_read := sd.readHandle(handle, @buffer, BUFFER_SIZE - 1)
    if (bytes_read <= 0)
      quit

    ' Display as text
    repeat i from 0 to bytes_read - 1
      c := buffer[i]
      if (c == 13) or (c == 10)                                  ' CR or LF
        serial.tx(c)
      elseif (c >= 32 and c < 127)                              ' printable
        serial.tx(c)
      else
        serial.tx(".")                                            ' non-printable

    total += bytes_read

  sd.closeFileHandle(handle)
  serial.fstr1(@"\r\n\r\n[%d bytes]\r\n", total)


PUB do_hexdump() | p_filename, handle, bytes_read, offset, i, c

'' Display file contents in hex format

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_filename := token(1)
  handle := sd.openFileRead(p_filename)

  if (handle < 0)
    serial.fstr1(@"File not found: %s\r\n", p_filename)
    return

  serial.fstr0(@"\r\n")
  offset := 0

  repeat
    bytes_read := sd.readHandle(handle, @buffer, 16)
    if (bytes_read <= 0)
      quit

    ' Print offset
    serial.fstr1(@"%.8x  ", offset)

    ' Print hex bytes
    repeat i from 0 to 15
      if (i < bytes_read)
        serial.fstr1(@"%.2x ", buffer[i])
      else
        serial.fstr0(@"   ")
      if (i == 7)
        serial.tx(" ")

    serial.fstr0(@" |")

    ' Print ASCII
    repeat i from 0 to bytes_read - 1
      c := buffer[i]
      if (c >= 32 and c < 127)
        serial.tx(c)
      else
        serial.tx(".")

    serial.fstr0(@"|\r\n")
    offset += bytes_read

    ' Limit output to first 512 bytes
    if (offset >= 512)
      serial.fstr0(@"... (truncated at 512 bytes)\r\n")
      quit

  sd.closeFileHandle(handle)
  serial.fstr1(@"\r\n[%d bytes total]\r\n", sd.fileSizeHandle(handle) > 0 ? sd.fileSizeHandle(handle) : offset)


PUB do_rename() | p_old, p_new, result

'' Rename file or directory

  if (ntokens <> 3)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_old := token(1)
  p_new := token(2)

  result := sd.rename(p_old, p_new)

  if (result)
    serial.fstr2(@"Renamed '%s' to '%s'\r\n", p_old, p_new)
  else
    serial.fstr1(@"Failed to rename: %s\r\n", p_old)


PUB do_copy() | p_src, p_dst, h_src, h_dst, bytes_read, total

'' Copy file

  if (ntokens <> 3)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_src := token(1)
  p_dst := token(2)

  if (strcomp(p_src, p_dst))
    serial.fstr0(@"Cannot copy file to itself\r\n")
    return

  h_src := sd.openFileRead(p_src)
  if (h_src < 0)
    serial.fstr1(@"Source file not found: %s\r\n", p_src)
    return

  h_dst := sd.createFileNew(p_dst)
  if (h_dst < 0)
    sd.closeFileHandle(h_src)
    serial.fstr1(@"Cannot create destination: %s\r\n", p_dst)
    return

  total := 0
  repeat
    bytes_read := sd.readHandle(h_src, @buffer, BUFFER_SIZE)
    if (bytes_read <= 0)
      quit
    sd.writeHandle(h_dst, @buffer, bytes_read)
    total += bytes_read

  sd.closeFileHandle(h_src)
  sd.closeFileHandle(h_dst)

  serial.fstr2(@"Copied %d bytes to %s\r\n", total, p_dst)


PUB do_delete() | p_filename, result

'' Delete file

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_filename := token(1)
  result := sd.deleteFile(p_filename)

  if (result)
    serial.fstr1(@"Deleted: %s\r\n", p_filename)
  else
    serial.fstr1(@"Failed to delete: %s\r\n", p_filename)


PUB do_rmdir()

'' Remove directory (must be empty)

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  serial.fstr0(@"rmdir not yet implemented\r\n")


PUB do_demo() | handle, i

'' Create demo files

  if (ntokens <> 1)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  serial.fstr0(@"Creating demo files...\r\n")

  ' Create text file 1
  write_demo_file(@"HELLO.TXT", @demo_hello)
  write_demo_file(@"README.TXT", @demo_readme)
  write_demo_file(@"NUMBERS.TXT", @demo_numbers)

  serial.fstr0(@"Demo files created.\r\n")


PUB do_card_info() | cid[4], csd[4], mid, oid[3], pnm[6], prv, psn, mdt

'' Display card identification info

  if (ntokens <> 1)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  sd.readCIDRaw(@cid)

  ' Parse CID fields
  mid := cid.byte[0]
  oid[0] := cid.byte[1]
  oid[1] := cid.byte[2]
  oid[2] := 0
  bytemove(@pnm, @cid.byte[3], 5)
  pnm[5] := 0
  prv := cid.byte[8]
  psn := (cid.byte[9] << 24) | (cid.byte[10] << 16) | (cid.byte[11] << 8) | cid.byte[12]
  mdt := ((cid.byte[13] & $0F) << 8) | cid.byte[14]

  serial.fstr0(@"\r\n--- SD Card Identification ---\r\n")
  serial.fstr1(@"Manufacturer ID:  0x%.2x\r\n", mid)
  serial.fstr1(@"OEM/Application:  %s\r\n", @oid)
  serial.fstr1(@"Product Name:     %s\r\n", @pnm)
  serial.fstr2(@"Product Revision: %d.%d\r\n", prv >> 4, prv & $0F)
  serial.fstr1(@"Serial Number:    0x%.8x\r\n", psn)
  serial.fstr2(@"Manufacture Date: %d/%d\r\n", (mdt >> 4) + 2000, mdt & $0F)
  serial.fstr1(@"Card Size:        %d MB\r\n", sd.cardSizeSectors() / 2048)
  serial.fstr1(@"SPI Frequency:    %d Hz\r\n", sd.getSPIFrequency())
  serial.fstr1(@"High-Speed Mode:  %s\r\n", sd.isHighSpeedActive() ? @"Active" : @"Inactive")


PUB do_audit() | wasMounted, result

'' Audit FAT32 filesystem integrity (read-only)
'' Works mounted or unmounted - uses raw sector reads

  if (ntokens <> 1)
    bad_syntax()
    return

  wasMounted := mounted

  ' If not mounted, initialize card for raw access
  if (not mounted)
    serial.fstr0(@"Initializing card...\r\n")
    if (not initRawAccess())
      serial.fstr0(@"ERROR: Cannot initialize card\r\n")
      return

  ' Reset statistics
  passCount := 0
  failCount := 0

  serial.fstr0(@"\r\n=== FAT32 Filesystem Audit (read-only) ===\r\n")
  serial.fstr1(@"Card: %d MB\r\n\r\n", sd.cardSizeSectors() / 2048)

  ' Read geometry
  if (not readGeometry())
    serial.fstr0(@"ERROR: Cannot read filesystem geometry\r\n")
    if (not wasMounted)
      sd.stop()
    return

  ' Run all audit checks
  auditMBR()
  auditVBR()
  auditBackupVBR()
  auditFSInfo()
  auditFAT()
  auditRootDir()

  ' Mount test only if we weren't already mounted
  if (not wasMounted)
    auditMountTest()
    sd.stop()

  ' Summary
  serial.fstr0(@"\r\n=== AUDIT COMPLETE ===\r\n")
  serial.fstr2(@"Tests: %d  Pass: %d", passCount + failCount, passCount)
  serial.fstr1(@"  Fail: %d\r\n", failCount)
  if (failCount == 0)
    serial.fstr0(@"FILESYSTEM INTEGRITY: OK\r\n")
  else
    serial.fstr0(@"FILESYSTEM INTEGRITY: ISSUES DETECTED\r\n")
    serial.fstr0(@"  Consider running 'fsck' to repair.\r\n")


PUB do_fsck() | cardSectors

'' Check and repair FAT32 filesystem
'' Requires unmount for write access to FAT sectors

  if (ntokens <> 1)
    bad_syntax()
    return

  ' FSCK needs raw write access - must unmount first
  if (mounted)
    if (not confirmYN(@"FSCK requires unmount. Unmount now"))
      return
    sd.unmount()
    mounted := false
    serial.fstr0(@"Unmounted.\r\n")

  ' Initialize card for raw access
  serial.fstr0(@"Initializing card...\r\n")
  if (not initRawAccess())
    serial.fstr0(@"ERROR: Cannot initialize card\r\n")
    return

  ' Reset statistics
  repairCount := 0
  errorCount := 0
  warningCount := 0
  dirCount := 0
  fileCount := 0
  scanDepth := 0
  fatBufSector := -1
  fatBufDirty := false

  cardSectors := sd.cardSizeSectors()
  serial.fstr0(@"\r\n=== FAT32 Filesystem Check & Repair ===\r\n")
  serial.fstr2(@"Card: %d sectors (%d MB)\r\n\r\n", cardSectors, cardSectors / 2048)

  ' Read filesystem geometry
  if (not readGeometry())
    serial.fstr0(@"FATAL: Cannot read filesystem geometry\r\n")
    sd.stop()
    return

  ' Determine if bitmap can cover the whole card
  bitmapCapable := (geoTotalClus <= MAX_BITMAP_CLUSTERS)
  if (not bitmapCapable)
    serial.fstr2(@"NOTE: Card has %d clusters (bitmap max: %d)\r\n", geoTotalClus, MAX_BITMAP_CLUSTERS)
    serial.fstr0(@"  Deep scan (passes 2-3) skipped.\r\n")
    warningCount++

  serial.fstr0(@"\r\n")

  ' Pass 1: Structural integrity
  fsckPass1()

  ' Pass 2: Directory walk + chain validation (requires bitmap)
  if (bitmapCapable)
    fsckPass2()

  ' Pass 3: Lost cluster recovery (requires bitmap)
  if (bitmapCapable)
    fsckPass3()

  ' Pass 4: FAT sync + free count
  fsckPass4()

  ' Summary
  serial.fstr0(@"\r\n=== FSCK COMPLETE ===\r\n")
  serial.fstr2(@"Errors: %d  Repairs: %d", errorCount, repairCount)
  serial.fstr1(@"  Warnings: %d\r\n", warningCount)
  if (bitmapCapable)
    serial.fstr2(@"Directories: %d  Files: %d\r\n", dirCount, fileCount)
  if (errorCount == 0 AND repairCount == 0)
    serial.fstr0(@"STATUS: CLEAN\r\n")
  elseif (errorCount == 0)
    serial.fstr0(@"STATUS: REPAIRED\r\n")
  else
    serial.fstr0(@"STATUS: ERRORS REMAIN\r\n")

  sd.stop()

  ' Offer to re-mount
  serial.fstr0(@"\r\n")
  if (confirmYN(@"Re-mount card"))
    do_mount()


PUB do_bench() | wasMounted, tStart, tElapsed, sector, i, rate, nSectors, readResult, msPerTick

'' Read-only throughput benchmark using raw sector reads
'' Works mounted or unmounted - no files created/deleted

  if (ntokens <> 1)
    bad_syntax()
    return

  wasMounted := mounted

  ' If not mounted, initialize card for raw access
  if (not mounted)
    serial.fstr0(@"Initializing card...\r\n")
    if (not initRawAccess())
      serial.fstr0(@"ERROR: Cannot initialize card\r\n")
      return

  serial.fstr0(@"\r\n=== Read-Only Throughput Benchmark ===\r\n")
  serial.fstr2(@"Card: %d MB, SPI: %d Hz\r\n", sd.cardSizeSectors() / 2048, sd.getSPIFrequency())
  serial.fstr1(@"Test area: sectors %d+\r\n\r\n", BENCH_SECTOR_BASE)

  msPerTick := clkfreq / 1000

  ' --- Single-sector test (100 reads) ---
  serial.fstr0(@"Single-sector (100 reads)... ")
  sector := BENCH_SECTOR_BASE
  tStart := getct()
  repeat 100
    sd.readSectorRaw(sector, @buffer)
    sector++
  tElapsed := getct() - tStart

  rate := (100 * 512 * msPerTick) / tElapsed                    ' bytes/ms = KB/s approx
  serial.fstr2(@"%d ms, %d KB/s\r\n", tElapsed / msPerTick, rate)

  ' --- Multi-sector x8 ---
  serial.fstr0(@"Multi-sector x8 (100 reads)... ")
  sector := BENCH_SECTOR_BASE
  tStart := getct()
  repeat 100
    readResult := sd.readSectorsRaw(sector, 8, @sharedPool)
    sector += 8
  tElapsed := getct() - tStart

  rate := (100 * 8 * 512 * (msPerTick / 10)) / (tElapsed / 10)
  serial.fstr2(@"%d ms, %d KB/s\r\n", tElapsed / msPerTick, rate)

  ' --- Multi-sector x32 ---
  serial.fstr0(@"Multi-sector x32 (25 reads)... ")
  sector := BENCH_SECTOR_BASE
  tStart := getct()
  repeat 25
    readResult := sd.readSectorsRaw(sector, 32, @sharedPool)
    sector += 32
  tElapsed := getct() - tStart

  rate := (25 * 32 * 512 * (msPerTick / 10)) / (tElapsed / 10)
  serial.fstr2(@"%d ms, %d KB/s\r\n", tElapsed / msPerTick, rate)

  ' --- Multi-sector x64 ---
  serial.fstr0(@"Multi-sector x64 (16 reads)... ")
  sector := BENCH_SECTOR_BASE
  tStart := getct()
  repeat 16
    readResult := sd.readSectorsRaw(sector, 64, @sharedPool)
    sector += 64
  tElapsed := getct() - tStart

  rate := (16 * 64 * 512 * (msPerTick / 10)) / (tElapsed / 10)
  serial.fstr2(@"%d ms, %d KB/s\r\n", tElapsed / msPerTick, rate)

  serial.fstr0(@"\rBenchmark complete.\r\n")

  ' Clean up if we initialized raw access
  if (not wasMounted)
    sd.stop()


PUB do_touch() | p_filename, handle

'' Create empty file or update timestamp

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_filename := token(1)
  handle := sd.createFileNew(p_filename)

  if (handle >= 0)
    sd.closeFileHandle(handle)
    serial.fstr1(@"Created: %s\r\n", p_filename)
  else
    serial.fstr1(@"Failed to create: %s\r\n", p_filename)


PUB do_label() | p_label

'' Display or set volume label
'' Usage: label          - show current volume label
''        label NEWNAME  - set new volume label (max 11 chars)

  if (ntokens > 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  if (ntokens == 1)
    serial.fstr1(@"Volume label: %s\r\n", sd.volumeLabel())
  else
    p_label := token(1)
    if strsize(p_label) > 11
      serial.fstr0(@"Label too long (max 11 characters)\r\n")
      return
    if sd.setVolumeLabel(p_label)
      serial.fstr1(@"Volume label set to: %s\r\n", sd.volumeLabel())
    else
      serial.fstr0(@"Failed to set volume label\r\n")


PUB not_implemented()

  serial.fstr1(@"%s is not implemented\r\n", token(0))


CON { helper methods }


PRI write_demo_file(p_name, p_content) | handle, len

'' Write demo content to file

  len := strsize(p_content)
  serial.fstr2(@"  Writing %s (%d bytes)...\r\n", p_name, len)

  handle := sd.createFileNew(p_name)
  if (handle < 0)
    serial.fstr0(@"    ERROR: Could not create file\r\n")
    return

  sd.writeHandle(handle, p_content, len)
  sd.closeFileHandle(handle)


PRI show_card_summary() | total_mb, free_mb

'' Show brief card summary after mount

  total_mb := sd.cardSizeSectors() / 2048
  free_mb := sd.freeSpace() / 2048

  serial.fstr1(@"  Volume: %s\r\n", sd.volumeLabel())
  serial.fstr2(@"  Size: %d MB, Free: %d MB\r\n", total_mb, free_mb)
  serial.fstr1(@"  SPI: %d Hz\r\n", sd.getSPIFrequency())


PRI check_mount() : status

'' Returns true if SD card is mounted

  status := mounted
  if (status == false)
    serial.fstr0(@"SD card not mounted. Use 'mount' command first.\r\n")


PRI go_up_directory() | i, len

'' Navigate up one directory level

  len := strsize(@cwd)
  if (len <= 1)                                                 ' already at root
    return

  ' Find last slash
  i := len - 1
  if (cwd[i] == "/")
    i--

  repeat while i > 0
    if (cwd[i] == "/")
      quit
    i--

  if (i == 0)
    bytemove(@cwd, @"/", 2)                                     ' back to root
  else
    cwd[i + 1] := 0                                             ' truncate path

  sd.changeDirectory(@"..")


PRI update_cwd(p_path) | len, cwd_len

'' Update current working directory string

  cwd_len := strsize(@cwd)
  len := strsize(p_path)

  if (cwd_len + len + 2 >= MAX_PATH)
    return                                                      ' path too long

  ' Add separator if needed
  if (cwd[cwd_len - 1] <> "/")
    cwd[cwd_len++] := "/"

  ' Append new directory
  bytemove(@cwd + cwd_len, p_path, len + 1)


PRI bad_syntax()

  serial.fstr0(@"Syntax error. Type 'help' for command list.\r\n")


CON { audit sub-methods }


PRI auditRunTest(pTestName, passed)

'' Record and display a single audit test result

  if (passed)
    passCount++
    serial.fstr1(@"  [PASS] %s\r\n", pTestName)
  else
    failCount++
    serial.fstr1(@"  [FAIL] %s\r\n", pTestName)


PRI auditMBR() | result

'' Audit MBR structure (sector 0)

  serial.fstr0(@"--- MBR ---\r\n")

  sd.readSectorRaw(0, @buffer)

  auditRunTest(@"MBR boot signature ($AA55)", WORD[@buffer + $1FE] == MBR_SIGNATURE)

  result := buffer[$1BE]
  auditRunTest(@"Partition 1 boot flag ($00/$80)", result == $00 OR result == $80)

  result := buffer[$1C2]
  auditRunTest(@"Partition type ($0C = FAT32 LBA)", result == PARTITION_TYPE_FAT32_LBA)

  result := LONG[@buffer + $1C6]
  auditRunTest(@"Partition start > 0", result > 0)
  serial.fstr1(@"    Partition start: sector %d\r\n", result)

  result := LONG[@buffer + $1CA]
  auditRunTest(@"Partition size > 0", result > 0)
  serial.fstr1(@"    Partition size: %d sectors\r\n\r\n", result)


PRI auditVBR() | result

'' Audit VBR (primary boot sector at partition start)

  serial.fstr0(@"--- VBR ---\r\n")

  sd.readSectorRaw(geoPartStart, @buffer)

  result := buffer[0]
  auditRunTest(@"VBR jump ($EB or $E9)", result == $EB OR result == $E9)

  auditRunTest(@"VBR boot signature ($AA55)", WORD[@buffer + $1FE] == MBR_SIGNATURE)

  result := WORD[@buffer + $0B]
  auditRunTest(@"Bytes/sector = 512", result == 512)

  result := buffer[$0D]
  auditRunTest(@"Sectors/cluster power of 2", result >= 1 AND result <= 128 AND (result & (result - 1)) == 0)
  serial.fstr1(@"    Sectors/cluster: %d\r\n", result)

  result := WORD[@buffer + $0E]
  auditRunTest(@"Reserved sectors = 32", result == 32)

  result := buffer[$10]
  auditRunTest(@"Number of FATs = 2", result == 2)

  result := WORD[@buffer + $11]
  auditRunTest(@"Root entry count = 0 (FAT32)", result == 0)

  result := WORD[@buffer + $13]
  auditRunTest(@"Total sectors 16-bit = 0", result == 0)

  result := buffer[$15]
  auditRunTest(@"Media type = $F8", result == $F8)

  result := WORD[@buffer + $16]
  auditRunTest(@"FAT size 16-bit = 0", result == 0)

  result := LONG[@buffer + $1C]
  auditRunTest(@"Hidden sectors = partition start", result == geoPartStart)

  auditRunTest(@"Total sectors 32-bit > 0", geoTotalSec > 0)
  serial.fstr1(@"    Total sectors: %d\r\n", geoTotalSec)

  auditRunTest(@"Sectors per FAT > 0", geoSecPerFat > 0)
  serial.fstr1(@"    Sectors/FAT: %d\r\n", geoSecPerFat)

  result := LONG[@buffer + $2C]
  auditRunTest(@"Root cluster = 2", result == 2)

  result := WORD[@buffer + $30]
  auditRunTest(@"FSInfo at sector 1", result == 1)

  result := WORD[@buffer + $32]
  auditRunTest(@"Backup boot at sector 6", result == 6)

  result := buffer[$42]
  auditRunTest(@"Extended boot sig = $29", result == EXT_BOOT_SIG)

  result := true
  if buffer[$52] <> "F" OR buffer[$53] <> "A" OR buffer[$54] <> "T" OR buffer[$55] <> "3" OR buffer[$56] <> "2"
    result := false
  auditRunTest(@"FS type = FAT32", result)
  serial.fstr0(@"\r\n")


PRI auditBackupVBR() | idx, mismatch

'' Verify backup VBR matches primary

  serial.fstr0(@"--- Backup VBR ---\r\n")

  sd.readSectorRaw(geoPartStart, @buffer)
  sd.readSectorRaw(geoPartStart + 6, @buf2)

  mismatch := false
  repeat idx from 0 to 511
    if (buffer[idx] <> buf2[idx])
      mismatch := true
      quit

  auditRunTest(@"Backup VBR matches primary", mismatch == false)
  serial.fstr0(@"\r\n")


PRI auditFSInfo() | result, idx, mismatch

'' Verify FSInfo sector and backup

  serial.fstr0(@"--- FSInfo ---\r\n")

  sd.readSectorRaw(geoPartStart + 1, @buffer)

  result := LONG[@buffer]
  auditRunTest(@"Lead signature ($41615252)", result == FSINFO_SIG1)

  result := LONG[@buffer + 484]
  auditRunTest(@"Struct signature ($61417272)", result == FSINFO_SIG2)

  result := LONG[@buffer + $1FC]
  auditRunTest(@"Trail signature ($AA550000)", result == FSINFO_TRAIL_SIG)

  result := LONG[@buffer + 488]
  auditRunTest(@"Free cluster count set", result <> 0)
  serial.fstr1(@"    Free clusters: %d\r\n", result)

  result := LONG[@buffer + 492]
  auditRunTest(@"Next free hint valid", result == $FFFFFFFF OR result >= 2)

  ' Check backup FSInfo
  sd.readSectorRaw(geoPartStart + 1, @buffer)
  sd.readSectorRaw(geoPartStart + 7, @buf2)

  mismatch := false
  repeat idx from 0 to 511
    if (buffer[idx] <> buf2[idx])
      mismatch := true
      quit

  auditRunTest(@"Backup FSInfo matches primary", mismatch == false)
  serial.fstr0(@"\r\n")


PRI auditFAT() | result, idx, mismatch

'' Verify FAT table entries and consistency

  serial.fstr0(@"--- FAT Table ---\r\n")

  sd.readSectorRaw(geoFat1Start, @buffer)

  result := LONG[@buffer]
  auditRunTest(@"FAT[0] = $0FFFFFF8 (media)", result == $0FFFFFF8)

  result := LONG[@buffer + 4]
  auditRunTest(@"FAT[1] = $0FFFFFFF (EOC)", result == $0FFFFFFF)

  result := LONG[@buffer + 8]
  auditRunTest(@"FAT[2] = $0FFFFFFF (root EOC)", result == $0FFFFFFF)

  result := LONG[@buffer + 12]
  auditRunTest(@"FAT[3] = 0 (free)", result == 0)

  ' Compare FAT1 and FAT2 first sector
  sd.readSectorRaw(geoFat2Start, @buf2)

  mismatch := false
  repeat idx from 0 to 511
    if (buffer[idx] <> buf2[idx])
      mismatch := true
      quit

  auditRunTest(@"FAT1 first sector == FAT2", mismatch == false)
  serial.fstr0(@"\r\n")


PRI auditRootDir() | result

'' Verify root directory structure

  serial.fstr0(@"--- Root Directory ---\r\n")

  sd.readSectorRaw(geoDataStart, @buffer)

  result := buffer[$0B]
  auditRunTest(@"Volume label entry (attr=$08)", result == $08)

  result := buffer[0]
  auditRunTest(@"Valid volume label chars", result >= $20 AND result <= $7E)

  result := buffer[$20]
  auditRunTest(@"Second entry valid or end", result == $00 OR result == $E5 OR (result >= $20 AND result <= $7E))
  serial.fstr0(@"\r\n")


PRI auditMountTest() | result

'' Test mount/unmount cycle

  serial.fstr0(@"--- Mount Test ---\r\n")

  result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
  auditRunTest(@"mount() succeeds", result)

  if (result)
    result := sd.freeSpace()
    auditRunTest(@"Free space > 0", result > 0)
    serial.fstr1(@"    Free: %d sectors\r\n", result)
    sd.unmount()

  serial.fstr0(@"\r\n")


CON { fsck sub-methods }


PRI fsckPass1() | idx, mismatch, fsinfoDirty, startRepairs

'' Pass 1: Check and repair structural elements

  serial.fstr0(@"--- Pass 1: Structural Integrity ---\r\n")
  startRepairs := repairCount

  ' === VBR backup (sector 6) ===
  sd.readSectorRaw(geoPartStart, @buffer)
  sd.readSectorRaw(geoPartStart + 6, @buf2)

  mismatch := false
  repeat idx from 0 to 511
    if (buffer[idx] <> buf2[idx])
      mismatch := true
      quit

  if (mismatch)
    serial.fstr0(@"  REPAIR: Backup VBR mismatch - copying\r\n")
    sd.writeSectorRaw(geoPartStart + 6, @buffer)
    repairCount++
  else
    serial.fstr0(@"  [OK] Backup VBR matches\r\n")

  ' === FSInfo signatures (sector 1) ===
  sd.readSectorRaw(geoPartStart + 1, @buffer)
  fsinfoDirty := false

  if (LONG[@buffer] <> FSINFO_SIG1)
    serial.fstr0(@"  REPAIR: FSInfo lead signature\r\n")
    LONG[@buffer] := FSINFO_SIG1
    fsinfoDirty := true
    repairCount++

  if (LONG[@buffer + 484] <> FSINFO_SIG2)
    serial.fstr0(@"  REPAIR: FSInfo struct signature\r\n")
    LONG[@buffer + 484] := FSINFO_SIG2
    fsinfoDirty := true
    repairCount++

  if (LONG[@buffer + $1FC] <> FSINFO_TRAIL_SIG)
    serial.fstr0(@"  REPAIR: FSInfo trail signature\r\n")
    LONG[@buffer + $1FC] := FSINFO_TRAIL_SIG
    fsinfoDirty := true
    repairCount++

  if (fsinfoDirty)
    sd.writeSectorRaw(geoPartStart + 1, @buffer)
  else
    serial.fstr0(@"  [OK] FSInfo signatures\r\n")

  ' === FSInfo backup (sector 7) ===
  sd.readSectorRaw(geoPartStart + 1, @buffer)
  sd.readSectorRaw(geoPartStart + 7, @buf2)

  mismatch := false
  repeat idx from 0 to 511
    if (buffer[idx] <> buf2[idx])
      mismatch := true
      quit

  if (mismatch)
    serial.fstr0(@"  REPAIR: Backup FSInfo mismatch - copying\r\n")
    sd.writeSectorRaw(geoPartStart + 7, @buffer)
    repairCount++
  else
    serial.fstr0(@"  [OK] Backup FSInfo matches\r\n")

  ' === FAT[0] media type ===
  sd.readSectorRaw(geoFat1Start, @buffer)

  if ((LONG[@buffer] & FAT_MASK) <> ($0FFFFFF8 & FAT_MASK))
    serial.fstr0(@"  REPAIR: FAT[0] media type\r\n")
    LONG[@buffer] := $0FFFFFF8 | (LONG[@buffer] & $F0000000)
    sd.writeSectorRaw(geoFat1Start, @buffer)
    repairCount++
  else
    serial.fstr0(@"  [OK] FAT[0] media type\r\n")

  ' === FAT[1] EOC marker ===
  if ((LONG[@buffer + 4] & FAT_MASK) <> FAT_EOC)
    serial.fstr0(@"  REPAIR: FAT[1] EOC marker\r\n")
    LONG[@buffer + 4] := FAT_EOC | (LONG[@buffer + 4] & $F0000000)
    sd.writeSectorRaw(geoFat1Start, @buffer)
    repairCount++
  else
    serial.fstr0(@"  [OK] FAT[1] EOC marker\r\n")

  ' === FAT[2] root cluster ===
  if ((LONG[@buffer + 8] & FAT_MASK) == FAT_FREE)
    serial.fstr0(@"  REPAIR: FAT[2] root cluster was free\r\n")
    LONG[@buffer + 8] := FAT_EOC | (LONG[@buffer + 8] & $F0000000)
    sd.writeSectorRaw(geoFat1Start, @buffer)
    repairCount++
  else
    serial.fstr0(@"  [OK] FAT[2] root cluster\r\n")

  serial.fstr1(@"  Pass 1: %d repairs\r\n\r\n", repairCount - startRepairs)


PRI fsckPass2() | startRepairs

'' Pass 2: Walk directory tree and validate all cluster chains

  serial.fstr0(@"--- Pass 2: Directory & Chain Validation ---\r\n")
  startRepairs := repairCount

  ' Clear cluster bitmap
  longfill(@sharedPool, 0, BITMAP_LONGS)

  ' Mark clusters 0 and 1 as used
  fsckSetBit(0)
  fsckSetBit(1)

  ' CRITICAL: Validate root chain BEFORE scanning directories
  fsckValidateChain(geoRootClus, 0, true)

  ' Scan directory tree
  dirCount := 0
  fileCount := 0
  scanDepth := 0
  fsckScanDir(geoRootClus)

  serial.fstr2(@"  Dirs: %d  Files: %d\r\n", dirCount, fileCount)
  serial.fstr1(@"  Pass 2: %d repairs\r\n\r\n", repairCount - startRepairs)


PRI fsckScanDir(dirCluster) | sector, entSector, entIdx, pEntry, attr, startClus, fSize, name0, nextClus

'' Recursively scan directory, validating all entries and chains

  dirCount++
  scanDepth++

  if (scanDepth > MAX_DIR_DEPTH)
    serial.fstr0(@"  WARNING: Max dir depth exceeded\r\n")
    warningCount++
    scanDepth--
    return

  ' Follow directory cluster chain
  repeat while dirCluster >= 2 AND dirCluster < (geoTotalClus + 2)
    sector := fsckClus2Sec(dirCluster)

    ' Read each sector in this cluster
    repeat entSector from 0 to geoSecPerClus - 1
      sd.readSectorRaw(sector + entSector, @buffer)

      ' Process 16 directory entries per sector
      repeat entIdx from 0 to 15
        pEntry := @buffer + (entIdx * 32)
        name0 := BYTE[pEntry]

        ' $00 = end of directory
        if (name0 == $00)
          scanDepth--
          return

        ' $E5 = deleted entry
        if (name0 == $E5)
          next

        attr := BYTE[pEntry + $0B]

        ' Long filename entry (attr $0F)
        if ((attr & $3F) == $0F)
          next

        ' Volume label
        if (attr & $08)
          next

        ' Skip . and .. entries
        if (fsckIsDot(pEntry))
          next

        ' Extract start cluster and file size
        startClus := WORD[pEntry + $1A] | (WORD[pEntry + $14] << 16)
        fSize := LONG[pEntry + $1C]

        if (attr & $10)
          ' --- Subdirectory ---
          if (startClus >= 2 AND startClus < (geoTotalClus + 2))
            fsckValidateChain(startClus, 0, true)
            fsckScanDir(startClus)
            ' Re-read our sector after recursion
            sd.readSectorRaw(sector + entSector, @buffer)
          elseif (startClus <> 0)
            serial.fstr1(@"  ERROR: Bad dir start cluster %d\r\n", startClus)
            errorCount++
        else
          ' --- Regular file ---
          fileCount++
          if (startClus >= 2 AND startClus < (geoTotalClus + 2))
            fsckValidateChain(startClus, fSize, false)
          elseif (startClus == 0 AND fSize > 0)
            serial.fstr1(@"  ERROR: File has size %d but no cluster\r\n", fSize)
            errorCount++

    ' Advance to next cluster in directory chain
    nextClus := fsckReadFAT(dirCluster) & FAT_MASK
    if (nextClus >= FAT_EOC_MIN)
      quit
    if (nextClus < 2 OR nextClus >= (geoTotalClus + 2))
      serial.fstr1(@"  ERROR: Bad cluster in dir chain: %d\r\n", nextClus)
      errorCount++
      quit
    dirCluster := nextClus

  scanDepth--


PRI fsckValidateChain(startClus, fSize, isDir) | clus, nextClus, chainLen, expectedLen

'' Follow and validate a cluster chain, marking bitmap

  chainLen := 0
  clus := startClus

  repeat while clus >= 2 AND clus < (geoTotalClus + 2)
    ' Check for cross-link
    if (fsckTestBit(clus))
      serial.fstr1(@"  ERROR: Cross-linked cluster %d\r\n", clus)
      errorCount++
      return

    ' Mark as referenced
    fsckSetBit(clus)
    chainLen++

    ' Safety: detect loops
    if (chainLen > MAX_CHAIN_LENGTH)
      serial.fstr1(@"  ERROR: Chain too long from cluster %d\r\n", startClus)
      errorCount++
      return

    ' Read next in chain
    nextClus := fsckReadFAT(clus) & FAT_MASK

    ' End of chain?
    if (nextClus >= FAT_EOC_MIN)
      quit

    ' Bad reference?
    if (nextClus < 2 OR (nextClus >= (geoTotalClus + 2) AND nextClus <> FAT_BAD))
      serial.fstr1(@"  ERROR: Bad ref %d", nextClus)
      serial.fstr1(@" from cluster %d\r\n", startClus)
      ' Truncate chain
      fsckWriteFAT(clus, FAT_EOC)
      serial.fstr1(@"  REPAIR: Truncated at cluster %d\r\n", clus)
      repairCount++
      quit

    ' Bad cluster marker
    if (nextClus == FAT_BAD)
      quit

    clus := nextClus

  ' Check chain length vs expected for files
  if (not isDir AND fSize > 0)
    expectedLen := (fSize + (geoSecPerClus * 512) - 1) / (geoSecPerClus * 512)
    if (chainLen <> expectedLen)
      serial.fstr2(@"  WARNING: Chain %d clusters, expected %d\r\n", chainLen, expectedLen)
      warningCount++


PRI fsckPass3() | clus, fatVal, lostCount, startRepairs

'' Pass 3: Find and free lost clusters

  serial.fstr0(@"--- Pass 3: Lost Cluster Recovery ---\r\n")
  startRepairs := repairCount
  lostCount := 0

  repeat clus from 2 to geoTotalClus + 1
    if (clus >= MAX_BITMAP_CLUSTERS)
      quit

    ' Progress dot every 100K clusters
    if ((clus & $1FFFF) == 0)
      serial.tx(".")

    if (not fsckTestBit(clus))
      fatVal := fsckReadFAT(clus) & FAT_MASK
      if (fatVal <> FAT_FREE AND fatVal <> FAT_BAD)
        fsckWriteFAT(clus, FAT_FREE)
        lostCount++

  ' Flush pending FAT writes
  fsckFlushFAT()

  if (lostCount > 0)
    serial.fstr1(@"\r  REPAIR: Freed %d lost clusters\r\n", lostCount)
    repairCount += lostCount
  else
    serial.fstr0(@"  [OK] No lost clusters\r\n")

  serial.fstr1(@"  Pass 3: %d repairs\r\n\r\n", repairCount - startRepairs)


PRI fsckPass4() | fatSector, entIdx, clus, fatVal, freeCount, syncCount, mismatch, idx, startRepairs

'' Pass 4: Sync FAT1 -> FAT2 and correct free cluster count

  serial.fstr0(@"--- Pass 4: FAT Sync & Free Count ---\r\n")
  startRepairs := repairCount

  ' Ensure prior writes flushed
  fsckFlushFAT()

  freeCount := 0
  syncCount := 0
  clus := 0

  repeat fatSector from 0 to geoSecPerFat - 1
    ' Progress dot every 1000 sectors
    if ((fatSector & $3FF) == 0)
      serial.tx(".")

    ' Read FAT1 sector
    sd.readSectorRaw(geoFat1Start + fatSector, @buffer)

    ' Count free clusters
    repeat entIdx from 0 to 127
      if (clus >= 2 AND clus < (geoTotalClus + 2))
        fatVal := LONG[@buffer + (entIdx * 4)] & FAT_MASK
        if (fatVal == FAT_FREE)
          freeCount++
      clus++

    ' Compare with FAT2
    sd.readSectorRaw(geoFat2Start + fatSector, @buf2)

    mismatch := false
    repeat idx from 0 to 511
      if (buffer[idx] <> buf2[idx])
        mismatch := true
        quit

    if (mismatch)
      sd.writeSectorRaw(geoFat2Start + fatSector, @buffer)
      syncCount++

  if (syncCount > 0)
    serial.fstr1(@"\r  REPAIR: Synced %d FAT sectors\r\n", syncCount)
    repairCount += syncCount
  else
    serial.fstr0(@"\r  [OK] FAT1 and FAT2 in sync\r\n")

  serial.fstr1(@"  Free clusters: %d\r\n", freeCount)

  ' Update FSInfo free cluster count
  sd.readSectorRaw(geoPartStart + 1, @buffer)

  if (LONG[@buffer + 488] <> freeCount)
    serial.fstr2(@"  REPAIR: FSInfo free count %d -> %d\r\n", LONG[@buffer + 488], freeCount)
    LONG[@buffer + 488] := freeCount
    sd.writeSectorRaw(geoPartStart + 1, @buffer)
    sd.writeSectorRaw(geoPartStart + 7, @buffer)
    repairCount++
  else
    serial.fstr0(@"  [OK] FSInfo free count correct\r\n")

  serial.fstr1(@"  Pass 4: %d repairs\r\n\r\n", repairCount - startRepairs)


PRI fsckReadFAT(cluster) : value | sector, offset

'' Read a FAT entry with sector caching

  sector := geoFat1Start + (cluster >> 7)
  offset := (cluster & $7F) * 4

  if (sector <> fatBufSector)
    fsckFlushFAT()
    sd.readSectorRaw(sector, @fatBuf)
    fatBufSector := sector

  value := LONG[@fatBuf + offset]


PRI fsckWriteFAT(cluster, value) | sector, offset, existing

'' Write a FAT entry with caching, preserving upper 4 bits

  sector := geoFat1Start + (cluster >> 7)
  offset := (cluster & $7F) * 4

  if (sector <> fatBufSector)
    fsckFlushFAT()
    sd.readSectorRaw(sector, @fatBuf)
    fatBufSector := sector

  existing := LONG[@fatBuf + offset]
  LONG[@fatBuf + offset] := (value & FAT_MASK) | (existing & $F0000000)
  fatBufDirty := true


PRI fsckFlushFAT()

'' Write cached FAT sector to both FAT1 and FAT2 if dirty

  if (fatBufDirty AND fatBufSector >= 0)
    sd.writeSectorRaw(fatBufSector, @fatBuf)
    sd.writeSectorRaw(fatBufSector - geoFat1Start + geoFat2Start, @fatBuf)
    fatBufDirty := false


PRI fsckClus2Sec(cluster) : sector

'' Convert cluster number to absolute sector

  sector := geoDataStart + ((cluster - 2) * geoSecPerClus)


PRI fsckSetBit(cluster)

'' Set bit in cluster bitmap

  sharedPool[cluster >> 5] |= (1 << (cluster & $1F))


PRI fsckTestBit(cluster) : result

'' Test bit in cluster bitmap

  result := (sharedPool[cluster >> 5] >> (cluster & $1F)) & 1


PRI fsckIsDot(pEntry) : result

'' Check if directory entry is . or ..

  result := false
  if (BYTE[pEntry] == ".")
    if (BYTE[pEntry + 1] == " " OR BYTE[pEntry + 1] == ".")
      result := true


CON { shared utility methods }


PRI confirmYN(p_prompt) : confirmed | c

'' Prompt user for y/n confirmation with 10-second timeout
'' Default is NO (just pressing Enter returns false, timeout returns false)

  serial.fstr1(@"%s (y/N)? ", p_prompt)
  c := serial.rxtime(10_000)
  if (c == "y" or c == "Y")
    serial.fstr0(@"yes\r\n")
    confirmed := true
  else
    serial.fstr0(@"no\r\n")
    confirmed := false


PRI initRawAccess() : ok

'' Initialize card for raw sector access (no mount)
'' Used by audit/fsck/bench when card is not mounted

  ok := sd.initCardOnly(SD_CS, SD_MOSI, SD_MISO, SD_SCK)


PRI readGeometry() : ok | numFats

'' Read MBR and VBR to extract filesystem geometry.
'' Populates all geo* VARs needed by audit and fsck.

  ' Read MBR to get partition start
  sd.readSectorRaw(0, @buf2)
  if WORD[@buf2 + $1FE] <> MBR_SIGNATURE
    serial.fstr0(@"  ERROR: Invalid MBR signature\r\n")
    return false

  geoPartStart := LONG[@buf2 + $1C6]
  if geoPartStart == 0
    serial.fstr0(@"  ERROR: Partition start is 0\r\n")
    return false

  ' Read VBR (Volume Boot Record)
  sd.readSectorRaw(geoPartStart, @buf2)
  if WORD[@buf2 + $1FE] <> MBR_SIGNATURE
    serial.fstr0(@"  ERROR: Invalid VBR signature\r\n")
    return false

  ' Extract geometry fields
  geoSecPerClus := buf2[$0D]
  geoReservedSec := WORD[@buf2 + $0E]
  numFats := buf2[$10]
  geoSecPerFat := LONG[@buf2 + $24]
  geoTotalSec := LONG[@buf2 + $20]
  geoRootClus := LONG[@buf2 + $2C]

  ' Validate critical fields
  if geoSecPerClus == 0 OR geoSecPerFat == 0 OR geoTotalSec == 0
    serial.fstr0(@"  ERROR: Zero in critical VBR field\r\n")
    return false

  if numFats < 1 OR numFats > 2
    serial.fstr1(@"  ERROR: Invalid number of FATs: %d\r\n", numFats)
    return false

  ' Compute derived values
  geoFat1Start := geoPartStart + geoReservedSec
  geoFat2Start := geoFat1Start + geoSecPerFat
  geoDataStart := geoFat1Start + (numFats * geoSecPerFat)
  geoTotalClus := (geoTotalSec - geoReservedSec - (numFats * geoSecPerFat)) / geoSecPerClus

  ok := true


PRI lcstr(p_str) : p_lcstr | c

'' Converts p_str to lowercase

  p_lcstr := p_str

  repeat strsize(p_str)
    c := byte[p_str]
    if (c >= "A") && (c <= "Z")
      byte[p_str] := c + 32
    ++p_str


CON { inline parser }


PRI parserReset()

' Reset command input buffer and tokens

  bytefill(@cliBuf, 0, CLI_BUF_SIZE)
  cliIdx := 0
  longfill(@tkPtrs, 0, CLI_MAX_TKNS)
  ntokens := 0


PRI enqueue(c) : done

' Add character to input buffer
' -- returns true when CR received

  if (c == 13)                                                  ' CR = end of input
    cliBuf[cliIdx] := 0                                         '  terminate buffer
    return true

  if (c == 10)                                                  ' LF = ignore
    return false

  if (c == 8) and (cliIdx > 0)                                 ' backspace?
    cliBuf[--cliIdx] := 0                                       '  erase last char
    return false

  if (cliIdx < CLI_BUF_SIZE - 2)                                ' room in buffer?
    cliBuf[cliIdx++] := c                                       '  add character

  return false


PRI parse() : count | p

' Parse input buffer into tokens separated by spaces/tabs
' -- returns token count

  longfill(@tkPtrs, 0, CLI_MAX_TKNS)
  ntokens := 0

  if (cliIdx == 0)                                              ' nothing to parse
    return 0

  p := @cliBuf

  repeat while (ntokens < CLI_MAX_TKNS)
    ' skip separators (space, tab)
    repeat while (byte[p] == " ") or (byte[p] == 9)
      p++
    if (byte[p] == 0)                                           ' end of string
      quit
    tkPtrs[ntokens++] := p                                      ' save token start
    ' walk to next separator or end
    repeat while (byte[p] <> 0)
      if (byte[p] == " ") or (byte[p] == 9)
        byte[p++] := 0                                          ' terminate token
        quit
      p++

  return ntokens


PRI token(idx) : p_str

' Returns pointer to parsed token at index

  if (idx >= 0) and (idx < CLI_MAX_TKNS)
    return tkPtrs[idx]


PRI idCommand(pCmdStr) : eCmdId | nIdx, pEntry, pStr

' Look up command string in command table, return enum value

  eCmdId := CMD_UNKNOWN

  repeat nIdx from 0 to cmdCt - 1
    pEntry := @@WORD[@cmdTable][nIdx]                           ' get pointer from table
    pStr := @BYTE[pEntry][1]                                    ' skip enum byte, point to string
    if strcomp(pCmdStr, pStr)
      eCmdId := BYTE[pEntry][0]                                 ' matched - return embedded enum
      quit


CON { strings / lists }


DAT { help text }

  s_Help        byte    13, 10
                byte    "  Navigation                          File Operations", 13, 10
                byte    "  mount       Mount SD card           type <f>    Show text (cat)", 13, 10
                byte    "  unmount     Unmount (eject)         hexdump <f> Hex dump (hd)", 13, 10
                byte    "  dir         List files (ls)         copy <s><d> Copy file (cp)", 13, 10
                byte    "  cd <path>   Change directory        ren <o> <n> Rename (mv)", 13, 10
                byte    "  pwd         Working directory       del <f>     Delete (rm)", 13, 10
                byte    "  mkdir <d>   Create directory        touch <f>   Create file", 13, 10
                byte    "  rmdir <d>   Remove directory        demo        Create demo files", 13, 10
                byte    "  Information                         Diagnostics & Utility", 13, 10
                byte    "  stats       Card stats (info)       audit       Check FS integrity", 13, 10
                byte    "  card        Card ID (cid)           fsck        Check & repair FS", 13, 10
                byte    "  version     Driver version          bench       Throughput test", 13, 10
                byte    "  label [n]   Volume label (vol)      format      Format SD card", 13, 10
                byte    "  cls         Clear screen            help        This help", 13, 10
                byte    0


DAT { command table }

' ------------------------------------------------------------
'   Adjust Command Set:
'    (1) add/remove enum in CON { command enums }
'    (2) add/remove entry             "name  BYTE  ENUM, CmdString, 0"
'    (3) add/remove pointer to entry  "WORD  @name"
' ------------------------------------------------------------

' Command entries: each contains [enum_byte, "string", 0]

cmdHelp       BYTE    CMD_HELP,      "help",      0
cmdVersion    BYTE    CMD_VERSION,   "version",   0
cmdCls        BYTE    CMD_CLS,       "cls",       0
cmdClear      BYTE    CMD_CLEAR,     "clear",     0
cmdMount      BYTE    CMD_MOUNT,     "mount",     0
cmdUnmount    BYTE    CMD_UNMOUNT,   "unmount",   0
cmdEject      BYTE    CMD_EJECT,     "eject",     0
cmdFormat     BYTE    CMD_FORMAT,    "format",    0
cmdStats      BYTE    CMD_STATS,     "stats",     0
cmdInfo       BYTE    CMD_INFO,      "info",      0
cmdDir        BYTE    CMD_DIR,       "dir",       0
cmdLs         BYTE    CMD_LS,        "ls",        0
cmdCd         BYTE    CMD_CD,        "cd",        0
cmdPwd        BYTE    CMD_PWD,       "pwd",       0
cmdMkdir      BYTE    CMD_MKDIR,     "mkdir",     0
cmdType       BYTE    CMD_TYPE,      "type",      0
cmdCat        BYTE    CMD_CAT,       "cat",       0
cmdHexdump    BYTE    CMD_HEXDUMP,   "hexdump",   0
cmdHd         BYTE    CMD_HD,        "hd",        0
cmdRen        BYTE    CMD_REN,       "ren",       0
cmdMv         BYTE    CMD_MV,        "mv",        0
cmdCopy       BYTE    CMD_COPY,      "copy",      0
cmdCp         BYTE    CMD_CP,        "cp",        0
cmdDel        BYTE    CMD_DEL,       "del",       0
cmdRm         BYTE    CMD_RM,        "rm",        0
cmdRmdir      BYTE    CMD_RMDIR,     "rmdir",     0
cmdDemo       BYTE    CMD_DEMO,      "demo",      0
cmdCard       BYTE    CMD_CARD,      "card",      0
cmdCid        BYTE    CMD_CID,       "cid",       0
cmdBenchmark  BYTE    CMD_BENCHMARK, "benchmark", 0
cmdPerf       BYTE    CMD_PERF,      "perf",      0
cmdTouch      BYTE    CMD_TOUCH,     "touch",     0
cmdAudit      BYTE    CMD_AUDIT,     "audit",     0
cmdFsck       BYTE    CMD_FSCK,      "fsck",      0
cmdBench      BYTE    CMD_BENCH,     "bench",     0
cmdLabel      BYTE    CMD_LABEL,     "label",     0
cmdVol        BYTE    CMD_VOL,       "vol",       0

cmdTable      ' first table-entry must follow immediately
              WORD    @cmdHelp, @cmdVersion, @cmdCls, @cmdClear
              WORD    @cmdMount, @cmdUnmount, @cmdEject, @cmdFormat
              WORD    @cmdStats, @cmdInfo, @cmdDir, @cmdLs
              WORD    @cmdCd, @cmdPwd, @cmdMkdir
              WORD    @cmdType, @cmdCat, @cmdHexdump, @cmdHd
              WORD    @cmdRen, @cmdMv, @cmdCopy, @cmdCp
              WORD    @cmdDel, @cmdRm, @cmdRmdir
              WORD    @cmdDemo, @cmdCard, @cmdCid
              WORD    @cmdBenchmark, @cmdPerf, @cmdTouch
              WORD    @cmdAudit, @cmdFsck, @cmdBench
              WORD    @cmdLabel, @cmdVol
cmdTableEnd   ' last entry must be immediately above this line
' ------------------------------------------------------------
cmdCt         BYTE    (@cmdTableEnd - @cmdTable) >> 1


DAT { demo file content }

  demo_hello    byte    "Hello from the P2 SD Card Filesystem!", 13, 10
                byte    "This file was created by the demo command.", 13, 10
                byte    0

  demo_readme   byte    "P2 SD Card Driver Demo", 13, 10
                byte    "======================", 13, 10
                byte    13, 10
                byte    "This SD card filesystem driver provides:", 13, 10
                byte    "- FAT32 support for cards up to 32GB", 13, 10
                byte    "- Multiple simultaneous file handles", 13, 10
                byte    "- High-speed SPI transfers with CRC", 13, 10
                byte    "- Smart pin hardware acceleration", 13, 10
                byte    13, 10
                byte    "Type 'help' for available commands.", 13, 10
                byte    0

  demo_numbers  byte    "1 One", 13, 10
                byte    "2 Two", 13, 10
                byte    "3 Three", 13, 10
                byte    "4 Four", 13, 10
                byte    "5 Five", 13, 10
                byte    "6 Six", 13, 10
                byte    "7 Seven", 13, 10
                byte    "8 Eight", 13, 10
                byte    "9 Nine", 13, 10
                byte    "10 Ten", 13, 10
                byte    0


CON { setup }


PUB setup()

'' Configure IO and objects for application

  serial.start(BR_TERM)                                         ' start terminal io


PUB wait_for_terminal(clear, delay)

'' Wait for terminal to be open and key pressed

  serial.rxflush()
  serial.rx()
  if (clear)
    serial.tx(serial.CLS)
    waitms(delay #> 0)


CON { license }

{{

  Terms of Use: MIT License

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

}}
