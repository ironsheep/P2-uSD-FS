'' =================================================================================================
''
''   File....... SD_demo_shell.spin2
''   Purpose.... Interactive command-line shell for SD card filesystem
''   Author..... Stephen M Moraco
''               Copyright (c) 2026 Iron Sheep Productions, LLC
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... FEB 2026
''   Updated.... 03 FEB 2026
''
'' =================================================================================================
''
''   Interactive shell for exploring SD card filesystem operations.
''   Supports both DOS-style (dir, type, del) and Unix-style (ls, cat, rm) commands.
''
''   Connect via serial terminal at 230,400 baud.
''   Type 'help' for list of available commands.
''
'' =================================================================================================

CON { timing }

  CLK_FREQ = 270_000_000                                        ' system freq as a constant
  MS_001   = CLK_FREQ / 1_000                                   ' ticks in 1ms
  US_001   = CLK_FREQ / 1_000_000                               ' ticks in 1us

  _clkfreq = CLK_FREQ                                           ' set system clock


CON { terminal }

  BR_TERM  = 230_400                                            ' terminal baud rate


CON { SD card pins - P2 Edge Module }

  SD_CS    = 60  { O }                                          ' directly directly directly chip select
  SD_SCK   = 61  { O }                                          ' serial clock
  SD_MOSI  = 59  { O }                                          ' master out, slave in
  SD_MISO  = 58  { I }                                          ' master in, slave out


CON { fixed io pins }

  PGM_RX   = 63  { I }                                          ' programming / debug
  PGM_TX   = 62  { O }


CON { constants }

  #true,  ON, OFF
  #false, NO, YES

  MAX_PATH    = 128                                             ' max path length
  SECTOR_SIZE = 512                                             ' SD sector size
  BUFFER_SIZE = 512                                             ' read/write buffer


OBJ

  cli   : "jm_parser"                                           '   command line input & parsing
  sd    : "SD_card_driver"                                      '   SD card filesystem driver
  term  : "jm_fullduplexserial"                                 ' * serial IO for terminal


VAR

  byte  buffer[BUFFER_SIZE]                                     ' general purpose buffer
  byte  pathbuf[MAX_PATH]                                       ' path buffer
  byte  cwd[MAX_PATH]                                           ' current working directory
  byte  ntokens                                                 ' number of parsed tokens
  byte  mounted                                                 ' mount status flag


PUB main() | len, idx

  setup()
  wait_for_terminal(false, 0)

  term.tx(term.CLS)
  term.fstr0(@"P2 SD Card Filesystem Shell\r")
  term.fstr0(@"- type 'help' for commands\r")
  term.fstr0(@"\r")

  ' Initialize current working directory
  bytemove(@cwd, @"/", 2)
  mounted := false

  repeat
    show_prompt()                                               ' prompt user
    len := get_command()                                        ' get input
    if (len > 0)                                                ' if command entered
      ntokens := cli.parse()                                    ' parse and count tokens
      if (ntokens)                                              ' if !0 tokens
        idx := cli.token_index(lcstr(cli.token(0)), @Commands)  ' lookup first in commands table
        run_command(idx)                                        ' run command code


PUB get_command() : len | c

'' Enter command from terminal window

  cli.reset()                                                   ' prep cli for new entry

  repeat
    c := term.rx()                                              ' get char from serial
    c := (c == 9) ? " " : c                                     ' convert tab to space
    if (c == 8)                                                 ' fix backspace
      term.str(string(8, " ", 8))                               '  for terminal
    else
      term.tx(c)                                                ' echo to terminal
    if cli.enqueue(c)                                           ' and to cli queue
      quit                                                      '  if terminated, we're done

  return cli.buffer_len()                                       ' report length of input


PUB show_prompt()

'' Display command prompt with current directory

  if (mounted)
    term.fstr1(@"\rSD:%s> ", @cwd)
  else
    term.fstr0(@"\rSD:(unmounted)> ")


CON { command handlers }


PUB run_command(idx)

'' Run command at index idx of Commands list

  if (idx < 0)
    term.fstr1(@"'%s' is not recognized as a command\r", cli.token(0))
    return

  case idx
    00     : show_help()                                        ' help
    01     : show_version()                                     ' version
    02, 03 : do_cls()                                           ' cls, clear
    04     : do_mount()                                         ' mount
    05, 06 : do_unmount()                                       ' unmount, eject
    07     : do_format()                                        ' format
    08, 09 : do_stats()                                         ' stats, info
    10, 11 : do_dir()                                           ' dir, ls
    12     : do_cd()                                            ' cd
    13     : do_pwd()                                           ' pwd
    14     : do_mkdir()                                         ' mkdir
    15, 16 : do_type()                                          ' type, cat
    17, 18 : do_hexdump()                                       ' hexdump, hd
    19, 20 : do_rename()                                        ' ren, mv
    21, 22 : do_copy()                                          ' copy, cp
    23, 24 : do_delete()                                        ' del, rm
    25     : do_rmdir()                                         ' rmdir
    26     : do_demo()                                          ' demo
    27, 28 : do_card_info()                                     ' card, cid
    29, 30 : do_benchmark()                                     ' benchmark, perf
    31     : do_touch()                                         ' touch
    other  : not_implemented()


PUB show_help()

'' Show available commands

  if (ntokens <> 1)
    bad_syntax()
    return

  term.str(@s_Help)


PUB show_version()

'' Show driver version info

  if (ntokens <> 1)
    bad_syntax()
    return

  term.fstr0(@"SD Card Driver - Iron Sheep Productions\r")
  term.fstr1(@"SPI Frequency: %d Hz\r", sd.getSPIFrequency())


PUB do_cls()

'' Clear terminal window

  if (ntokens <> 1)
    bad_syntax()
    return

  term.tx(term.CLS)


PUB do_mount() | result

'' Mount SD card filesystem

  if (ntokens <> 1)
    bad_syntax()
    return

  if (mounted)
    term.fstr0(@"SD card is already mounted\r")
    return

  term.fstr0(@"Mounting SD card...\r")
  result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)

  if (result)
    mounted := true
    bytemove(@cwd, @"/", 2)                                     ' reset to root
    term.fstr0(@"Mounted successfully\r")
    show_card_summary()
  else
    term.fstr1(@"Mount failed, error: %d\r", sd.error())


PUB do_unmount()

'' Unmount SD card filesystem

  if (ntokens <> 1)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  sd.unmount()
  mounted := false
  term.fstr0(@"SD card unmounted\r")


PUB do_format()

'' Format SD card (dangerous!)

  if (ntokens <> 1)
    bad_syntax()
    return

  term.fstr0(@"WARNING: Format will erase ALL data on the SD card!\r")
  term.fstr0(@"This feature is not yet implemented in this shell.\r")
  term.fstr0(@"Use SD_format_utility.spin2 instead.\r")


PUB do_stats() | free_sectors, total_sectors, free_mb, total_mb

'' Display filesystem statistics

  if (ntokens <> 1)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  total_sectors := sd.cardSizeSectors()
  free_sectors := sd.freeSpace()

  total_mb := total_sectors / 2048                              ' sectors to MB (512 * 2048 = 1MB)
  free_mb := free_sectors / 2048

  term.fstr0(@"\r--- SD Card Statistics ---\r")
  term.fstr2(@"Total size:    %d sectors (%d MB)\r", total_sectors, total_mb)
  term.fstr2(@"Free space:    %d sectors (%d MB)\r", free_sectors, free_mb)
  term.fstr1(@"Volume label:  %s\r", sd.volumeLabel())
  term.fstr1(@"SPI frequency: %d Hz\r", sd.getSPIFrequency())


PUB do_dir() | entry, result, count, total_size, attrib, size, p_name

'' List directory contents

  if (ntokens > 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  term.fstr1(@"\r Directory of %s\r\r", @cwd)
  term.fstr0(@"  Attr      Size  Name\r")
  term.fstr0(@"  ----  --------  --------------------------------\r")

  entry := 0
  count := 0
  total_size := 0

  repeat
    result := sd.readDirectory(entry++)
    if (result == 0)                                            ' no more entries
      quit

    p_name := sd.fileName()
    if (byte[p_name] == 0)                                      ' empty name, skip
      next

    attrib := sd.attributes()
    size := sd.fileSize()

    ' Format attributes
    term.fstr0(@"  ")
    term.tx((attrib & $10) ? "D" : "-")                         ' directory
    term.tx((attrib & $01) ? "R" : "-")                         ' read-only
    term.tx((attrib & $02) ? "H" : "-")                         ' hidden
    term.tx((attrib & $04) ? "S" : "-")                         ' system

    if (attrib & $10)                                           ' directory
      term.fstr1(@"    <DIR>  %s\r", p_name)
    else
      term.fstr2(@"  %8d  %s\r", size, p_name)
      total_size += size

    count++

  term.fstr0(@"\r")
  term.fstr2(@"  %d file(s), %d bytes\r", count, total_size)
  term.fstr1(@"  %d bytes free\r", sd.freeSpace() * SECTOR_SIZE)


PUB do_cd() | p_path

'' Change current directory

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_path := cli.token(1)

  ' Handle special cases
  if (strcomp(p_path, @"/") or strcomp(p_path, @"\\"))
    ' Go to root
    sd.changeDirectory(@"/")
    bytemove(@cwd, @"/", 2)
    return

  if (strcomp(p_path, @".."))
    ' Go up one level
    go_up_directory()
    return

  ' Try to change to specified directory
  if (sd.changeDirectory(p_path))
    update_cwd(p_path)
  else
    term.fstr1(@"Directory not found: %s\r", p_path)


PUB do_pwd()

'' Print working directory

  if (ntokens <> 1)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  term.fstr1(@"%s\r", @cwd)


PUB do_mkdir() | p_name, result

'' Create new directory

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_name := cli.token(1)
  result := sd.newDirectory(p_name)

  if (result)
    term.fstr1(@"Created directory: %s\r", p_name)
  else
    term.fstr1(@"Failed to create directory: %s\r", p_name)


PUB do_type() | p_filename, handle, bytes_read, total, c, i

'' Display contents of text file

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_filename := cli.token(1)
  handle := sd.openFileRead(p_filename)

  if (handle < 0)
    term.fstr1(@"File not found: %s\r", p_filename)
    return

  term.fstr0(@"\r")
  total := 0

  repeat
    bytes_read := sd.readHandle(handle, @buffer, BUFFER_SIZE - 1)
    if (bytes_read <= 0)
      quit

    ' Display as text
    repeat i from 0 to bytes_read - 1
      c := buffer[i]
      if (c == 13)                                              ' CR
        term.tx(13)
      elseif (c == 10)                                          ' LF - skip (CR handles newline)
        ' skip
      elseif (c >= 32 and c < 127)                              ' printable
        term.tx(c)
      else
        term.tx(".")                                            ' non-printable

    total += bytes_read

  sd.closeFileHandle(handle)
  term.fstr1(@"\r\r[%d bytes]\r", total)


PUB do_hexdump() | p_filename, handle, bytes_read, offset, i, c

'' Display file contents in hex format

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_filename := cli.token(1)
  handle := sd.openFileRead(p_filename)

  if (handle < 0)
    term.fstr1(@"File not found: %s\r", p_filename)
    return

  term.fstr0(@"\r")
  offset := 0

  repeat
    bytes_read := sd.readHandle(handle, @buffer, 16)
    if (bytes_read <= 0)
      quit

    ' Print offset
    term.fstr1(@"%.8x  ", offset)

    ' Print hex bytes
    repeat i from 0 to 15
      if (i < bytes_read)
        term.fstr1(@"%.2x ", buffer[i])
      else
        term.fstr0(@"   ")
      if (i == 7)
        term.tx(" ")

    term.fstr0(@" |")

    ' Print ASCII
    repeat i from 0 to bytes_read - 1
      c := buffer[i]
      if (c >= 32 and c < 127)
        term.tx(c)
      else
        term.tx(".")

    term.fstr0(@"|\r")
    offset += bytes_read

    ' Limit output to first 512 bytes
    if (offset >= 512)
      term.fstr0(@"... (truncated at 512 bytes)\r")
      quit

  sd.closeFileHandle(handle)
  term.fstr1(@"\r[%d bytes total]\r", sd.fileSizeHandle(handle) > 0 ? sd.fileSizeHandle(handle) : offset)


PUB do_rename() | p_old, p_new, result

'' Rename file or directory

  if (ntokens <> 3)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_old := cli.token(1)
  p_new := cli.token(2)

  result := sd.rename(p_old, p_new)

  if (result)
    term.fstr2(@"Renamed '%s' to '%s'\r", p_old, p_new)
  else
    term.fstr1(@"Failed to rename: %s\r", p_old)


PUB do_copy() | p_src, p_dst, h_src, h_dst, bytes_read, total

'' Copy file

  if (ntokens <> 3)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_src := cli.token(1)
  p_dst := cli.token(2)

  if (strcomp(p_src, p_dst))
    term.fstr0(@"Cannot copy file to itself\r")
    return

  h_src := sd.openFileRead(p_src)
  if (h_src < 0)
    term.fstr1(@"Source file not found: %s\r", p_src)
    return

  h_dst := sd.createFileNew(p_dst)
  if (h_dst < 0)
    sd.closeFileHandle(h_src)
    term.fstr1(@"Cannot create destination: %s\r", p_dst)
    return

  total := 0
  repeat
    bytes_read := sd.readHandle(h_src, @buffer, BUFFER_SIZE)
    if (bytes_read <= 0)
      quit
    sd.writeHandle(h_dst, @buffer, bytes_read)
    total += bytes_read

  sd.closeFileHandle(h_src)
  sd.closeFileHandle(h_dst)

  term.fstr2(@"Copied %d bytes to %s\r", total, p_dst)


PUB do_delete() | p_filename, result

'' Delete file

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_filename := cli.token(1)
  result := sd.deleteFile(p_filename)

  if (result)
    term.fstr1(@"Deleted: %s\r", p_filename)
  else
    term.fstr1(@"Failed to delete: %s\r", p_filename)


PUB do_rmdir()

'' Remove directory (must be empty)

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  term.fstr0(@"rmdir not yet implemented\r")


PUB do_demo() | handle, i

'' Create demo files

  if (ntokens <> 1)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  term.fstr0(@"Creating demo files...\r")

  ' Create text file 1
  write_demo_file(@"HELLO.TXT", @demo_hello)
  write_demo_file(@"README.TXT", @demo_readme)
  write_demo_file(@"NUMBERS.TXT", @demo_numbers)

  term.fstr0(@"Demo files created.\r")


PUB do_card_info() | cid[4], csd[4], mid, oid[3], pnm[6], prv, psn, mdt

'' Display card identification info

  if (ntokens <> 1)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  sd.readCIDRaw(@cid)

  ' Parse CID fields
  mid := cid.byte[0]
  oid[0] := cid.byte[1]
  oid[1] := cid.byte[2]
  oid[2] := 0
  bytemove(@pnm, @cid.byte[3], 5)
  pnm[5] := 0
  prv := cid.byte[8]
  psn := (cid.byte[9] << 24) | (cid.byte[10] << 16) | (cid.byte[11] << 8) | cid.byte[12]
  mdt := ((cid.byte[13] & $0F) << 8) | cid.byte[14]

  term.fstr0(@"\r--- SD Card Identification ---\r")
  term.fstr1(@"Manufacturer ID:  0x%.2x\r", mid)
  term.fstr1(@"OEM/Application:  %s\r", @oid)
  term.fstr1(@"Product Name:     %s\r", @pnm)
  term.fstr2(@"Product Revision: %d.%d\r", prv >> 4, prv & $0F)
  term.fstr1(@"Serial Number:    0x%.8x\r", psn)
  term.fstr2(@"Manufacture Date: %d/%d\r", (mdt >> 4) + 2000, mdt & $0F)
  term.fstr1(@"Card Size:        %d MB\r", sd.cardSizeSectors() / 2048)
  term.fstr1(@"SPI Frequency:    %d Hz\r", sd.getSPIFrequency())
  term.fstr1(@"High-Speed Mode:  %s\r", sd.isHighSpeedActive() ? @"Active" : @"Inactive")


PUB do_benchmark() | start, elapsed, i, handle, bytes, rate

'' Quick read/write benchmark

  if (ntokens <> 1)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  term.fstr0(@"\r--- Quick Benchmark ---\r")

  ' Write test
  term.fstr0(@"Write test (32KB)...")
  handle := sd.createFileNew(@"_BENCH_.TMP")
  if (handle < 0)
    term.fstr0(@" failed to create file\r")
    return

  bytefill(@buffer, $AA, BUFFER_SIZE)
  start := getct()

  repeat 64                                                     ' 64 x 512 = 32KB
    sd.writeHandle(handle, @buffer, BUFFER_SIZE)

  elapsed := getct() - start
  sd.closeFileHandle(handle)

  bytes := 64 * BUFFER_SIZE
  rate := (bytes * (clkfreq / 1000)) / elapsed                  ' bytes per ms -> KB/s
  term.fstr2(@" %d bytes in %d ms", bytes, elapsed / (clkfreq / 1000))
  term.fstr1(@" (%d KB/s)\r", rate)

  ' Read test
  term.fstr0(@"Read test (32KB)... ")
  handle := sd.openFileRead(@"_BENCH_.TMP")
  if (handle < 0)
    term.fstr0(@" failed to open file\r")
    return

  start := getct()

  repeat 64
    sd.readHandle(handle, @buffer, BUFFER_SIZE)

  elapsed := getct() - start
  sd.closeFileHandle(handle)

  rate := (bytes * (clkfreq / 1000)) / elapsed
  term.fstr2(@" %d bytes in %d ms", bytes, elapsed / (clkfreq / 1000))
  term.fstr1(@" (%d KB/s)\r", rate)

  ' Cleanup
  sd.deleteFile(@"_BENCH_.TMP")
  term.fstr0(@"Benchmark complete.\r")


PUB do_touch() | p_filename, handle

'' Create empty file or update timestamp

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_filename := cli.token(1)
  handle := sd.createFileNew(p_filename)

  if (handle >= 0)
    sd.closeFileHandle(handle)
    term.fstr1(@"Created: %s\r", p_filename)
  else
    term.fstr1(@"Failed to create: %s\r", p_filename)


PUB not_implemented()

  term.fstr1(@"%s is not implemented\r", cli.token(0))


CON { helper methods }


PRI write_demo_file(p_name, p_content) | handle, len

'' Write demo content to file

  len := strsize(p_content)
  term.fstr2(@"  Writing %s (%d bytes)...\r", p_name, len)

  handle := sd.createFileNew(p_name)
  if (handle < 0)
    term.fstr0(@"    ERROR: Could not create file\r")
    return

  sd.writeHandle(handle, p_content, len)
  sd.closeFileHandle(handle)


PRI show_card_summary() | total_mb, free_mb

'' Show brief card summary after mount

  total_mb := sd.cardSizeSectors() / 2048
  free_mb := sd.freeSpace() / 2048

  term.fstr1(@"  Volume: %s\r", sd.volumeLabel())
  term.fstr2(@"  Size: %d MB, Free: %d MB\r", total_mb, free_mb)
  term.fstr1(@"  SPI: %d Hz\r", sd.getSPIFrequency())


PRI check_mount() : status

'' Returns true if SD card is mounted

  status := mounted
  if (status == false)
    term.fstr0(@"SD card not mounted. Use 'mount' command first.\r")


PRI go_up_directory() | i, len

'' Navigate up one directory level

  len := strsize(@cwd)
  if (len <= 1)                                                 ' already at root
    return

  ' Find last slash
  i := len - 1
  if (cwd[i] == "/")
    i--

  repeat while i > 0
    if (cwd[i] == "/")
      quit
    i--

  if (i == 0)
    bytemove(@cwd, @"/", 2)                                     ' back to root
  else
    cwd[i + 1] := 0                                             ' truncate path

  sd.changeDirectory(@"..")


PRI update_cwd(p_path) | len, cwd_len

'' Update current working directory string

  cwd_len := strsize(@cwd)
  len := strsize(p_path)

  if (cwd_len + len + 2 >= MAX_PATH)
    return                                                      ' path too long

  ' Add separator if needed
  if (cwd[cwd_len - 1] <> "/")
    cwd[cwd_len++] := "/"

  ' Append new directory
  bytemove(@cwd + cwd_len, p_path, len + 1)


PRI bad_syntax()

  term.fstr0(@"Syntax error. Type 'help' for command list.\r")


PRI lcstr(p_str) : p_lcstr | c

'' Converts p_str to lowercase

  p_lcstr := p_str

  repeat strsize(p_str)
    c := byte[p_str]
    if (c >= "A") && (c <= "Z")
      byte[p_str] := c + 32
    ++p_str


CON { strings / lists }


DAT { help text }

  s_Help        byte    13
                byte    "  === Navigation ===", 13
                byte    "  mount        Mount SD card", 13
                byte    "  unmount      Safely unmount SD card (alias: eject)", 13
                byte    "  dir          List directory (alias: ls)", 13
                byte    "  cd <path>    Change directory", 13
                byte    "  pwd          Print working directory", 13
                byte    13
                byte    "  === File Operations ===", 13
                byte    "  type <file>  Display text file (alias: cat)", 13
                byte    "  hexdump <f>  Display file in hex (alias: hd)", 13
                byte    "  copy <s> <d> Copy file (alias: cp)", 13
                byte    "  ren <o> <n>  Rename file (alias: mv)", 13
                byte    "  del <file>   Delete file (alias: rm)", 13
                byte    "  touch <file> Create empty file", 13
                byte    "  mkdir <dir>  Create directory", 13
                byte    "  rmdir <dir>  Remove empty directory", 13
                byte    13
                byte    "  === Information ===", 13
                byte    "  stats        Show filesystem statistics (alias: info)", 13
                byte    "  card         Show card identification (alias: cid)", 13
                byte    "  benchmark    Quick read/write speed test (alias: perf)", 13
                byte    "  version      Show driver version", 13
                byte    13
                byte    "  === Utility ===", 13
                byte    "  demo         Create sample demo files", 13
                byte    "  cls          Clear screen (alias: clear)", 13
                byte    "  help         Show this help", 13
                byte    0


DAT { command table }

' Command lookup table - index matches case statement in run_command()

  Commands      byte    "help",      0                          ' 00
                byte    "version",   0                          ' 01
                byte    "cls",       0                          ' 02
                byte    "clear",     0                          ' 03
                byte    "mount",     0                          ' 04
                byte    "unmount",   0                          ' 05
                byte    "eject",     0                          ' 06
                byte    "format",    0                          ' 07
                byte    "stats",     0                          ' 08
                byte    "info",      0                          ' 09
                byte    "dir",       0                          ' 10
                byte    "ls",        0                          ' 11
                byte    "cd",        0                          ' 12
                byte    "pwd",       0                          ' 13
                byte    "mkdir",     0                          ' 14
                byte    "type",      0                          ' 15
                byte    "cat",       0                          ' 16
                byte    "hexdump",   0                          ' 17
                byte    "hd",        0                          ' 18
                byte    "ren",       0                          ' 19
                byte    "mv",        0                          ' 20
                byte    "copy",      0                          ' 21
                byte    "cp",        0                          ' 22
                byte    "del",       0                          ' 23
                byte    "rm",        0                          ' 24
                byte    "rmdir",     0                          ' 25
                byte    "demo",      0                          ' 26
                byte    "card",      0                          ' 27
                byte    "cid",       0                          ' 28
                byte    "benchmark", 0                          ' 29
                byte    "perf",      0                          ' 30
                byte    "touch",     0                          ' 31
                byte    0


DAT { demo file content }

  demo_hello    byte    "Hello from the P2 SD Card Filesystem!", 13, 10
                byte    "This file was created by the demo command.", 13, 10
                byte    0

  demo_readme   byte    "P2 SD Card Driver Demo", 13, 10
                byte    "======================", 13, 10
                byte    13, 10
                byte    "This SD card filesystem driver provides:", 13, 10
                byte    "- FAT32 support for cards up to 32GB", 13, 10
                byte    "- Multiple simultaneous file handles", 13, 10
                byte    "- High-speed SPI transfers with CRC", 13, 10
                byte    "- Smart pin hardware acceleration", 13, 10
                byte    13, 10
                byte    "Type 'help' for available commands.", 13, 10
                byte    0

  demo_numbers  byte    "1 One", 13, 10
                byte    "2 Two", 13, 10
                byte    "3 Three", 13, 10
                byte    "4 Four", 13, 10
                byte    "5 Five", 13, 10
                byte    "6 Six", 13, 10
                byte    "7 Seven", 13, 10
                byte    "8 Eight", 13, 10
                byte    "9 Nine", 13, 10
                byte    "10 Ten", 13, 10
                byte    0


DAT { terminal separators }

  separators    byte    " ", 9, 0                               ' separate with space or tab


CON { setup }


PUB setup()

'' Configure IO and objects for application

  term.tstart(BR_TERM)                                          ' start terminal io
  cli.start(13, cli.NONE, @separators)                          ' setup parser


PUB wait_for_terminal(clear, delay)

'' Wait for terminal to be open and key pressed

  term.rxflush()
  term.rx()
  if (clear)
    term.tx(term.CLS)
    waitms(delay #> 0)


CON { license }

{{

  Terms of Use: MIT License

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

}}
