{Spin2_v49}
'' =================================================================================================
''
''   File....... SD_demo_shell.spin2
''   Purpose.... Interactive command-line shell for SD card filesystem
''   Author..... Stephen M Moraco
''               Copyright (c) 2026 Iron Sheep Productions, LLC
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... FEB 2026
''   Updated.... 07 FEB 2026
''
'' =================================================================================================
''
''   Interactive shell for exploring SD card filesystem operations.
''   Supports both DOS-style (dir, type, del) and Unix-style (ls, cat, rm) commands.
''
''   Connect via serial terminal at 2,000,000 baud (2 Mbit).
''   Type 'help' for list of available commands.
''
'' =================================================================================================

CON { timing }

  CLK_FREQ = 270_000_000                                        ' system freq as a constant
  MS_001   = CLK_FREQ / 1_000                                   ' ticks in 1ms
  US_001   = CLK_FREQ / 1_000_000                               ' ticks in 1us

  _clkfreq = CLK_FREQ                                           ' set system clock


CON { terminal }

'  BR_TERM  = 230_400                                            ' terminal baud rate
  BR_TERM  = 2_000_000                                            ' terminal baud rate


CON { SD card pins - P2 Edge Module }

  SD_CS    = 60  { O }                                          ' directly directly directly chip select
  SD_SCK   = 61  { O }                                          ' serial clock
  SD_MOSI  = 59  { O }                                          ' master out, slave in
  SD_MISO  = 58  { I }                                          ' master in, slave out


CON { fixed io pins }

  PGM_RX   = 63  { I }                                          ' programming / debug
  PGM_TX   = 62  { O }


CON { constants }

  #true,  ON, OFF
  #false, NO, YES

  MAX_PATH    = 128                                             ' max path length
  SECTOR_SIZE = 512                                             ' SD sector size
  BUFFER_SIZE = 512                                             ' read/write buffer


CON { FAT32 structure constants }

  ' FAT32 structure signatures
  MBR_SIGNATURE               = $AA55
  PARTITION_TYPE_FAT32_LBA    = $0C
  FSINFO_SIG1                 = $41615252      ' "RRaA"
  FSINFO_SIG2                 = $61417272      ' "rrAa"
  FSINFO_TRAIL_SIG            = $AA550000      ' Trail signature
  EXT_BOOT_SIG                = $29            ' Extended boot signature

  ' FAT entry constants
  FAT_MASK        = $0FFFFFFF     ' Lower 28 bits (cluster value)
  FAT_EOC_MIN     = $0FFFFFF8     ' Minimum end-of-chain marker
  FAT_EOC         = $0FFFFFFF     ' Standard EOC
  FAT_FREE        = $00000000     ' Free cluster
  FAT_BAD         = $0FFFFFF7     ' Bad cluster marker

  ' Bitmap capacity (256KB covers up to 2M clusters)
  BITMAP_LONGS        = 65536             ' 256KB
  MAX_BITMAP_CLUSTERS = BITMAP_LONGS * 32 ' 2,097,152 clusters

  ' Safety limits
  MAX_DIR_DEPTH       = 16
  MAX_CHAIN_LENGTH    = 2_000_000

  ' Bench test parameters
  BENCH_SECTOR_BASE   = 1_000_000         ' Safe area past filesystem
  BENCH_SECTOR_RANGE  = 10_000            ' Range of test sectors


CON { parser }

  CLI_BUF_SIZE = 128                                            ' command input buffer size
  CLI_MAX_TKNS =  10                                            ' max tokens per command


CON { command enums }

  #0, CMD_UNKNOWN, CMD_HELP, CMD_VERSION, CMD_CLS, CMD_CLEAR
  CMD_MOUNT, CMD_UNMOUNT, CMD_EJECT, CMD_FORMAT
  CMD_STATS, CMD_INFO, CMD_DIR, CMD_LS
  CMD_CD, CMD_PWD, CMD_MKDIR
  CMD_TYPE, CMD_CAT, CMD_HEXDUMP, CMD_HD
  CMD_REN, CMD_MV, CMD_COPY, CMD_CP
  CMD_DEL, CMD_RM, CMD_RMDIR
  CMD_DEMO, CMD_CARD, CMD_CID
  CMD_BENCHMARK, CMD_PERF, CMD_TOUCH
  CMD_AUDIT, CMD_FSCK, CMD_BENCH
  CMD_LABEL, CMD_VOL


'' Enable full driver features for card info display
#PRAGMA EXPORTDEF SD_INCLUDE_ALL

OBJ

  sd     : "micro_sd_fat32_fs"                                  '   SD card filesystem driver
  serial : "isp_serial_singleton"                               '   serial IO for terminal (singleton)


VAR { application }

  byte  buffer[BUFFER_SIZE]                                     ' general purpose buffer
  byte  pathbuf[MAX_PATH]                                       ' path buffer
  byte  cwd[MAX_PATH]                                           ' current working directory
  byte  ntokens                                                 ' number of parsed tokens
  byte  mounted                                                 ' mount status flag


VAR { audit/fsck/bench }

  byte  buf2[SECTOR_SIZE]                                       ' comparison buffer
  byte  fatBuf[SECTOR_SIZE]                                     ' FAT sector cache

  ' Struct overlay pointers (set before use, overlaid on buf2)
  long  pVBR                                                    ' ^sd.vbr_t overlay
  long  pPart                                                   ' ^sd.mbr_partition_t overlay
  long  pFSInfo                                                 ' ^sd.fsinfo_t overlay

  ' FAT cache state
  long  fatBufSector                                            ' cached FAT1 sector (-1 = none)
  long  fatBufDirty                                             ' TRUE if fatBuf needs writing

  ' Filesystem geometry (populated by readGeometry)
  long  geoPartStart                                            ' partition start sector
  long  geoSecPerFat                                            ' sectors per FAT
  long  geoSecPerClus                                           ' sectors per cluster
  long  geoTotalClus                                            ' total data clusters
  long  geoTotalSec                                             ' total sectors
  long  geoReservedSec                                          ' reserved sectors
  long  geoFat1Start                                            ' FAT1 first sector
  long  geoFat2Start                                            ' FAT2 first sector
  long  geoDataStart                                            ' data region first sector
  long  geoRootClus                                             ' root directory cluster

  ' Audit/FSCK statistics
  long  passCount                                               ' tests passed
  long  failCount                                               ' tests failed
  long  repairCount                                             ' repairs made
  long  errorCount                                              ' errors found
  long  warningCount                                            ' warnings issued
  long  dirCount                                                ' directories scanned
  long  fileCount                                               ' files scanned
  long  scanDepth                                               ' current recursion depth
  long  bitmapCapable                                           ' TRUE if card fits in bitmap
  long  bitmapField                                             ' FIELD pointer for 1-bit bitmap access

  ' Shared pool: FSCK bitmap or bench read buffer (256KB)
  long  sharedPool[BITMAP_LONGS]


VAR { parser }

  byte  cliBuf[CLI_BUF_SIZE]                                    ' command input buffer
  byte  cliIdx                                                  ' current position in buffer
  long  tkPtrs[CLI_MAX_TKNS]                                    ' pointers to parsed tokens


PUB main() | len, eCmd

  setup()
  serial.tx(serial.CLS)
  serial.fstr0(@"* Press return to start...\r\n")
  wait_for_terminal(false, 0)

  serial.tx(serial.CLS)
  serial.fstr0(@"P2 SD Card Filesystem Shell\r\n")
  serial.fstr0(@"- type 'help' for commands\r\n")
  serial.fstr0(@"\r\n")
  debug("SD Shell: ready for commands")

  ' Initialize current working directory
  bytemove(@cwd, @"/", 2)
  mounted := false

  repeat
    show_prompt()                                               ' prompt user
    len := get_command()                                        ' get input
    if (len > 0)                                                ' if command entered
      ' no echo â€” pnut-term-ts provides local echo
      debug("CMD: [", zstr_(@cliBuf), "] len=", udec_(len))
      ntokens := parse()                                        ' parse and count tokens
      if (ntokens)                                              ' if !0 tokens
        eCmd := idCommand(lcstr(token(0)))                      ' lookup command enum
        debug("  -> enum=", udec_(eCmd), " tokens=", udec_(ntokens))
        run_command(eCmd)                                       ' run command code


PUB get_command() : len | i

'' Enter command from terminal window

  parserReset()                                                 ' prep for new entry

  cliIdx := serial.rxline(@cliBuf, CLI_BUF_SIZE)               ' tight receive until CR

  ' convert tabs to spaces
  repeat i from 0 to cliIdx - 1
    if (cliBuf[i] == 9)
      cliBuf[i] := " "

  return cliIdx                                                 ' report length of input


PUB show_prompt()

'' Display command prompt with current directory

  if (mounted)
    serial.fstr1(@"\rSD:%s> ", @cwd)
  else
    serial.fstr0(@"\rSD:(unmounted)> ")


CON { command handlers }


PUB run_command(eCmd)

'' Run command identified by enum value eCmd

  if (eCmd == CMD_UNKNOWN)
    serial.fstr1(@"'%s' is not recognized as a command\r\n", token(0))
    return

  case eCmd
    CMD_HELP                : show_help()
    CMD_VERSION             : show_version()
    CMD_CLS, CMD_CLEAR      : do_cls()
    CMD_MOUNT               : do_mount()
    CMD_UNMOUNT, CMD_EJECT  : do_unmount()
    CMD_FORMAT              : do_format()
    CMD_STATS, CMD_INFO     : do_stats()
    CMD_DIR, CMD_LS         : do_dir()
    CMD_CD                  : do_cd()
    CMD_PWD                 : do_pwd()
    CMD_MKDIR               : do_mkdir()
    CMD_TYPE, CMD_CAT       : do_type()
    CMD_HEXDUMP, CMD_HD     : do_hexdump()
    CMD_REN, CMD_MV         : do_rename()
    CMD_COPY, CMD_CP        : do_copy()
    CMD_DEL, CMD_RM         : do_delete()
    CMD_RMDIR               : do_rmdir()
    CMD_DEMO                : do_demo()
    CMD_CARD, CMD_CID       : do_card_info()
    CMD_BENCHMARK, CMD_PERF, CMD_BENCH : do_bench()
    CMD_TOUCH               : do_touch()
    CMD_AUDIT               : do_audit()
    CMD_FSCK                : do_fsck()
    CMD_LABEL, CMD_VOL      : do_label()
    other                   : not_implemented()


PUB show_help()

'' Show available commands

  if (ntokens <> 1)
    bad_syntax()
    return

  serial.tx(serial.CLS)
  serial.fstr0(@"  SD Shell v0.9.3g\r\n\r\n")
  serial.fstr0(@"  Navigation                          File Operations\r\n")
  serial.fstr0(@"  mount       Mount SD card           type <f>    Show text (cat)\r\n")
  serial.fstr0(@"  unmount     Unmount (eject)         hexdump <f> Hex dump (hd)\r\n")
  serial.fstr0(@"  dir         List files (ls)         copy <s><d> Copy file (cp)\r\n")
  serial.fstr0(@"  cd <path>   Change directory        ren <o> <n> Rename (mv)\r\n")
  serial.fstr0(@"  pwd         Working directory       del <f>     Delete (rm)\r\n")
  serial.fstr0(@"  mkdir <d>   Create directory        touch <f>   Create file\r\n")
  serial.fstr0(@"  rmdir <d>   Remove directory        demo        Create demo files\r\n")
  serial.fstr0(@"\r\n")
  serial.fstr0(@"  Information                         Diagnostics & Utility\r\n")
  serial.fstr0(@"  stats       FS stats (info)         audit       Check FS integrity\r\n")
  serial.fstr0(@"  card        Card summary (cid)      fsck        Check & repair FS\r\n")
  serial.fstr0(@"  version     Driver version          bench       Throughput test\r\n")
  serial.fstr0(@"  label [n]   Volume label (vol)      format      Format SD card\r\n")
  serial.fstr0(@"  cls         Clear screen            help        This help\r\n")


PUB show_version()

'' Show driver version info

  if (ntokens <> 1)
    bad_syntax()
    return

  serial.fstr0(@"SD Card Driver - Iron Sheep Productions\r\n")
  serial.fstr1(@"SPI Frequency: %d Hz\r\n", sd.getSPIFrequency())


PUB do_cls()

'' Clear terminal window

  if (ntokens <> 1)
    bad_syntax()
    return

  serial.tx(serial.CLS)


PUB do_mount() | result

'' Mount SD card filesystem

  if (ntokens <> 1)
    bad_syntax()
    return

  if (mounted)
    serial.fstr0(@"SD card is already mounted\r\n")
    return

  serial.fstr0(@"Mounting SD card...\r\n")
  result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
  debug("mount result=", sdec_(result), " err=", sdec_(sd.error()))

  if (result)
    mounted := true
    bytemove(@cwd, @"/", 2)                                     ' reset to root
    serial.fstr0(@"Mounted successfully\r\n")
    debug("  mounted, SPI=", udec_(sd.getSPIFrequency()), " Hz")
    show_card_summary()
  else
    serial.fstr1(@"Mount failed, error: %d\r\n", sd.error())


PUB do_unmount()

'' Unmount SD card filesystem

  if (ntokens <> 1)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  sd.unmount()
  mounted := false
  serial.fstr0(@"SD card unmounted\r\n")


PUB do_format()

'' Format SD card (dangerous!)

  if (ntokens <> 1)
    bad_syntax()
    return

  serial.fstr0(@"WARNING: Format will erase ALL data on the SD card!\r\n")
  serial.fstr0(@"This feature is not yet implemented in this shell.\r\n")
  serial.fstr0(@"Use SD_format_card.spin2 instead.\r\n")


PUB do_stats() | total_sectors, total_mb, free_sectors, free_mb

'' Display filesystem statistics (requires mount)
'' For card hardware info, use 'card' command

  if (ntokens <> 1)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  total_sectors := sd.cardSizeSectors()
  total_mb := total_sectors / 2048                              ' sectors to MB (512 * 2048 = 1MB)
  free_sectors := sd.freeSpace()
  free_mb := free_sectors / 2048

  serial.fstr2(@"Total:  %d sectors (%d MB)\r\n", total_sectors, total_mb)
  serial.fstr2(@"Free:   %d sectors (%d MB)\r\n", free_sectors, free_mb)
  serial.fstr1(@"Label:  %s\r\n", sd.volumeLabel())


PUB do_dir() | dh, result, count, total_size, attrib, size, p_name

'' List directory contents using handle-based directory enumeration

  if (ntokens > 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  serial.fstr1(@"\r\n Directory of %s\r\n\r\n", @cwd)
  serial.fstr0(@"  Attr      Size  Name\r\n")
  serial.fstr0(@"  ----  --------  --------------------------------\r\n")

  dh := sd.openDirectory(@".")
  debug("openDir handle=", sdec_(dh))
  if (dh < 0)
    serial.fstr1(@"  Error opening directory: %d\r\n", dh)
    return

  count := 0
  total_size := 0

  repeat
    result := sd.readDirectoryHandle(dh)
    if (result == 0)                                            ' no more entries
      quit

    p_name := sd.fileName()
    if (byte[p_name] == 0)                                      ' empty name, skip
      next

    attrib := sd.attributes()
    size := sd.fileSize()

    ' Format attributes
    serial.fstr0(@"  ")
    serial.tx((attrib & $10) ? "D" : "-")                         ' directory
    serial.tx((attrib & $01) ? "R" : "-")                         ' read-only
    serial.tx((attrib & $02) ? "H" : "-")                         ' hidden
    serial.tx((attrib & $04) ? "S" : "-")                         ' system

    if (attrib & $10)                                           ' directory
      serial.fstr1(@"    <DIR>  %s\r\n", p_name)
    else
      serial.fstr2(@"  %8d  %s\r\n", size, p_name)
      total_size += size

    count++

  sd.closeDirectoryHandle(dh)

  serial.fstr0(@"\r\n")
  serial.fstr2(@"  %d file(s), %d bytes\r\n", count, total_size)
  serial.fstr1(@"  %d bytes free\r\n", sd.freeSpace() * SECTOR_SIZE)


PUB do_cd() | p_path

'' Change current directory

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_path := token(1)

  ' Handle special cases
  if (strcomp(p_path, @"/") or strcomp(p_path, @"\\"))
    ' Go to root
    sd.changeDirectory(@"/")
    bytemove(@cwd, @"/", 2)
    return

  if (strcomp(p_path, @".."))
    ' Go up one level
    go_up_directory()
    return

  ' Try to change to specified directory
  if (sd.changeDirectory(p_path))
    update_cwd(p_path)
  else
    serial.fstr1(@"Directory not found: %s\r\n", p_path)


PUB do_pwd()

'' Print working directory

  if (ntokens <> 1)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  serial.fstr1(@"%s\r\n", @cwd)


PUB do_mkdir() | p_name, result

'' Create new directory

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_name := token(1)
  result := sd.newDirectory(p_name)

  if (result)
    serial.fstr1(@"Created directory: %s\r\n", p_name)
  else
    serial.fstr1(@"Failed to create directory: %s\r\n", p_name)


PUB do_type() | p_filename, handle, bytes_read, total, c, i

'' Display contents of text file

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_filename := token(1)
  handle := sd.openFileRead(p_filename)
  debug("openFileRead handle=", sdec_(handle))

  if (handle < 0)
    serial.fstr1(@"File not found: %s\r\n", p_filename)
    return

  serial.fstr0(@"\r\n")
  total := 0

  repeat
    bytes_read := sd.readHandle(handle, @buffer, BUFFER_SIZE - 1)
    if (bytes_read <= 0)
      quit

    ' Display as text
    repeat i from 0 to bytes_read - 1
      c := buffer[i]
      if (c == 13) or (c == 10)                                  ' CR or LF
        serial.tx(c)
      elseif (c >= 32 and c < 127)                              ' printable
        serial.tx(c)
      else
        serial.tx(".")                                            ' non-printable

    total += bytes_read

  sd.closeFileHandle(handle)
  serial.fstr1(@"\r\n\r\n[%d bytes]\r\n", total)


PUB do_hexdump() | p_filename, handle, bytes_read, offset, i, c, fileSize

'' Display file contents in hex format

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_filename := token(1)
  handle := sd.openFileRead(p_filename)
  debug("openFileRead handle=", sdec_(handle))

  if (handle < 0)
    serial.fstr1(@"File not found: %s\r\n", p_filename)
    return

  serial.fstr0(@"\r\n")
  offset := 0

  repeat
    bytes_read := sd.readHandle(handle, @buffer, 16)
    if (bytes_read <= 0)
      quit

    ' Print offset
    serial.fstr1(@"%.8x  ", offset)

    ' Print hex bytes
    repeat i from 0 to 15
      if (i < bytes_read)
        serial.fstr1(@"%.2x ", buffer[i])
      else
        serial.fstr0(@"   ")
      if (i == 7)
        serial.tx(" ")

    serial.fstr0(@" |")

    ' Print ASCII
    repeat i from 0 to bytes_read - 1
      c := buffer[i]
      if (c >= 32 and c < 127)
        serial.tx(c)
      else
        serial.tx(".")

    serial.fstr0(@"|\r\n")
    offset += bytes_read

    ' Limit output to first 512 bytes
    if (offset >= 512)
      serial.fstr0(@"... (truncated at 512 bytes)\r\n")
      quit

  fileSize := sd.fileSizeHandle(handle)
  sd.closeFileHandle(handle)
  serial.fstr1(@"\r\n[%d bytes total]\r\n", fileSize > 0 ? fileSize : offset)


PUB do_rename() | p_old, p_new, result

'' Rename file or directory

  if (ntokens <> 3)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_old := token(1)
  p_new := token(2)

  result := sd.rename(p_old, p_new)

  if (result)
    serial.fstr2(@"Renamed '%s' to '%s'\r\n", p_old, p_new)
  else
    serial.fstr1(@"Failed to rename: %s\r\n", p_old)


PUB do_copy() | p_src, p_dst, h_src, h_dst, bytes_read, total

'' Copy file

  if (ntokens <> 3)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_src := token(1)
  p_dst := token(2)

  if (strcomp(p_src, p_dst))
    serial.fstr0(@"Cannot copy file to itself\r\n")
    return

  h_src := sd.openFileRead(p_src)
  if (h_src < 0)
    serial.fstr1(@"Source file not found: %s\r\n", p_src)
    return

  h_dst := sd.createFileNew(p_dst)
  if (h_dst < 0)
    sd.closeFileHandle(h_src)
    serial.fstr1(@"Cannot create destination: %s\r\n", p_dst)
    return

  total := 0
  repeat
    bytes_read := sd.readHandle(h_src, @buffer, BUFFER_SIZE)
    if (bytes_read <= 0)
      quit
    sd.writeHandle(h_dst, @buffer, bytes_read)
    total += bytes_read

  sd.closeFileHandle(h_src)
  sd.closeFileHandle(h_dst)

  serial.fstr2(@"Copied %d bytes to %s\r\n", total, p_dst)


PUB do_delete() | p_filename, result

'' Delete file

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_filename := token(1)
  result := sd.deleteFile(p_filename)

  if (result)
    serial.fstr1(@"Deleted: %s\r\n", p_filename)
  else
    serial.fstr1(@"Failed to delete: %s\r\n", p_filename)


PUB do_rmdir()

'' Remove directory (must be empty)

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  serial.fstr0(@"rmdir not yet implemented\r\n")


PUB do_demo() | handle, i

'' Create demo files

  if (ntokens <> 1)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  serial.fstr0(@"Creating demo files...\r\n")

  ' Create text file 1
  write_demo_file(@"HELLO.TXT", @demo_hello)
  write_demo_file(@"README.TXT", @demo_readme)
  write_demo_file(@"NUMBERS.TXT", @demo_numbers)

  serial.fstr0(@"Demo files created.\r\n")


PUB do_card_info() | sd.cid_t cid, sd.scr_t scr, wasMounted, ...
                     ocr, sizeMB, spiHz, psn, mdtYear, mdtMonth, ...
                     pnm[2], p_mfr, p_type, p_spec, p_fs, ...
                     oemBuf[3], partStart, i

'' Display compact two-line card identification summary
'' Works mounted or unmounted
''
'' Line 1: Manufacturer Product Type SizeMB/GB [FS] SDver revN.M SN:hex Year/Mo
'' Line 2: SPI freq MHz  [OEM name]

  if (ntokens <> 1)
    bad_syntax()
    return

  wasMounted := mounted

  ' If not mounted, initialize card for raw access
  if (not mounted)
    serial.fstr0(@"Initializing card...\r\n")
    if (not initRawAccess())
      serial.fstr0(@"ERROR: Cannot initialize card\r\n")
      return

  ' Read card registers into struct locals
  sd.readCIDRaw(@cid)
  sd.readSCRRaw(@scr)
  ocr := sd.getOCR()
  sizeMB := sd.cardSizeSectors() / 2048
  spiHz := sd.getSPIFrequency()

  ' Parse CID: product name (5 bytes, null-terminated)
  bytemove(@pnm, @cid.pnm, 5)
  BYTE[@pnm + 5] := 0

  ' Parse CID: serial number (4 bytes big-endian -> 32-bit LONG)
  psn := (cid.psn[0] << 24) | (cid.psn[1] << 16) | (cid.psn[2] << 8) | cid.psn[3]

  ' Parse CID: manufacturing date
  mdtYear := 2000 + ((cid.mdt[0] & $0F) << 4) + ((cid.mdt[1] >> 4) & $0F)
  mdtMonth := cid.mdt[1] & $0F

  ' Look up descriptive strings
  p_mfr := lookupMID(cid.mid)
  p_type := getCardType(ocr, sizeMB)
  p_spec := getSDSpecVersion(@scr)
  p_fs := detectFilesystem()

  ' Read VBR OEM name from partition boot record
  sd.readSectorRaw(0, @buf2)
  if WORD[@buf2 + $1FE] == MBR_SIGNATURE
    pPart := @buf2 + $1BE
    partStart := partLbaStart(pPart)
    if partStart > 0
      sd.readSectorRaw(partStart, @buf2)
      bytemove(@oemBuf, @buf2 + 3, 8)
      BYTE[@oemBuf + 8] := 0
      ' Trim trailing spaces
      i := 7
      repeat while i >= 0 AND BYTE[@oemBuf + i] == " "
        BYTE[@oemBuf + i] := 0
        i--
    else
      bytemove(@oemBuf, @"n/a", 4)
  else
    bytemove(@oemBuf, @"n/a", 4)

  ' Line 1 part A: Mfr Product Type Size [FS] Spec
  serial.str(p_mfr)
  serial.tx(" ")
  serial.str(@pnm)
  serial.tx(" ")
  serial.str(p_type)
  serial.tx(" ")
  if sizeMB < 1024
    serial.dec(sizeMB)
    serial.str(@"MB")
  else
    serial.dec(sizeMB / 1024)
    serial.str(@"GB")
  serial.str(@" [")
  serial.str(p_fs)
  serial.str(@"] ")
  serial.str(p_spec)

  ' Line 1 part B: rev SN date
  serial.str(@" rev")
  serial.dec(cid.prv >> 4)
  serial.tx(".")
  serial.dec(cid.prv & $0F)
  serial.str(@" SN:")
  serial.fwhex(psn, 8)
  serial.tx(" ")
  serial.dec(mdtYear)
  serial.tx("/")
  serial.fwdec(mdtMonth, 2)
  serial.tx(13)
  serial.tx(10)

  ' Line 2: SPI frequency and OEM name
  serial.str(@"SPI ")
  serial.dec(spiHz / 1_000_000)
  serial.tx(".")
  serial.dec((spiHz / 100_000) // 10)
  serial.str(@" MHz  [")
  serial.str(@oemBuf)
  serial.tx("]")
  serial.tx(13)
  serial.tx(10)

  ' Clean up if we initialized raw access
  if (not wasMounted)
    sd.stop()


PUB do_audit() | wasMounted, result

'' Audit FAT32 filesystem integrity (read-only)
'' Works mounted or unmounted - uses raw sector reads

  if (ntokens <> 1)
    bad_syntax()
    return

  wasMounted := mounted

  ' If not mounted, initialize card for raw access
  if (not mounted)
    serial.fstr0(@"Initializing card...\r\n")
    if (not initRawAccess())
      serial.fstr0(@"ERROR: Cannot initialize card\r\n")
      return

  ' Reset statistics
  passCount := 0
  failCount := 0

  serial.fstr0(@"\r\n=== FAT32 Filesystem Audit (read-only) ===\r\n")
  serial.fstr1(@"Card: %d MB\r\n\r\n", sd.cardSizeSectors() / 2048)

  ' Read geometry
  if (not readGeometry())
    serial.fstr0(@"ERROR: Cannot read filesystem geometry\r\n")
    if (not wasMounted)
      sd.stop()
    return

  ' Run all audit checks
  auditMBR()
  auditVBR()
  auditBackupVBR()
  auditFSInfo()
  auditFAT()
  auditRootDir()

  ' Mount test only if we weren't already mounted
  if (not wasMounted)
    auditMountTest()
    sd.stop()

  ' Summary
  serial.fstr0(@"\r\n=== AUDIT COMPLETE ===\r\n")
  serial.fstr2(@"Tests: %d  Pass: %d", passCount + failCount, passCount)
  serial.fstr1(@"  Fail: %d\r\n", failCount)
  if (failCount == 0)
    serial.fstr0(@"FILESYSTEM INTEGRITY: OK\r\n")
  else
    serial.fstr0(@"FILESYSTEM INTEGRITY: ISSUES DETECTED\r\n")
    serial.fstr0(@"  Consider running 'fsck' to repair.\r\n")


PUB do_fsck() | cardSectors

'' Check and repair FAT32 filesystem
'' Requires unmount for write access to FAT sectors

  if (ntokens <> 1)
    bad_syntax()
    return

  ' FSCK needs raw write access - must unmount first
  if (mounted)
    if (not confirmYN(@"FSCK requires unmount. Unmount now"))
      return
    sd.unmount()
    mounted := false
    serial.fstr0(@"Unmounted.\r\n")

  ' Initialize card for raw access
  serial.fstr0(@"Initializing card...\r\n")
  if (not initRawAccess())
    serial.fstr0(@"ERROR: Cannot initialize card\r\n")
    return

  ' Reset statistics
  repairCount := 0
  errorCount := 0
  warningCount := 0
  dirCount := 0
  fileCount := 0
  scanDepth := 0
  fatBufSector := -1
  fatBufDirty := false

  cardSectors := sd.cardSizeSectors()
  serial.fstr0(@"\r\n=== FAT32 Filesystem Check & Repair ===\r\n")
  serial.fstr2(@"Card: %d sectors (%d MB)\r\n\r\n", cardSectors, cardSectors / 2048)

  ' Read filesystem geometry
  if (not readGeometry())
    serial.fstr0(@"FATAL: Cannot read filesystem geometry\r\n")
    sd.stop()
    return

  ' Determine if bitmap can cover the whole card
  bitmapCapable := (geoTotalClus <= MAX_BITMAP_CLUSTERS)
  if (not bitmapCapable)
    serial.fstr2(@"NOTE: Card has %d clusters (bitmap max: %d)\r\n", geoTotalClus, MAX_BITMAP_CLUSTERS)
    serial.fstr0(@"  Deep scan (passes 2-3) skipped.\r\n")
    warningCount++

  serial.fstr0(@"\r\n")

  ' Pass 1: Structural integrity
  fsckPass1()

  ' Pass 2: Directory walk + chain validation (requires bitmap)
  if (bitmapCapable)
    fsckPass2()

  ' Pass 3: Lost cluster recovery (requires bitmap)
  if (bitmapCapable)
    fsckPass3()

  ' Pass 4: FAT sync + free count
  fsckPass4()

  ' Summary
  serial.fstr0(@"\r\n=== FSCK COMPLETE ===\r\n")
  serial.fstr2(@"Errors: %d  Repairs: %d", errorCount, repairCount)
  serial.fstr1(@"  Warnings: %d\r\n", warningCount)
  if (bitmapCapable)
    serial.fstr2(@"Directories: %d  Files: %d\r\n", dirCount, fileCount)
  if (errorCount == 0 AND repairCount == 0)
    serial.fstr0(@"STATUS: CLEAN\r\n")
  elseif (errorCount == 0)
    serial.fstr0(@"STATUS: REPAIRED\r\n")
  else
    serial.fstr0(@"STATUS: ERRORS REMAIN\r\n")

  sd.stop()

  ' Offer to re-mount
  serial.fstr0(@"\r\n")
  if (confirmYN(@"Re-mount card"))
    do_mount()


PUB do_bench() | wasMounted, tStart, tElapsed, sector, i, rate, nSectors, readResult, msPerTick

'' Read-only throughput benchmark using raw sector reads
'' Works mounted or unmounted - no files created/deleted

  if (ntokens <> 1)
    bad_syntax()
    return

  wasMounted := mounted

  ' If not mounted, initialize card for raw access
  if (not mounted)
    serial.fstr0(@"Initializing card...\r\n")
    if (not initRawAccess())
      serial.fstr0(@"ERROR: Cannot initialize card\r\n")
      return

  serial.fstr0(@"\r\n=== Read-Only Throughput Benchmark ===\r\n")
  serial.fstr2(@"Card: %d MB, SPI: %d Hz\r\n", sd.cardSizeSectors() / 2048, sd.getSPIFrequency())
  serial.fstr1(@"Test area: sectors %d+\r\n\r\n", BENCH_SECTOR_BASE)

  msPerTick := clkfreq / 1000

  ' --- Single-sector test (100 reads) ---
  serial.fstr0(@"Single-sector (100 reads)... ")
  sector := BENCH_SECTOR_BASE
  tStart := getct()
  repeat 100
    sd.readSectorRaw(sector, @buffer)
    sector++
  tElapsed := getct() - tStart

  rate := (100 * 512 * msPerTick) / tElapsed                    ' bytes/ms = KB/s approx
  serial.fstr2(@"%d ms, %d KB/s\r\n", tElapsed / msPerTick, rate)

  ' --- Multi-sector x8 ---
  serial.fstr0(@"Multi-sector x8 (100 reads)... ")
  sector := BENCH_SECTOR_BASE
  tStart := getct()
  repeat 100
    readResult := sd.readSectorsRaw(sector, 8, @sharedPool)
    sector += 8
  tElapsed := getct() - tStart

  rate := (100 * 8 * 512 * (msPerTick / 10)) / (tElapsed / 10)
  serial.fstr2(@"%d ms, %d KB/s\r\n", tElapsed / msPerTick, rate)

  ' --- Multi-sector x32 ---
  serial.fstr0(@"Multi-sector x32 (25 reads)... ")
  sector := BENCH_SECTOR_BASE
  tStart := getct()
  repeat 25
    readResult := sd.readSectorsRaw(sector, 32, @sharedPool)
    sector += 32
  tElapsed := getct() - tStart

  rate := (25 * 32 * 512 * (msPerTick / 10)) / (tElapsed / 10)
  serial.fstr2(@"%d ms, %d KB/s\r\n", tElapsed / msPerTick, rate)

  ' --- Multi-sector x64 ---
  serial.fstr0(@"Multi-sector x64 (16 reads)... ")
  sector := BENCH_SECTOR_BASE
  tStart := getct()
  repeat 16
    readResult := sd.readSectorsRaw(sector, 64, @sharedPool)
    sector += 64
  tElapsed := getct() - tStart

  rate := (16 * 64 * 512 * (msPerTick / 10)) / (tElapsed / 10)
  serial.fstr2(@"%d ms, %d KB/s\r\n", tElapsed / msPerTick, rate)

  serial.fstr0(@"\rBenchmark complete.\r\n")

  ' Clean up if we initialized raw access
  if (not wasMounted)
    sd.stop()


PUB do_touch() | p_filename, handle

'' Create empty file or update timestamp

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_filename := token(1)
  handle := sd.createFileNew(p_filename)

  if (handle >= 0)
    sd.closeFileHandle(handle)
    serial.fstr1(@"Created: %s\r\n", p_filename)
  else
    serial.fstr1(@"Failed to create: %s\r\n", p_filename)


PUB do_label() | p_label

'' Display or set volume label
'' Usage: label          - show current volume label
''        label NEWNAME  - set new volume label (max 11 chars)

  if (ntokens > 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  if (ntokens == 1)
    serial.fstr1(@"Volume label: %s\r\n", sd.volumeLabel())
  else
    p_label := token(1)
    if strsize(p_label) > 11
      serial.fstr0(@"Label too long (max 11 characters)\r\n")
      return
    if sd.setVolumeLabel(p_label)
      serial.fstr1(@"Volume label set to: %s\r\n", sd.volumeLabel())
    else
      serial.fstr0(@"Failed to set volume label\r\n")


PUB not_implemented()

  serial.fstr1(@"%s is not implemented\r\n", token(0))


CON { helper methods }


PRI write_demo_file(p_name, p_content) | handle, len

'' Write demo content to file

  len := strsize(p_content)
  serial.fstr2(@"  Writing %s (%d bytes)...\r\n", p_name, len)

  handle := sd.createFileNew(p_name)
  if (handle < 0)
    serial.fstr0(@"    ERROR: Could not create file\r\n")
    return

  sd.writeHandle(handle, p_content, len)
  sd.closeFileHandle(handle)


PRI show_card_summary() | total_mb, free_mb

'' Show brief card summary after mount

  total_mb := sd.cardSizeSectors() / 2048
  free_mb := sd.freeSpace() / 2048

  serial.fstr1(@"  Volume: %s\r\n", sd.volumeLabel())
  serial.fstr2(@"  Size: %d MB, Free: %d MB\r\n", total_mb, free_mb)
  serial.fstr1(@"  SPI: %d Hz\r\n", sd.getSPIFrequency())


PRI check_mount() : status

'' Returns true if SD card is mounted

  status := mounted
  if (status == false)
    serial.fstr0(@"SD card not mounted. Use 'mount' command first.\r\n")


PRI go_up_directory() | i, len

'' Navigate up one directory level

  len := strsize(@cwd)
  if (len <= 1)                                                 ' already at root
    return

  ' Find last slash
  i := len - 1
  if (cwd[i] == "/")
    i--

  repeat while i > 0
    if (cwd[i] == "/")
      quit
    i--

  if (i == 0)
    bytemove(@cwd, @"/", 2)                                     ' back to root
  else
    cwd[i + 1] := 0                                             ' truncate path

  sd.changeDirectory(@"..")


PRI update_cwd(p_path) | len, cwd_len

'' Update current working directory string

  cwd_len := strsize(@cwd)
  len := strsize(p_path)

  if (cwd_len + len + 2 >= MAX_PATH)
    return                                                      ' path too long

  ' Add separator if needed
  if (cwd[cwd_len - 1] <> "/")
    cwd[cwd_len++] := "/"

  ' Append new directory
  bytemove(@cwd + cwd_len, p_path, len + 1)


PRI bad_syntax()

  serial.fstr0(@"Syntax error. Type 'help' for command list.\r\n")


CON { audit sub-methods }


PRI auditRunTest(pTestName, passed)

'' Record and display a single audit test result

  if (passed)
    passCount++
    serial.fstr1(@"  [PASS] %s\r\n", pTestName)
  else
    failCount++
    serial.fstr1(@"  [FAIL] %s\r\n", pTestName)


PRI auditMBR() | result

'' Audit MBR structure (sector 0)

  serial.fstr0(@"--- MBR ---\r\n")

  sd.readSectorRaw(0, @buffer)

  auditRunTest(@"MBR boot signature ($AA55)", WORD[@buffer + $1FE] == MBR_SIGNATURE)

  pPart := @buffer + $1BE
  result := partBootFlag(pPart)
  auditRunTest(@"Partition 1 boot flag ($00/$80)", result == $00 OR result == $80)

  result := partType(pPart)
  auditRunTest(@"Partition type ($0C = FAT32 LBA)", result == PARTITION_TYPE_FAT32_LBA)

  result := partLbaStart(pPart)
  auditRunTest(@"Partition start > 0", result > 0)
  serial.fstr1(@"    Partition start: sector %d\r\n", result)

  result := partLbaSize(pPart)
  auditRunTest(@"Partition size > 0", result > 0)
  serial.fstr1(@"    Partition size: %d sectors\r\n\r\n", result)


PRI auditVBR() | result

'' Audit VBR (primary boot sector at partition start)

  serial.fstr0(@"--- VBR ---\r\n")

  sd.readSectorRaw(geoPartStart, @buffer)
  pVBR := @buffer

  result := vbrJumpBoot0(pVBR)
  auditRunTest(@"VBR jump ($EB or $E9)", result == $EB OR result == $E9)

  auditRunTest(@"VBR boot signature ($AA55)", vbrBootSignature(pVBR) == MBR_SIGNATURE)

  result := vbrBytesPerSec(pVBR)
  auditRunTest(@"Bytes/sector = 512", result == 512)

  result := vbrSecPerClus(pVBR)
  auditRunTest(@"Sectors/cluster power of 2", result >= 1 AND result <= 128 AND (result & (result - 1)) == 0)
  serial.fstr1(@"    Sectors/cluster: %d\r\n", result)

  result := vbrReservedSec(pVBR)
  auditRunTest(@"Reserved sectors = 32", result == 32)

  result := vbrNumFats(pVBR)
  auditRunTest(@"Number of FATs = 2", result == 2)

  result := vbrRootEntCnt(pVBR)
  auditRunTest(@"Root entry count = 0 (FAT32)", result == 0)

  result := vbrTotalSec16(pVBR)
  auditRunTest(@"Total sectors 16-bit = 0", result == 0)

  result := vbrMediaType(pVBR)
  auditRunTest(@"Media type = $F8", result == $F8)

  result := vbrSecPerFat16(pVBR)
  auditRunTest(@"FAT size 16-bit = 0", result == 0)

  result := vbrHiddenSec(pVBR)
  auditRunTest(@"Hidden sectors = partition start", result == geoPartStart)

  auditRunTest(@"Total sectors 32-bit > 0", geoTotalSec > 0)
  serial.fstr1(@"    Total sectors: %d\r\n", geoTotalSec)

  auditRunTest(@"Sectors per FAT > 0", geoSecPerFat > 0)
  serial.fstr1(@"    Sectors/FAT: %d\r\n", geoSecPerFat)

  result := vbrRootCluster(pVBR)
  auditRunTest(@"Root cluster = 2", result == 2)

  result := vbrFsInfoSec(pVBR)
  auditRunTest(@"FSInfo at sector 1", result == 1)

  result := vbrBackBootSec(pVBR)
  auditRunTest(@"Backup boot at sector 6", result == 6)

  result := vbrBootSigByte(pVBR)
  auditRunTest(@"Extended boot sig = $29", result == EXT_BOOT_SIG)

  result := true
  if vbrFsTypeByte(pVBR, 0) <> "F" OR vbrFsTypeByte(pVBR, 1) <> "A" OR vbrFsTypeByte(pVBR, 2) <> "T" OR vbrFsTypeByte(pVBR, 3) <> "3" OR vbrFsTypeByte(pVBR, 4) <> "2"
    result := false
  auditRunTest(@"FS type = FAT32", result)
  serial.fstr0(@"\r\n")


PRI auditBackupVBR() | idx, mismatch

'' Verify backup VBR matches primary

  serial.fstr0(@"--- Backup VBR ---\r\n")

  sd.readSectorRaw(geoPartStart, @buffer)
  sd.readSectorRaw(geoPartStart + 6, @buf2)

  mismatch := false
  repeat idx from 0 to 511
    if (buffer[idx] <> buf2[idx])
      mismatch := true
      quit

  auditRunTest(@"Backup VBR matches primary", mismatch == false)
  serial.fstr0(@"\r\n")


PRI auditFSInfo() | result, idx, mismatch

'' Verify FSInfo sector and backup

  serial.fstr0(@"--- FSInfo ---\r\n")

  sd.readSectorRaw(geoPartStart + 1, @buffer)
  pFSInfo := @buffer

  result := fsiLeadSig(pFSInfo)
  auditRunTest(@"Lead signature ($41615252)", result == FSINFO_SIG1)

  result := fsiStructSig(pFSInfo)
  auditRunTest(@"Struct signature ($61417272)", result == FSINFO_SIG2)

  result := fsiTrailSig(pFSInfo)
  auditRunTest(@"Trail signature ($AA550000)", result == FSINFO_TRAIL_SIG)

  result := fsiFreeClusters(pFSInfo)
  auditRunTest(@"Free cluster count set", result <> 0)
  serial.fstr1(@"    Free clusters: %d\r\n", result)

  result := fsiNextFreeHint(pFSInfo)
  auditRunTest(@"Next free hint valid", result == $FFFFFFFF OR result >= 2)

  ' Check backup FSInfo
  sd.readSectorRaw(geoPartStart + 1, @buffer)
  sd.readSectorRaw(geoPartStart + 7, @buf2)

  mismatch := false
  repeat idx from 0 to 511
    if (buffer[idx] <> buf2[idx])
      mismatch := true
      quit

  auditRunTest(@"Backup FSInfo matches primary", mismatch == false)
  serial.fstr0(@"\r\n")


PRI auditFAT() | result, idx, mismatch

'' Verify FAT table entries and consistency

  serial.fstr0(@"--- FAT Table ---\r\n")

  sd.readSectorRaw(geoFat1Start, @buffer)

  result := LONG[@buffer]
  auditRunTest(@"FAT[0] = $0FFFFFF8 (media)", result == $0FFFFFF8)

  result := LONG[@buffer + 4]
  auditRunTest(@"FAT[1] = $0FFFFFFF (EOC)", result == $0FFFFFFF)

  result := LONG[@buffer + 8]
  auditRunTest(@"FAT[2] = $0FFFFFFF (root EOC)", result == $0FFFFFFF)

  result := LONG[@buffer + 12]
  auditRunTest(@"FAT[3] = 0 (free)", result == 0)

  ' Compare FAT1 and FAT2 first sector
  sd.readSectorRaw(geoFat2Start, @buf2)

  mismatch := false
  repeat idx from 0 to 511
    if (buffer[idx] <> buf2[idx])
      mismatch := true
      quit

  auditRunTest(@"FAT1 first sector == FAT2", mismatch == false)
  serial.fstr0(@"\r\n")


PRI auditRootDir() | result, pEntry

'' Verify root directory structure
'' Note: pEntry is untyped LONG (pnut-ts v51a limitation: ^structName not supported
''   in locals). Struct member access via dirEnt*() helper methods.

  serial.fstr0(@"--- Root Directory ---\r\n")

  sd.readSectorRaw(geoDataStart, @buffer)

  ' Check first directory entry (volume label)
  pEntry := @buffer
  result := dirEntAttr(pEntry)
  auditRunTest(@"Volume label entry (attr=$08)", result == $08)

  result := dirEntName0(pEntry)
  auditRunTest(@"Valid volume label chars", result >= $20 AND result <= $7E)

  ' Check second directory entry
  pEntry := @buffer + SIZEOF(sd.dir_entry_t)
  result := dirEntName0(pEntry)
  auditRunTest(@"Second entry valid or end", result == $00 OR result == $E5 OR (result >= $20 AND result <= $7E))
  serial.fstr0(@"\r\n")


PRI auditMountTest() | result

'' Test mount/unmount cycle

  serial.fstr0(@"--- Mount Test ---\r\n")

  result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
  auditRunTest(@"mount() succeeds", result)

  if (result)
    result := sd.freeSpace()
    auditRunTest(@"Free space > 0", result > 0)
    serial.fstr1(@"    Free: %d sectors\r\n", result)
    sd.unmount()

  serial.fstr0(@"\r\n")


CON { fsck sub-methods }


PRI fsckPass1() | idx, mismatch, fsinfoDirty, startRepairs

'' Pass 1: Check and repair structural elements

  serial.fstr0(@"--- Pass 1: Structural Integrity ---\r\n")
  startRepairs := repairCount

  ' === VBR backup (sector 6) ===
  sd.readSectorRaw(geoPartStart, @buffer)
  sd.readSectorRaw(geoPartStart + 6, @buf2)

  mismatch := false
  repeat idx from 0 to 511
    if (buffer[idx] <> buf2[idx])
      mismatch := true
      quit

  if (mismatch)
    serial.fstr0(@"  REPAIR: Backup VBR mismatch - copying\r\n")
    sd.writeSectorRaw(geoPartStart + 6, @buffer)
    repairCount++
  else
    serial.fstr0(@"  [OK] Backup VBR matches\r\n")

  ' === FSInfo signatures (sector 1) ===
  sd.readSectorRaw(geoPartStart + 1, @buffer)
  pFSInfo := @buffer
  fsinfoDirty := false

  if (fsiLeadSig(pFSInfo) <> FSINFO_SIG1)
    serial.fstr0(@"  REPAIR: FSInfo lead signature\r\n")
    fsiSetLeadSig(pFSInfo, FSINFO_SIG1)
    fsinfoDirty := true
    repairCount++

  if (fsiStructSig(pFSInfo) <> FSINFO_SIG2)
    serial.fstr0(@"  REPAIR: FSInfo struct signature\r\n")
    fsiSetStructSig(pFSInfo, FSINFO_SIG2)
    fsinfoDirty := true
    repairCount++

  if (fsiTrailSig(pFSInfo) <> FSINFO_TRAIL_SIG)
    serial.fstr0(@"  REPAIR: FSInfo trail signature\r\n")
    fsiSetTrailSig(pFSInfo, FSINFO_TRAIL_SIG)
    fsinfoDirty := true
    repairCount++

  if (fsinfoDirty)
    sd.writeSectorRaw(geoPartStart + 1, @buffer)
  else
    serial.fstr0(@"  [OK] FSInfo signatures\r\n")

  ' === FSInfo backup (sector 7) ===
  sd.readSectorRaw(geoPartStart + 1, @buffer)
  sd.readSectorRaw(geoPartStart + 7, @buf2)

  mismatch := false
  repeat idx from 0 to 511
    if (buffer[idx] <> buf2[idx])
      mismatch := true
      quit

  if (mismatch)
    serial.fstr0(@"  REPAIR: Backup FSInfo mismatch - copying\r\n")
    sd.writeSectorRaw(geoPartStart + 7, @buffer)
    repairCount++
  else
    serial.fstr0(@"  [OK] Backup FSInfo matches\r\n")

  ' === FAT[0] media type ===
  sd.readSectorRaw(geoFat1Start, @buffer)

  if ((LONG[@buffer] & FAT_MASK) <> ($0FFFFFF8 & FAT_MASK))
    serial.fstr0(@"  REPAIR: FAT[0] media type\r\n")
    LONG[@buffer] := $0FFFFFF8 | (LONG[@buffer] & $F0000000)
    sd.writeSectorRaw(geoFat1Start, @buffer)
    repairCount++
  else
    serial.fstr0(@"  [OK] FAT[0] media type\r\n")

  ' === FAT[1] EOC marker ===
  if ((LONG[@buffer + 4] & FAT_MASK) <> FAT_EOC)
    serial.fstr0(@"  REPAIR: FAT[1] EOC marker\r\n")
    LONG[@buffer + 4] := FAT_EOC | (LONG[@buffer + 4] & $F0000000)
    sd.writeSectorRaw(geoFat1Start, @buffer)
    repairCount++
  else
    serial.fstr0(@"  [OK] FAT[1] EOC marker\r\n")

  ' === FAT[2] root cluster ===
  if ((LONG[@buffer + 8] & FAT_MASK) == FAT_FREE)
    serial.fstr0(@"  REPAIR: FAT[2] root cluster was free\r\n")
    LONG[@buffer + 8] := FAT_EOC | (LONG[@buffer + 8] & $F0000000)
    sd.writeSectorRaw(geoFat1Start, @buffer)
    repairCount++
  else
    serial.fstr0(@"  [OK] FAT[2] root cluster\r\n")

  serial.fstr1(@"  Pass 1: %d repairs\r\n\r\n", repairCount - startRepairs)


PRI fsckPass2() | startRepairs

'' Pass 2: Walk directory tree and validate all cluster chains

  serial.fstr0(@"--- Pass 2: Directory & Chain Validation ---\r\n")
  startRepairs := repairCount

  ' Clear cluster bitmap
  longfill(@sharedPool, 0, BITMAP_LONGS)
  bitmapField := ^@sharedPool.[0]                               ' 1-bit FIELD pointer for bitmap

  ' Mark clusters 0 and 1 as used
  fsckSetBit(0)
  fsckSetBit(1)

  ' CRITICAL: Validate root chain BEFORE scanning directories
  fsckValidateChain(geoRootClus, 0, true)

  ' Scan directory tree
  dirCount := 0
  fileCount := 0
  scanDepth := 0
  fsckScanDir(geoRootClus)

  serial.fstr2(@"  Dirs: %d  Files: %d\r\n", dirCount, fileCount)
  serial.fstr1(@"  Pass 2: %d repairs\r\n\r\n", repairCount - startRepairs)


PRI fsckScanDir(dirCluster) | sector, entSector, entIdx, pEntry, attr, startClus, fSize, name0, nextClus

'' Recursively scan directory, validating all entries and chains
'' Note: pEntry is untyped LONG (pnut-ts v51a limitation: ^structName not supported
''   in locals). Struct member access via dirEnt*() helper methods which accept
''   ^sd.dir_entry_t parameter.

  dirCount++
  scanDepth++

  if (scanDepth > MAX_DIR_DEPTH)
    serial.fstr0(@"  WARNING: Max dir depth exceeded\r\n")
    warningCount++
    scanDepth--
    return

  ' Follow directory cluster chain
  repeat while dirCluster >= 2 AND dirCluster < (geoTotalClus + 2)
    sector := fsckClus2Sec(dirCluster)

    ' Read each sector in this cluster
    repeat entSector from 0 to geoSecPerClus - 1
      sd.readSectorRaw(sector + entSector, @buffer)

      ' Process 16 directory entries per sector
      repeat entIdx from 0 to 15
        pEntry := @buffer + (entIdx * SIZEOF(sd.dir_entry_t))
        name0 := dirEntName0(pEntry)

        ' $00 = end of directory
        if (name0 == $00)
          scanDepth--
          return

        ' $E5 = deleted entry
        if (name0 == $E5)
          next

        attr := dirEntAttr(pEntry)

        ' Long filename entry (attr $0F)
        if ((attr & $3F) == $0F)
          next

        ' Volume label
        if (attr & $08)
          next

        ' Skip . and .. entries
        if (fsckIsDot(pEntry))
          next

        ' Extract start cluster and file size
        startClus := dirEntStartClus(pEntry)
        fSize := dirEntFileSize(pEntry)

        if (attr & $10)
          ' --- Subdirectory ---
          if (startClus >= 2 AND startClus < (geoTotalClus + 2))
            fsckValidateChain(startClus, 0, true)
            fsckScanDir(startClus)
            ' Re-read our sector after recursion
            sd.readSectorRaw(sector + entSector, @buffer)
          elseif (startClus <> 0)
            serial.fstr1(@"  ERROR: Bad dir start cluster %d\r\n", startClus)
            errorCount++
        else
          ' --- Regular file ---
          fileCount++
          if (startClus >= 2 AND startClus < (geoTotalClus + 2))
            fsckValidateChain(startClus, fSize, false)
          elseif (startClus == 0 AND fSize > 0)
            serial.fstr1(@"  ERROR: File has size %d but no cluster\r\n", fSize)
            errorCount++

    ' Advance to next cluster in directory chain
    nextClus := fsckReadFAT(dirCluster) & FAT_MASK
    if (nextClus >= FAT_EOC_MIN)
      quit
    if (nextClus < 2 OR nextClus >= (geoTotalClus + 2))
      serial.fstr1(@"  ERROR: Bad cluster in dir chain: %d\r\n", nextClus)
      errorCount++
      quit
    dirCluster := nextClus

  scanDepth--


PRI fsckValidateChain(startClus, fSize, isDir) | clus, nextClus, chainLen, expectedLen

'' Follow and validate a cluster chain, marking bitmap

  chainLen := 0
  clus := startClus

  repeat while clus >= 2 AND clus < (geoTotalClus + 2)
    ' Check for cross-link
    if (fsckTestBit(clus))
      serial.fstr1(@"  ERROR: Cross-linked cluster %d\r\n", clus)
      errorCount++
      return

    ' Mark as referenced
    fsckSetBit(clus)
    chainLen++

    ' Safety: detect loops
    if (chainLen > MAX_CHAIN_LENGTH)
      serial.fstr1(@"  ERROR: Chain too long from cluster %d\r\n", startClus)
      errorCount++
      return

    ' Read next in chain
    nextClus := fsckReadFAT(clus) & FAT_MASK

    ' End of chain?
    if (nextClus >= FAT_EOC_MIN)
      quit

    ' Bad reference?
    if (nextClus < 2 OR (nextClus >= (geoTotalClus + 2) AND nextClus <> FAT_BAD))
      serial.fstr1(@"  ERROR: Bad ref %d", nextClus)
      serial.fstr1(@" from cluster %d\r\n", startClus)
      ' Truncate chain
      fsckWriteFAT(clus, FAT_EOC)
      serial.fstr1(@"  REPAIR: Truncated at cluster %d\r\n", clus)
      repairCount++
      quit

    ' Bad cluster marker
    if (nextClus == FAT_BAD)
      quit

    clus := nextClus

  ' Check chain length vs expected for files
  if (not isDir AND fSize > 0)
    expectedLen := (fSize + (geoSecPerClus * 512) - 1) / (geoSecPerClus * 512)
    if (chainLen <> expectedLen)
      serial.fstr2(@"  WARNING: Chain %d clusters, expected %d\r\n", chainLen, expectedLen)
      warningCount++


PRI fsckPass3() | clus, fatVal, lostCount, startRepairs

'' Pass 3: Find and free lost clusters

  serial.fstr0(@"--- Pass 3: Lost Cluster Recovery ---\r\n")
  startRepairs := repairCount
  lostCount := 0

  repeat clus from 2 to geoTotalClus + 1
    if (clus >= MAX_BITMAP_CLUSTERS)
      quit

    ' Progress dot every 100K clusters
    if ((clus & $1FFFF) == 0)
      serial.tx(".")

    if (not fsckTestBit(clus))
      fatVal := fsckReadFAT(clus) & FAT_MASK
      if (fatVal <> FAT_FREE AND fatVal <> FAT_BAD)
        fsckWriteFAT(clus, FAT_FREE)
        lostCount++

  ' Flush pending FAT writes
  fsckFlushFAT()

  if (lostCount > 0)
    serial.fstr1(@"\r  REPAIR: Freed %d lost clusters\r\n", lostCount)
    repairCount += lostCount
  else
    serial.fstr0(@"  [OK] No lost clusters\r\n")

  serial.fstr1(@"  Pass 3: %d repairs\r\n\r\n", repairCount - startRepairs)


PRI fsckPass4() | fatSector, entIdx, clus, fatVal, freeCount, syncCount, mismatch, idx, startRepairs

'' Pass 4: Sync FAT1 -> FAT2 and correct free cluster count

  serial.fstr0(@"--- Pass 4: FAT Sync & Free Count ---\r\n")
  startRepairs := repairCount

  ' Ensure prior writes flushed
  fsckFlushFAT()

  freeCount := 0
  syncCount := 0
  clus := 0

  repeat fatSector from 0 to geoSecPerFat - 1
    ' Progress dot every 1000 sectors
    if ((fatSector & $3FF) == 0)
      serial.tx(".")

    ' Read FAT1 sector
    sd.readSectorRaw(geoFat1Start + fatSector, @buffer)

    ' Count free clusters
    repeat entIdx from 0 to 127
      if (clus >= 2 AND clus < (geoTotalClus + 2))
        fatVal := LONG[@buffer + (entIdx * 4)] & FAT_MASK
        if (fatVal == FAT_FREE)
          freeCount++
      clus++

    ' Compare with FAT2
    sd.readSectorRaw(geoFat2Start + fatSector, @buf2)

    mismatch := false
    repeat idx from 0 to 511
      if (buffer[idx] <> buf2[idx])
        mismatch := true
        quit

    if (mismatch)
      sd.writeSectorRaw(geoFat2Start + fatSector, @buffer)
      syncCount++

  if (syncCount > 0)
    serial.fstr1(@"\r  REPAIR: Synced %d FAT sectors\r\n", syncCount)
    repairCount += syncCount
  else
    serial.fstr0(@"\r  [OK] FAT1 and FAT2 in sync\r\n")

  serial.fstr1(@"  Free clusters: %d\r\n", freeCount)

  ' Update FSInfo free cluster count
  sd.readSectorRaw(geoPartStart + 1, @buffer)
  pFSInfo := @buffer

  if (fsiFreeClusters(pFSInfo) <> freeCount)
    serial.fstr2(@"  REPAIR: FSInfo free count %d -> %d\r\n", fsiFreeClusters(pFSInfo), freeCount)
    fsiSetFreeClusters(pFSInfo, freeCount)
    sd.writeSectorRaw(geoPartStart + 1, @buffer)
    sd.writeSectorRaw(geoPartStart + 7, @buffer)
    repairCount++
  else
    serial.fstr0(@"  [OK] FSInfo free count correct\r\n")

  serial.fstr1(@"  Pass 4: %d repairs\r\n\r\n", repairCount - startRepairs)


PRI fsckReadFAT(cluster) : value | sector, offset

'' Read a FAT entry with sector caching

  sector := geoFat1Start + (cluster >> 7)
  offset := (cluster & $7F) * 4

  if (sector <> fatBufSector)
    fsckFlushFAT()
    sd.readSectorRaw(sector, @fatBuf)
    fatBufSector := sector

  value := LONG[@fatBuf + offset]


PRI fsckWriteFAT(cluster, value) | sector, offset, existing

'' Write a FAT entry with caching, preserving upper 4 bits

  sector := geoFat1Start + (cluster >> 7)
  offset := (cluster & $7F) * 4

  if (sector <> fatBufSector)
    fsckFlushFAT()
    sd.readSectorRaw(sector, @fatBuf)
    fatBufSector := sector

  existing := LONG[@fatBuf + offset]
  LONG[@fatBuf + offset] := (value & FAT_MASK) | (existing & $F0000000)
  fatBufDirty := true


PRI fsckFlushFAT()

'' Write cached FAT sector to both FAT1 and FAT2 if dirty

  if (fatBufDirty AND fatBufSector >= 0)
    sd.writeSectorRaw(fatBufSector, @fatBuf)
    sd.writeSectorRaw(fatBufSector - geoFat1Start + geoFat2Start, @fatBuf)
    fatBufDirty := false


PRI fsckClus2Sec(cluster) : sector

'' Convert cluster number to absolute sector

  sector := geoDataStart + ((cluster - 2) * geoSecPerClus)


PRI fsckSetBit(cluster)

'' Set bit in cluster bitmap

  FIELD[bitmapField][cluster]~~


PRI fsckTestBit(cluster) : result

'' Test bit in cluster bitmap

  result := FIELD[bitmapField][cluster]


PRI fsckIsDot(^sd.dir_entry_t pEntry) : result

'' Check if directory entry is . or ..

  result := false
  if (pEntry.name[0] == ".")
    if (pEntry.name[1] == " " OR pEntry.name[1] == ".")
      result := true


PRI dirEntName0(^sd.dir_entry_t pEntry) : result

'' Return first byte of directory entry filename

  result := pEntry.name[0]


PRI dirEntAttr(^sd.dir_entry_t pEntry) : result

'' Return attribute byte of directory entry

  result := pEntry.attr


PRI dirEntStartClus(^sd.dir_entry_t pEntry) : result

'' Return 32-bit start cluster (combined from clusHI and clusLO fields)

  result := pEntry.clusLO | (pEntry.clusHI << 16)


PRI dirEntFileSize(^sd.dir_entry_t pEntry) : result

'' Return file size from directory entry

  result := pEntry.fileSize


' â”€â”€ MBR partition entry accessors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

PRI partBootFlag(^sd.mbr_partition_t p) : value
  return p.bootFlag

PRI partType(^sd.mbr_partition_t p) : value
  return p.partType

PRI partLbaStart(^sd.mbr_partition_t p) : value
  return p.lbaStart

PRI partLbaSize(^sd.mbr_partition_t p) : value
  return p.lbaSize

' â”€â”€ VBR (Volume Boot Record) accessors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

PRI vbrJumpBoot0(^sd.vbr_t p) : value
  return p.jumpBoot[0]

PRI vbrOemNameByte(^sd.vbr_t p, idx) : value
  return p.oemName[idx]

PRI vbrBytesPerSec(^sd.vbr_t p) : value
  return p.bytesPerSec

PRI vbrSecPerClus(^sd.vbr_t p) : value
  return p.secPerClus

PRI vbrReservedSec(^sd.vbr_t p) : value
  return p.reservedSec

PRI vbrNumFats(^sd.vbr_t p) : value
  return p.numFats

PRI vbrRootEntCnt(^sd.vbr_t p) : value
  return p.rootEntCnt

PRI vbrTotalSec16(^sd.vbr_t p) : value
  return p.totalSec16

PRI vbrMediaType(^sd.vbr_t p) : value
  return p.mediaType

PRI vbrSecPerFat16(^sd.vbr_t p) : value
  return p.secPerFat16

PRI vbrHiddenSec(^sd.vbr_t p) : value
  return p.hiddenSec

PRI vbrTotalSec32(^sd.vbr_t p) : value
  return p.totalSec32

PRI vbrSecPerFat32(^sd.vbr_t p) : value
  return p.secPerFat32

PRI vbrRootCluster(^sd.vbr_t p) : value
  return p.rootCluster

PRI vbrFsInfoSec(^sd.vbr_t p) : value
  return p.fsInfoSec

PRI vbrBackBootSec(^sd.vbr_t p) : value
  return p.backBootSec

PRI vbrBootSigByte(^sd.vbr_t p) : value
  return p.bootSig

PRI vbrBootSignature(^sd.vbr_t p) : value
  return p.bootSignature

PRI vbrFsTypeByte(^sd.vbr_t p, idx) : value
  return p.fsTypeLabel[idx]

' â”€â”€ FSInfo sector accessors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

PRI fsiLeadSig(^sd.fsinfo_t p) : value
  return p.leadSig

PRI fsiStructSig(^sd.fsinfo_t p) : value
  return p.structSig

PRI fsiTrailSig(^sd.fsinfo_t p) : value
  return p.trailSig

PRI fsiFreeClusters(^sd.fsinfo_t p) : value
  return p.freeClusters

PRI fsiNextFreeHint(^sd.fsinfo_t p) : value
  return p.nextFreeHint

PRI fsiSetLeadSig(^sd.fsinfo_t p, value)
  p.leadSig := value

PRI fsiSetStructSig(^sd.fsinfo_t p, value)
  p.structSig := value

PRI fsiSetTrailSig(^sd.fsinfo_t p, value)
  p.trailSig := value

PRI fsiSetFreeClusters(^sd.fsinfo_t p, value)
  p.freeClusters := value


CON { shared utility methods }


PRI confirmYN(p_prompt) : confirmed | c

'' Prompt user for y/n confirmation with 10-second timeout
'' Default is NO (just pressing Enter returns false, timeout returns false)

  serial.fstr1(@"%s (y/N)? ", p_prompt)
  c := serial.rxtime(10_000)
  if (c == "y" or c == "Y")
    serial.fstr0(@"yes\r\n")
    confirmed := true
  else
    serial.fstr0(@"no\r\n")
    confirmed := false


PRI initRawAccess() : ok

'' Initialize card for raw sector access (no mount)
'' Used by audit/fsck/bench when card is not mounted

  ok := sd.initCardOnly(SD_CS, SD_MOSI, SD_MISO, SD_SCK)


PRI lookupMID(mid) : p_name | p, entryMID

'' Look up manufacturer name from MID byte.
'' Returns pointer to name string, or "MID:$NN" for unknown.

  p := @midTable
  repeat
    entryMID := WORD[p]
    if entryMID == $00                                                ' end sentinel
      ' Unknown - format hex into buffer and return
      bytemove(@buffer, @midUnknown, 6)                               ' "MID:$"
      buffer[5] := hexDigit(mid >> 4)
      buffer[6] := hexDigit(mid & $0F)
      buffer[7] := 0
      return @buffer
    if entryMID == mid
      return @@WORD[p + 2]                                            ' convert DAT relative offset to absolute address
    p += 4                                                            ' next entry: word MID + word ptr


PRI hexDigit(nibble) : ch

'' Convert 0-15 to ASCII hex digit

  if nibble < 10
    return "0" + nibble
  return "A" + nibble - 10


PRI getCardType(ocr, sizeMB) : p_type

'' Determine card type from OCR CCS bit and capacity.
'' CCS=0: SDSC, CCS=1 and <=32GB: SDHC, CCS=1 and >32GB: SDXC

  if (ocr & (1 << 30)) == 0
    return @ctSDSC
  if sizeMB > 32768
    return @ctSDXC
  return @ctSDHC


PRI getSDSpecVersion(^sd.scr_t p_scr) : p_version | sdSpec, spec3, spec4, specX

'' Decode SD spec version from SCR register struct.
'' Takes typed pointer to scr_t struct.
'' Returns pointer to version string.

  sdSpec := p_scr.sdSpec & $0F
  spec3 := (p_scr.sdSpec3Ext >> 7) & 1
  spec4 := (p_scr.sdSpec3Ext >> 2) & 1
  specX := ((p_scr.sdSpec3Ext & $03) << 2) | ((p_scr.sdSpecXLo >> 6) & $03)

  if sdSpec < 2
    return @"SD 1.x"
  if spec3 == 0
    return @"SD 2.0"
  if spec4 == 0
    return @"SD 3.x"
  if specX == 0
    return @"SD 4.x"
  if specX == 1
    return @"SD 5.x"
  if specX == 2
    return @"SD 6.x"
  if specX == 3
    return @"SD 7.x"
  if specX == 4
    return @"SD 8.x"
  if specX == 5
    return @"SD 9.x"
  return @"SD ??"


PRI decodeSpeedClass(classByte) : speed

'' Decode SPEED_CLASS byte from SD Status.
'' $00=0, $01=2, $02=4, $03=6, $04=10

  case classByte
    $00 : return 0
    $01 : return 2
    $02 : return 4
    $03 : return 6
    $04 : return 10
    other : return 0


PRI detectFilesystem() : p_fsName | pType

'' Read MBR sector 0 to determine filesystem type from partition type byte.
'' Uses buf2 for the read. Returns pointer to filesystem name string.

  sd.readSectorRaw(0, @buf2)

  ' Check MBR signature
  if WORD[@buf2 + $1FE] <> MBR_SIGNATURE
    return @fsUnknown

  pPart := @buf2 + $1BE                                           ' overlay partition entry 1
  pType := partType(pPart)

  case pType
    $00 : return @fsEmpty
    $01 : return @fsFAT12
    $04, $06, $0E : return @fsFAT16
    $0B, $0C : return @fsFAT32
    $07 : return resolveType07()
    $83 : return @fsLinux
    $EE : return @fsGPT
    other : return @fsUnknown


PRI resolveType07() : p_fsName | partStart

'' Distinguish exFAT from NTFS for partition type $07.
'' Reads VBR OEM name via struct overlay.

  partStart := partLbaStart(pPart)                                 ' pPart set by detectFilesystem
  if partStart == 0
    return @fsUnknown

  sd.readSectorRaw(partStart, @buf2)
  pVBR := @buf2                                                    ' overlay VBR

  ' Check OEM name for "EXFAT"
  if vbrOemNameByte(pVBR, 0) == "E" AND vbrOemNameByte(pVBR, 1) == "X" AND ...
     vbrOemNameByte(pVBR, 2) == "F" AND vbrOemNameByte(pVBR, 3) == "A" AND vbrOemNameByte(pVBR, 4) == "T"
    return @fsExFAT

  return @fsNTFS


PRI readGeometry() : ok | numFats

'' Read MBR and VBR to extract filesystem geometry.
'' Populates all geo* VARs needed by audit and fsck.

  ' Read MBR to get partition start
  sd.readSectorRaw(0, @buf2)
  if WORD[@buf2 + $1FE] <> MBR_SIGNATURE
    serial.fstr0(@"  ERROR: Invalid MBR signature\r\n")
    return false

  pPart := @buf2 + $1BE                                           ' overlay partition entry 1
  geoPartStart := partLbaStart(pPart)
  if geoPartStart == 0
    serial.fstr0(@"  ERROR: Partition start is 0\r\n")
    return false

  ' Read VBR (Volume Boot Record)
  sd.readSectorRaw(geoPartStart, @buf2)
  pVBR := @buf2                                                    ' overlay VBR
  if vbrBootSignature(pVBR) <> MBR_SIGNATURE
    serial.fstr0(@"  ERROR: Invalid VBR signature\r\n")
    return false

  ' Extract geometry fields
  geoSecPerClus := vbrSecPerClus(pVBR)
  geoReservedSec := vbrReservedSec(pVBR)
  numFats := vbrNumFats(pVBR)
  geoSecPerFat := vbrSecPerFat32(pVBR)
  geoTotalSec := vbrTotalSec32(pVBR)
  geoRootClus := vbrRootCluster(pVBR)

  ' Validate critical fields
  if geoSecPerClus == 0 OR geoSecPerFat == 0 OR geoTotalSec == 0
    serial.fstr0(@"  ERROR: Zero in critical VBR field\r\n")
    return false

  if numFats < 1 OR numFats > 2
    serial.fstr1(@"  ERROR: Invalid number of FATs: %d\r\n", numFats)
    return false

  ' Compute derived values
  geoFat1Start := geoPartStart + geoReservedSec
  geoFat2Start := geoFat1Start + geoSecPerFat
  geoDataStart := geoFat1Start + (numFats * geoSecPerFat)
  geoTotalClus := (geoTotalSec - geoReservedSec - (numFats * geoSecPerFat)) / geoSecPerClus

  ok := true


PRI lcstr(p_str) : p_lcstr | c

'' Converts p_str to lowercase

  p_lcstr := p_str

  repeat strsize(p_str)
    c := byte[p_str]
    if (c >= "A") && (c <= "Z")
      byte[p_str] := c + 32
    ++p_str


CON { inline parser }


PRI parserReset()

' Reset command input buffer and tokens

  bytefill(@cliBuf, 0, CLI_BUF_SIZE)
  cliIdx := 0
  longfill(@tkPtrs, 0, CLI_MAX_TKNS)
  ntokens := 0


PRI enqueue(c) : done

' Add character to input buffer
' -- returns true when CR received

  if (c == 13)                                                  ' CR = end of input
    cliBuf[cliIdx] := 0                                         '  terminate buffer
    return true

  if (c == 10)                                                  ' LF = ignore
    return false

  if (c == 8) and (cliIdx > 0)                                 ' backspace?
    cliBuf[--cliIdx] := 0                                       '  erase last char
    return false

  if (cliIdx < CLI_BUF_SIZE - 2)                                ' room in buffer?
    cliBuf[cliIdx++] := c                                       '  add character

  return false


PRI parse() : count | p

' Parse input buffer into tokens separated by spaces/tabs
' -- returns token count

  longfill(@tkPtrs, 0, CLI_MAX_TKNS)
  ntokens := 0

  if (cliIdx == 0)                                              ' nothing to parse
    return 0

  p := @cliBuf

  repeat while (ntokens < CLI_MAX_TKNS)
    ' skip separators (space, tab)
    repeat while (byte[p] == " ") or (byte[p] == 9)
      p++
    if (byte[p] == 0)                                           ' end of string
      quit
    tkPtrs[ntokens++] := p                                      ' save token start
    ' walk to next separator or end
    repeat while (byte[p] <> 0)
      if (byte[p] == " ") or (byte[p] == 9)
        byte[p++] := 0                                          ' terminate token
        quit
      p++

  return ntokens


PRI token(idx) : p_str

' Returns pointer to parsed token at index

  if (idx >= 0) and (idx < CLI_MAX_TKNS)
    return tkPtrs[idx]


PRI idCommand(pCmdStr) : eCmdId | nIdx, pEntry, pStr

' Look up command string in command table, return enum value

  eCmdId := CMD_UNKNOWN

  repeat nIdx from 0 to cmdCt - 1
    pEntry := @@WORD[@cmdTable][nIdx]                           ' get pointer from table
    pStr := @BYTE[pEntry][1]                                    ' skip enum byte, point to string
    if strcomp(pCmdStr, pStr)
      eCmdId := BYTE[pEntry][0]                                 ' matched - return embedded enum
      quit


CON { strings / lists }


DAT { help text }



DAT { command table }

' ------------------------------------------------------------
'   Adjust Command Set:
'    (1) add/remove enum in CON { command enums }
'    (2) add/remove entry             "name  BYTE  ENUM, CmdString, 0"
'    (3) add/remove pointer to entry  "WORD  @name"
' ------------------------------------------------------------

' Command entries: each contains [enum_byte, "string", 0]

cmdHelp       BYTE    CMD_HELP,      "help",      0
cmdVersion    BYTE    CMD_VERSION,   "version",   0
cmdCls        BYTE    CMD_CLS,       "cls",       0
cmdClear      BYTE    CMD_CLEAR,     "clear",     0
cmdMount      BYTE    CMD_MOUNT,     "mount",     0
cmdUnmount    BYTE    CMD_UNMOUNT,   "unmount",   0
cmdEject      BYTE    CMD_EJECT,     "eject",     0
cmdFormat     BYTE    CMD_FORMAT,    "format",    0
cmdStats      BYTE    CMD_STATS,     "stats",     0
cmdInfo       BYTE    CMD_INFO,      "info",      0
cmdDir        BYTE    CMD_DIR,       "dir",       0
cmdLs         BYTE    CMD_LS,        "ls",        0
cmdCd         BYTE    CMD_CD,        "cd",        0
cmdPwd        BYTE    CMD_PWD,       "pwd",       0
cmdMkdir      BYTE    CMD_MKDIR,     "mkdir",     0
cmdType       BYTE    CMD_TYPE,      "type",      0
cmdCat        BYTE    CMD_CAT,       "cat",       0
cmdHexdump    BYTE    CMD_HEXDUMP,   "hexdump",   0
cmdHd         BYTE    CMD_HD,        "hd",        0
cmdRen        BYTE    CMD_REN,       "ren",       0
cmdMv         BYTE    CMD_MV,        "mv",        0
cmdCopy       BYTE    CMD_COPY,      "copy",      0
cmdCp         BYTE    CMD_CP,        "cp",        0
cmdDel        BYTE    CMD_DEL,       "del",       0
cmdRm         BYTE    CMD_RM,        "rm",        0
cmdRmdir      BYTE    CMD_RMDIR,     "rmdir",     0
cmdDemo       BYTE    CMD_DEMO,      "demo",      0
cmdCard       BYTE    CMD_CARD,      "card",      0
cmdCid        BYTE    CMD_CID,       "cid",       0
cmdBenchmark  BYTE    CMD_BENCHMARK, "benchmark", 0
cmdPerf       BYTE    CMD_PERF,      "perf",      0
cmdTouch      BYTE    CMD_TOUCH,     "touch",     0
cmdAudit      BYTE    CMD_AUDIT,     "audit",     0
cmdFsck       BYTE    CMD_FSCK,      "fsck",      0
cmdBench      BYTE    CMD_BENCH,     "bench",     0
cmdLabel      BYTE    CMD_LABEL,     "label",     0
cmdVol        BYTE    CMD_VOL,       "vol",       0

cmdTable      ' first table-entry must follow immediately
              WORD    @cmdHelp, @cmdVersion, @cmdCls, @cmdClear
              WORD    @cmdMount, @cmdUnmount, @cmdEject, @cmdFormat
              WORD    @cmdStats, @cmdInfo, @cmdDir, @cmdLs
              WORD    @cmdCd, @cmdPwd, @cmdMkdir
              WORD    @cmdType, @cmdCat, @cmdHexdump, @cmdHd
              WORD    @cmdRen, @cmdMv, @cmdCopy, @cmdCp
              WORD    @cmdDel, @cmdRm, @cmdRmdir
              WORD    @cmdDemo, @cmdCard, @cmdCid
              WORD    @cmdBenchmark, @cmdPerf, @cmdTouch
              WORD    @cmdAudit, @cmdFsck, @cmdBench
              WORD    @cmdLabel, @cmdVol
cmdTableEnd   ' last entry must be immediately above this line
' ------------------------------------------------------------
cmdCt         BYTE    (@cmdTableEnd - @cmdTable) >> 1


DAT { demo file content }

  demo_hello    byte    "Hello from the P2 SD Card Filesystem!", 13, 10
                byte    "This file was created by the demo command.", 13, 10
                byte    0

  demo_readme   byte    "P2 SD Card Driver Demo", 13, 10
                byte    "======================", 13, 10
                byte    13, 10
                byte    "This SD card filesystem driver provides:", 13, 10
                byte    "- FAT32 support for cards up to 32GB", 13, 10
                byte    "- Multiple simultaneous file handles", 13, 10
                byte    "- High-speed SPI transfers with CRC", 13, 10
                byte    "- Smart pin hardware acceleration", 13, 10
                byte    13, 10
                byte    "Type 'help' for available commands.", 13, 10
                byte    0

  demo_numbers  byte    "1 One", 13, 10
                byte    "2 Two", 13, 10
                byte    "3 Three", 13, 10
                byte    "4 Four", 13, 10
                byte    "5 Five", 13, 10
                byte    "6 Six", 13, 10
                byte    "7 Seven", 13, 10
                byte    "8 Eight", 13, 10
                byte    "9 Nine", 13, 10
                byte    "10 Ten", 13, 10
                byte    0


DAT { manufacturer lookup table - word pairs: MID, pointer to name }

  ' Manufacturer ID lookup: word MID, word @name
  ' From SD Card Association assigned IDs and observed cards
  ' 4 bytes per entry, word-aligned
  midTable
              word    $02, @midKioxia
              word    $03, @midSanDisk
              word    $09, @midATP
              word    $1B, @midSamsung
              word    $1D, @midADATA
              word    $27, @midPhison
              word    $28, @midLexar
              word    $41, @midKingston
              word    $45, @midTeam
              word    $6F, @midHiksemi
              word    $74, @midGigastone
              word    $82, @midSony
              word    $9C, @midAngelbird
              word    $9F, @midSharedOEM
              word    $AD, @midLongsys
              word    $00, 0                                           ' end sentinel

  midKioxia       byte    "Kioxia", 0
  midSanDisk      byte    "SanDisk", 0
  midATP          byte    "ATP", 0
  midSamsung      byte    "Samsung", 0
  midADATA        byte    "ADATA", 0
  midPhison       byte    "Phison", 0
  midLexar        byte    "Lexar", 0
  midKingston     byte    "Kingston", 0
  midTeam         byte    "TEAM", 0
  midHiksemi      byte    "Hiksemi", 0
  midGigastone    byte    "Gigastone", 0
  midSony         byte    "Sony", 0
  midAngelbird    byte    "Angelbird", 0
  midSharedOEM    byte    "OEM", 0
  midLongsys      byte    "Longsys", 0
  midUnknown      byte    "MID:$", 0

DAT { filesystem type strings }

  fsUnknown       byte    "Unknown", 0
  fsFAT32         byte    "FAT32", 0
  fsFAT16         byte    "FAT16", 0
  fsFAT12         byte    "FAT12", 0
  fsExFAT         byte    "exFAT", 0
  fsNTFS          byte    "NTFS", 0
  fsLinux         byte    "Linux", 0
  fsGPT           byte    "GPT", 0
  fsEmpty         byte    "Empty", 0

DAT { card type strings }

  ctSDSC          byte    "SDSC", 0
  ctSDHC          byte    "SDHC", 0
  ctSDXC          byte    "SDXC", 0

CON { setup }


PUB setup()

'' Configure IO and objects for application

  serial.start(BR_TERM)                                         ' start terminal io
  debug("SD Shell: serial started at ", udec_(BR_TERM), " baud")


PUB wait_for_terminal(clear, delay)

'' Wait for terminal to be open and key pressed

  serial.rxflush()
  serial.rx()
  if (clear)
    serial.tx(serial.CLS)
    waitms(delay #> 0)


CON { license }

{{

  Terms of Use: MIT License

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

}}
