'' =================================================================================================
''
''   File....... SD_demo_shell.spin2
''   Purpose.... Interactive command-line shell for SD card filesystem
''   Author..... Stephen M Moraco
''               Copyright (c) 2026 Iron Sheep Productions, LLC
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... FEB 2026
''   Updated.... 07 FEB 2026
''
'' =================================================================================================
''
''   Interactive shell for exploring SD card filesystem operations.
''   Supports both DOS-style (dir, type, del) and Unix-style (ls, cat, rm) commands.
''
''   Connect via serial terminal at 230,400 baud.
''   Type 'help' for list of available commands.
''
'' =================================================================================================

CON { timing }

  CLK_FREQ = 270_000_000                                        ' system freq as a constant
  MS_001   = CLK_FREQ / 1_000                                   ' ticks in 1ms
  US_001   = CLK_FREQ / 1_000_000                               ' ticks in 1us

  _clkfreq = CLK_FREQ                                           ' set system clock


CON { terminal }

  BR_TERM  = 230_400                                            ' terminal baud rate


CON { SD card pins - P2 Edge Module }

  SD_CS    = 60  { O }                                          ' directly directly directly chip select
  SD_SCK   = 61  { O }                                          ' serial clock
  SD_MOSI  = 59  { O }                                          ' master out, slave in
  SD_MISO  = 58  { I }                                          ' master in, slave out


CON { fixed io pins }

  PGM_RX   = 63  { I }                                          ' programming / debug
  PGM_TX   = 62  { O }


CON { constants }

  #true,  ON, OFF
  #false, NO, YES

  MAX_PATH    = 128                                             ' max path length
  SECTOR_SIZE = 512                                             ' SD sector size
  BUFFER_SIZE = 512                                             ' read/write buffer


CON { parser }

  CLI_BUF_SIZE = 128                                            ' command input buffer size
  CLI_MAX_TKNS =  10                                            ' max tokens per command


CON { command enums }

  #0, CMD_UNKNOWN, CMD_HELP, CMD_VERSION, CMD_CLS, CMD_CLEAR
  CMD_MOUNT, CMD_UNMOUNT, CMD_EJECT, CMD_FORMAT
  CMD_STATS, CMD_INFO, CMD_DIR, CMD_LS
  CMD_CD, CMD_PWD, CMD_MKDIR
  CMD_TYPE, CMD_CAT, CMD_HEXDUMP, CMD_HD
  CMD_REN, CMD_MV, CMD_COPY, CMD_CP
  CMD_DEL, CMD_RM, CMD_RMDIR
  CMD_DEMO, CMD_CARD, CMD_CID
  CMD_BENCHMARK, CMD_PERF, CMD_TOUCH


'' Enable full driver features for card info display
#PRAGMA EXPORTDEF SD_INCLUDE_ALL

OBJ

  sd     : "SD_card_driver"                                     '   SD card filesystem driver
  serial : "isp_serial_singleton"                               '   serial IO for terminal (singleton)


VAR { application }

  byte  buffer[BUFFER_SIZE]                                     ' general purpose buffer
  byte  pathbuf[MAX_PATH]                                       ' path buffer
  byte  cwd[MAX_PATH]                                           ' current working directory
  byte  ntokens                                                 ' number of parsed tokens
  byte  mounted                                                 ' mount status flag


VAR { parser }

  byte  cliBuf[CLI_BUF_SIZE]                                    ' command input buffer
  byte  cliIdx                                                  ' current position in buffer
  long  tkPtrs[CLI_MAX_TKNS]                                    ' pointers to parsed tokens


PUB main() | len, eCmd

  setup()
  wait_for_terminal(false, 0)

  serial.tx(serial.CLS)
  serial.fstr0(@"P2 SD Card Filesystem Shell\r")
  serial.fstr0(@"- type 'help' for commands\r")
  serial.fstr0(@"\r")

  ' Initialize current working directory
  bytemove(@cwd, @"/", 2)
  mounted := false

  repeat
    show_prompt()                                               ' prompt user
    len := get_command()                                        ' get input
    if (len > 0)                                                ' if command entered
      ntokens := parse()                                        ' parse and count tokens
      if (ntokens)                                              ' if !0 tokens
        eCmd := idCommand(lcstr(token(0)))                      ' lookup command enum
        run_command(eCmd)                                       ' run command code


PUB get_command() : len | c

'' Enter command from terminal window

  parserReset()                                                 ' prep for new entry

  repeat
    c := serial.rx()                                            ' get char from serial
    c := (c == 9) ? " " : c                                    ' convert tab to space
    if (c == 8)                                                 ' fix backspace
      serial.str(string(8, " ", 8))                             '  for terminal
    else
      serial.tx(c)                                              ' echo to terminal
    if enqueue(c)                                               ' add to input buffer
      quit                                                      '  if terminated, we're done

  return cliIdx                                                 ' report length of input


PUB show_prompt()

'' Display command prompt with current directory

  if (mounted)
    serial.fstr1(@"\rSD:%s> ", @cwd)
  else
    serial.fstr0(@"\rSD:(unmounted)> ")


CON { command handlers }


PUB run_command(eCmd)

'' Run command identified by enum value eCmd

  if (eCmd == CMD_UNKNOWN)
    serial.fstr1(@"'%s' is not recognized as a command\r", token(0))
    return

  case eCmd
    CMD_HELP                : show_help()
    CMD_VERSION             : show_version()
    CMD_CLS, CMD_CLEAR      : do_cls()
    CMD_MOUNT               : do_mount()
    CMD_UNMOUNT, CMD_EJECT  : do_unmount()
    CMD_FORMAT              : do_format()
    CMD_STATS, CMD_INFO     : do_stats()
    CMD_DIR, CMD_LS         : do_dir()
    CMD_CD                  : do_cd()
    CMD_PWD                 : do_pwd()
    CMD_MKDIR               : do_mkdir()
    CMD_TYPE, CMD_CAT       : do_type()
    CMD_HEXDUMP, CMD_HD     : do_hexdump()
    CMD_REN, CMD_MV         : do_rename()
    CMD_COPY, CMD_CP        : do_copy()
    CMD_DEL, CMD_RM         : do_delete()
    CMD_RMDIR               : do_rmdir()
    CMD_DEMO                : do_demo()
    CMD_CARD, CMD_CID       : do_card_info()
    CMD_BENCHMARK, CMD_PERF : do_benchmark()
    CMD_TOUCH               : do_touch()
    other                   : not_implemented()


PUB show_help()

'' Show available commands

  if (ntokens <> 1)
    bad_syntax()
    return

  serial.str(@s_Help)


PUB show_version()

'' Show driver version info

  if (ntokens <> 1)
    bad_syntax()
    return

  serial.fstr0(@"SD Card Driver - Iron Sheep Productions\r")
  serial.fstr1(@"SPI Frequency: %d Hz\r", sd.getSPIFrequency())


PUB do_cls()

'' Clear terminal window

  if (ntokens <> 1)
    bad_syntax()
    return

  serial.tx(serial.CLS)


PUB do_mount() | result

'' Mount SD card filesystem

  if (ntokens <> 1)
    bad_syntax()
    return

  if (mounted)
    serial.fstr0(@"SD card is already mounted\r")
    return

  serial.fstr0(@"Mounting SD card...\r")
  result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)

  if (result)
    mounted := true
    bytemove(@cwd, @"/", 2)                                     ' reset to root
    serial.fstr0(@"Mounted successfully\r")
    show_card_summary()
  else
    serial.fstr1(@"Mount failed, error: %d\r", sd.error())


PUB do_unmount()

'' Unmount SD card filesystem

  if (ntokens <> 1)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  sd.unmount()
  mounted := false
  serial.fstr0(@"SD card unmounted\r")


PUB do_format()

'' Format SD card (dangerous!)

  if (ntokens <> 1)
    bad_syntax()
    return

  serial.fstr0(@"WARNING: Format will erase ALL data on the SD card!\r")
  serial.fstr0(@"This feature is not yet implemented in this shell.\r")
  serial.fstr0(@"Use SD_format_utility.spin2 instead.\r")


PUB do_stats() | free_sectors, total_sectors, free_mb, total_mb

'' Display filesystem statistics

  if (ntokens <> 1)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  total_sectors := sd.cardSizeSectors()
  free_sectors := sd.freeSpace()

  total_mb := total_sectors / 2048                              ' sectors to MB (512 * 2048 = 1MB)
  free_mb := free_sectors / 2048

  serial.fstr0(@"\r--- SD Card Statistics ---\r")
  serial.fstr2(@"Total size:    %d sectors (%d MB)\r", total_sectors, total_mb)
  serial.fstr2(@"Free space:    %d sectors (%d MB)\r", free_sectors, free_mb)
  serial.fstr1(@"Volume label:  %s\r", sd.volumeLabel())
  serial.fstr1(@"SPI frequency: %d Hz\r", sd.getSPIFrequency())


PUB do_dir() | entry, result, count, total_size, attrib, size, p_name

'' List directory contents

  if (ntokens > 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  serial.fstr1(@"\r Directory of %s\r\r", @cwd)
  serial.fstr0(@"  Attr      Size  Name\r")
  serial.fstr0(@"  ----  --------  --------------------------------\r")

  entry := 0
  count := 0
  total_size := 0

  repeat
    result := sd.readDirectory(entry++)
    if (result == 0)                                            ' no more entries
      quit

    p_name := sd.fileName()
    if (byte[p_name] == 0)                                      ' empty name, skip
      next

    attrib := sd.attributes()
    size := sd.fileSize()

    ' Format attributes
    serial.fstr0(@"  ")
    serial.tx((attrib & $10) ? "D" : "-")                         ' directory
    serial.tx((attrib & $01) ? "R" : "-")                         ' read-only
    serial.tx((attrib & $02) ? "H" : "-")                         ' hidden
    serial.tx((attrib & $04) ? "S" : "-")                         ' system

    if (attrib & $10)                                           ' directory
      serial.fstr1(@"    <DIR>  %s\r", p_name)
    else
      serial.fstr2(@"  %8d  %s\r", size, p_name)
      total_size += size

    count++

  serial.fstr0(@"\r")
  serial.fstr2(@"  %d file(s), %d bytes\r", count, total_size)
  serial.fstr1(@"  %d bytes free\r", sd.freeSpace() * SECTOR_SIZE)


PUB do_cd() | p_path

'' Change current directory

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_path := token(1)

  ' Handle special cases
  if (strcomp(p_path, @"/") or strcomp(p_path, @"\\"))
    ' Go to root
    sd.changeDirectory(@"/")
    bytemove(@cwd, @"/", 2)
    return

  if (strcomp(p_path, @".."))
    ' Go up one level
    go_up_directory()
    return

  ' Try to change to specified directory
  if (sd.changeDirectory(p_path))
    update_cwd(p_path)
  else
    serial.fstr1(@"Directory not found: %s\r", p_path)


PUB do_pwd()

'' Print working directory

  if (ntokens <> 1)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  serial.fstr1(@"%s\r", @cwd)


PUB do_mkdir() | p_name, result

'' Create new directory

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_name := token(1)
  result := sd.newDirectory(p_name)

  if (result)
    serial.fstr1(@"Created directory: %s\r", p_name)
  else
    serial.fstr1(@"Failed to create directory: %s\r", p_name)


PUB do_type() | p_filename, handle, bytes_read, total, c, i

'' Display contents of text file

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_filename := token(1)
  handle := sd.openFileRead(p_filename)

  if (handle < 0)
    serial.fstr1(@"File not found: %s\r", p_filename)
    return

  serial.fstr0(@"\r")
  total := 0

  repeat
    bytes_read := sd.readHandle(handle, @buffer, BUFFER_SIZE - 1)
    if (bytes_read <= 0)
      quit

    ' Display as text
    repeat i from 0 to bytes_read - 1
      c := buffer[i]
      if (c == 13)                                              ' CR
        serial.tx(13)
      elseif (c == 10)                                          ' LF - skip (CR handles newline)
        ' skip
      elseif (c >= 32 and c < 127)                              ' printable
        serial.tx(c)
      else
        serial.tx(".")                                            ' non-printable

    total += bytes_read

  sd.closeFileHandle(handle)
  serial.fstr1(@"\r\r[%d bytes]\r", total)


PUB do_hexdump() | p_filename, handle, bytes_read, offset, i, c

'' Display file contents in hex format

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_filename := token(1)
  handle := sd.openFileRead(p_filename)

  if (handle < 0)
    serial.fstr1(@"File not found: %s\r", p_filename)
    return

  serial.fstr0(@"\r")
  offset := 0

  repeat
    bytes_read := sd.readHandle(handle, @buffer, 16)
    if (bytes_read <= 0)
      quit

    ' Print offset
    serial.fstr1(@"%.8x  ", offset)

    ' Print hex bytes
    repeat i from 0 to 15
      if (i < bytes_read)
        serial.fstr1(@"%.2x ", buffer[i])
      else
        serial.fstr0(@"   ")
      if (i == 7)
        serial.tx(" ")

    serial.fstr0(@" |")

    ' Print ASCII
    repeat i from 0 to bytes_read - 1
      c := buffer[i]
      if (c >= 32 and c < 127)
        serial.tx(c)
      else
        serial.tx(".")

    serial.fstr0(@"|\r")
    offset += bytes_read

    ' Limit output to first 512 bytes
    if (offset >= 512)
      serial.fstr0(@"... (truncated at 512 bytes)\r")
      quit

  sd.closeFileHandle(handle)
  serial.fstr1(@"\r[%d bytes total]\r", sd.fileSizeHandle(handle) > 0 ? sd.fileSizeHandle(handle) : offset)


PUB do_rename() | p_old, p_new, result

'' Rename file or directory

  if (ntokens <> 3)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_old := token(1)
  p_new := token(2)

  result := sd.rename(p_old, p_new)

  if (result)
    serial.fstr2(@"Renamed '%s' to '%s'\r", p_old, p_new)
  else
    serial.fstr1(@"Failed to rename: %s\r", p_old)


PUB do_copy() | p_src, p_dst, h_src, h_dst, bytes_read, total

'' Copy file

  if (ntokens <> 3)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_src := token(1)
  p_dst := token(2)

  if (strcomp(p_src, p_dst))
    serial.fstr0(@"Cannot copy file to itself\r")
    return

  h_src := sd.openFileRead(p_src)
  if (h_src < 0)
    serial.fstr1(@"Source file not found: %s\r", p_src)
    return

  h_dst := sd.createFileNew(p_dst)
  if (h_dst < 0)
    sd.closeFileHandle(h_src)
    serial.fstr1(@"Cannot create destination: %s\r", p_dst)
    return

  total := 0
  repeat
    bytes_read := sd.readHandle(h_src, @buffer, BUFFER_SIZE)
    if (bytes_read <= 0)
      quit
    sd.writeHandle(h_dst, @buffer, bytes_read)
    total += bytes_read

  sd.closeFileHandle(h_src)
  sd.closeFileHandle(h_dst)

  serial.fstr2(@"Copied %d bytes to %s\r", total, p_dst)


PUB do_delete() | p_filename, result

'' Delete file

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_filename := token(1)
  result := sd.deleteFile(p_filename)

  if (result)
    serial.fstr1(@"Deleted: %s\r", p_filename)
  else
    serial.fstr1(@"Failed to delete: %s\r", p_filename)


PUB do_rmdir()

'' Remove directory (must be empty)

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  serial.fstr0(@"rmdir not yet implemented\r")


PUB do_demo() | handle, i

'' Create demo files

  if (ntokens <> 1)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  serial.fstr0(@"Creating demo files...\r")

  ' Create text file 1
  write_demo_file(@"HELLO.TXT", @demo_hello)
  write_demo_file(@"README.TXT", @demo_readme)
  write_demo_file(@"NUMBERS.TXT", @demo_numbers)

  serial.fstr0(@"Demo files created.\r")


PUB do_card_info() | cid[4], csd[4], mid, oid[3], pnm[6], prv, psn, mdt

'' Display card identification info

  if (ntokens <> 1)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  sd.readCIDRaw(@cid)

  ' Parse CID fields
  mid := cid.byte[0]
  oid[0] := cid.byte[1]
  oid[1] := cid.byte[2]
  oid[2] := 0
  bytemove(@pnm, @cid.byte[3], 5)
  pnm[5] := 0
  prv := cid.byte[8]
  psn := (cid.byte[9] << 24) | (cid.byte[10] << 16) | (cid.byte[11] << 8) | cid.byte[12]
  mdt := ((cid.byte[13] & $0F) << 8) | cid.byte[14]

  serial.fstr0(@"\r--- SD Card Identification ---\r")
  serial.fstr1(@"Manufacturer ID:  0x%.2x\r", mid)
  serial.fstr1(@"OEM/Application:  %s\r", @oid)
  serial.fstr1(@"Product Name:     %s\r", @pnm)
  serial.fstr2(@"Product Revision: %d.%d\r", prv >> 4, prv & $0F)
  serial.fstr1(@"Serial Number:    0x%.8x\r", psn)
  serial.fstr2(@"Manufacture Date: %d/%d\r", (mdt >> 4) + 2000, mdt & $0F)
  serial.fstr1(@"Card Size:        %d MB\r", sd.cardSizeSectors() / 2048)
  serial.fstr1(@"SPI Frequency:    %d Hz\r", sd.getSPIFrequency())
  serial.fstr1(@"High-Speed Mode:  %s\r", sd.isHighSpeedActive() ? @"Active" : @"Inactive")


PUB do_benchmark() | start, elapsed, i, handle, bytes, rate

'' Quick read/write benchmark

  if (ntokens <> 1)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  serial.fstr0(@"\r--- Quick Benchmark ---\r")

  ' Write test
  serial.fstr0(@"Write test (32KB)...")
  handle := sd.createFileNew(@"_BENCH_.TMP")
  if (handle < 0)
    serial.fstr0(@" failed to create file\r")
    return

  bytefill(@buffer, $AA, BUFFER_SIZE)
  start := getct()

  repeat 64                                                     ' 64 x 512 = 32KB
    sd.writeHandle(handle, @buffer, BUFFER_SIZE)

  elapsed := getct() - start
  sd.closeFileHandle(handle)

  bytes := 64 * BUFFER_SIZE
  rate := (bytes * (clkfreq / 1000)) / elapsed                  ' bytes per ms -> KB/s
  serial.fstr2(@" %d bytes in %d ms", bytes, elapsed / (clkfreq / 1000))
  serial.fstr1(@" (%d KB/s)\r", rate)

  ' Read test
  serial.fstr0(@"Read test (32KB)... ")
  handle := sd.openFileRead(@"_BENCH_.TMP")
  if (handle < 0)
    serial.fstr0(@" failed to open file\r")
    return

  start := getct()

  repeat 64
    sd.readHandle(handle, @buffer, BUFFER_SIZE)

  elapsed := getct() - start
  sd.closeFileHandle(handle)

  rate := (bytes * (clkfreq / 1000)) / elapsed
  serial.fstr2(@" %d bytes in %d ms", bytes, elapsed / (clkfreq / 1000))
  serial.fstr1(@" (%d KB/s)\r", rate)

  ' Cleanup
  sd.deleteFile(@"_BENCH_.TMP")
  serial.fstr0(@"Benchmark complete.\r")


PUB do_touch() | p_filename, handle

'' Create empty file or update timestamp

  if (ntokens <> 2)
    bad_syntax()
    return

  if (check_mount() == false)
    return

  p_filename := token(1)
  handle := sd.createFileNew(p_filename)

  if (handle >= 0)
    sd.closeFileHandle(handle)
    serial.fstr1(@"Created: %s\r", p_filename)
  else
    serial.fstr1(@"Failed to create: %s\r", p_filename)


PUB not_implemented()

  serial.fstr1(@"%s is not implemented\r", token(0))


CON { helper methods }


PRI write_demo_file(p_name, p_content) | handle, len

'' Write demo content to file

  len := strsize(p_content)
  serial.fstr2(@"  Writing %s (%d bytes)...\r", p_name, len)

  handle := sd.createFileNew(p_name)
  if (handle < 0)
    serial.fstr0(@"    ERROR: Could not create file\r")
    return

  sd.writeHandle(handle, p_content, len)
  sd.closeFileHandle(handle)


PRI show_card_summary() | total_mb, free_mb

'' Show brief card summary after mount

  total_mb := sd.cardSizeSectors() / 2048
  free_mb := sd.freeSpace() / 2048

  serial.fstr1(@"  Volume: %s\r", sd.volumeLabel())
  serial.fstr2(@"  Size: %d MB, Free: %d MB\r", total_mb, free_mb)
  serial.fstr1(@"  SPI: %d Hz\r", sd.getSPIFrequency())


PRI check_mount() : status

'' Returns true if SD card is mounted

  status := mounted
  if (status == false)
    serial.fstr0(@"SD card not mounted. Use 'mount' command first.\r")


PRI go_up_directory() | i, len

'' Navigate up one directory level

  len := strsize(@cwd)
  if (len <= 1)                                                 ' already at root
    return

  ' Find last slash
  i := len - 1
  if (cwd[i] == "/")
    i--

  repeat while i > 0
    if (cwd[i] == "/")
      quit
    i--

  if (i == 0)
    bytemove(@cwd, @"/", 2)                                     ' back to root
  else
    cwd[i + 1] := 0                                             ' truncate path

  sd.changeDirectory(@"..")


PRI update_cwd(p_path) | len, cwd_len

'' Update current working directory string

  cwd_len := strsize(@cwd)
  len := strsize(p_path)

  if (cwd_len + len + 2 >= MAX_PATH)
    return                                                      ' path too long

  ' Add separator if needed
  if (cwd[cwd_len - 1] <> "/")
    cwd[cwd_len++] := "/"

  ' Append new directory
  bytemove(@cwd + cwd_len, p_path, len + 1)


PRI bad_syntax()

  serial.fstr0(@"Syntax error. Type 'help' for command list.\r")


PRI lcstr(p_str) : p_lcstr | c

'' Converts p_str to lowercase

  p_lcstr := p_str

  repeat strsize(p_str)
    c := byte[p_str]
    if (c >= "A") && (c <= "Z")
      byte[p_str] := c + 32
    ++p_str


CON { inline parser }


PRI parserReset()

' Reset command input buffer and tokens

  bytefill(@cliBuf, 0, CLI_BUF_SIZE)
  cliIdx := 0
  longfill(@tkPtrs, 0, CLI_MAX_TKNS)
  ntokens := 0


PRI enqueue(c) : done

' Add character to input buffer
' -- returns true when CR received

  if (c == 0) or (c == 13)                                     ' end of input?
    cliBuf[cliIdx] := 0                                         '  terminate buffer
    return true

  if (c == 8) and (cliIdx > 0)                                 ' backspace?
    cliBuf[--cliIdx] := 0                                       '  erase last char
    return false

  if (cliIdx < CLI_BUF_SIZE - 2)                                ' room in buffer?
    cliBuf[cliIdx++] := c                                       '  add character

  return false


PRI parse() : count | p

' Parse input buffer into tokens separated by spaces/tabs
' -- returns token count

  longfill(@tkPtrs, 0, CLI_MAX_TKNS)
  ntokens := 0

  if (cliIdx == 0)                                              ' nothing to parse
    return 0

  p := @cliBuf

  repeat while (ntokens < CLI_MAX_TKNS)
    ' skip separators (space, tab)
    repeat while (byte[p] == " ") or (byte[p] == 9)
      p++
    if (byte[p] == 0)                                           ' end of string
      quit
    tkPtrs[ntokens++] := p                                      ' save token start
    ' walk to next separator or end
    repeat while (byte[p] <> 0)
      if (byte[p] == " ") or (byte[p] == 9)
        byte[p++] := 0                                          ' terminate token
        quit
      p++

  return ntokens


PRI token(idx) : p_str

' Returns pointer to parsed token at index

  if (idx >= 0) and (idx < CLI_MAX_TKNS)
    return tkPtrs[idx]


PRI idCommand(pCmdStr) : eCmdId | nIdx, pEntry, pStr

' Look up command string in command table, return enum value

  eCmdId := CMD_UNKNOWN

  repeat nIdx from 0 to cmdCt - 1
    pEntry := @@WORD[@cmdTable][nIdx]                           ' get pointer from table
    pStr := @BYTE[pEntry][1]                                    ' skip enum byte, point to string
    if strcomp(pCmdStr, pStr)
      eCmdId := BYTE[pEntry][0]                                 ' matched - return embedded enum
      quit


CON { strings / lists }


DAT { help text }

  s_Help        byte    13
                byte    "  === Navigation ===", 13
                byte    "  mount        Mount SD card", 13
                byte    "  unmount      Safely unmount SD card (alias: eject)", 13
                byte    "  dir          List directory (alias: ls)", 13
                byte    "  cd <path>    Change directory", 13
                byte    "  pwd          Print working directory", 13
                byte    13
                byte    "  === File Operations ===", 13
                byte    "  type <file>  Display text file (alias: cat)", 13
                byte    "  hexdump <f>  Display file in hex (alias: hd)", 13
                byte    "  copy <s> <d> Copy file (alias: cp)", 13
                byte    "  ren <o> <n>  Rename file (alias: mv)", 13
                byte    "  del <file>   Delete file (alias: rm)", 13
                byte    "  touch <file> Create empty file", 13
                byte    "  mkdir <dir>  Create directory", 13
                byte    "  rmdir <dir>  Remove empty directory", 13
                byte    13
                byte    "  === Information ===", 13
                byte    "  stats        Show filesystem statistics (alias: info)", 13
                byte    "  card         Show card identification (alias: cid)", 13
                byte    "  benchmark    Quick read/write speed test (alias: perf)", 13
                byte    "  version      Show driver version", 13
                byte    13
                byte    "  === Utility ===", 13
                byte    "  demo         Create sample demo files", 13
                byte    "  cls          Clear screen (alias: clear)", 13
                byte    "  help         Show this help", 13
                byte    0


DAT { command table }

' ------------------------------------------------------------
'   Adjust Command Set:
'    (1) add/remove enum in CON { command enums }
'    (2) add/remove entry             "name  BYTE  ENUM, CmdString, 0"
'    (3) add/remove pointer to entry  "WORD  @name"
' ------------------------------------------------------------

' Command entries: each contains [enum_byte, "string", 0]

cmdHelp       BYTE    CMD_HELP,      "help",      0
cmdVersion    BYTE    CMD_VERSION,   "version",   0
cmdCls        BYTE    CMD_CLS,       "cls",       0
cmdClear      BYTE    CMD_CLEAR,     "clear",     0
cmdMount      BYTE    CMD_MOUNT,     "mount",     0
cmdUnmount    BYTE    CMD_UNMOUNT,   "unmount",   0
cmdEject      BYTE    CMD_EJECT,     "eject",     0
cmdFormat     BYTE    CMD_FORMAT,    "format",    0
cmdStats      BYTE    CMD_STATS,     "stats",     0
cmdInfo       BYTE    CMD_INFO,      "info",      0
cmdDir        BYTE    CMD_DIR,       "dir",       0
cmdLs         BYTE    CMD_LS,        "ls",        0
cmdCd         BYTE    CMD_CD,        "cd",        0
cmdPwd        BYTE    CMD_PWD,       "pwd",       0
cmdMkdir      BYTE    CMD_MKDIR,     "mkdir",     0
cmdType       BYTE    CMD_TYPE,      "type",      0
cmdCat        BYTE    CMD_CAT,       "cat",       0
cmdHexdump    BYTE    CMD_HEXDUMP,   "hexdump",   0
cmdHd         BYTE    CMD_HD,        "hd",        0
cmdRen        BYTE    CMD_REN,       "ren",       0
cmdMv         BYTE    CMD_MV,        "mv",        0
cmdCopy       BYTE    CMD_COPY,      "copy",      0
cmdCp         BYTE    CMD_CP,        "cp",        0
cmdDel        BYTE    CMD_DEL,       "del",       0
cmdRm         BYTE    CMD_RM,        "rm",        0
cmdRmdir      BYTE    CMD_RMDIR,     "rmdir",     0
cmdDemo       BYTE    CMD_DEMO,      "demo",      0
cmdCard       BYTE    CMD_CARD,      "card",      0
cmdCid        BYTE    CMD_CID,       "cid",       0
cmdBenchmark  BYTE    CMD_BENCHMARK, "benchmark", 0
cmdPerf       BYTE    CMD_PERF,      "perf",      0
cmdTouch      BYTE    CMD_TOUCH,     "touch",     0

cmdTable      ' first table-entry must follow immediately
              WORD    @cmdHelp, @cmdVersion, @cmdCls, @cmdClear
              WORD    @cmdMount, @cmdUnmount, @cmdEject, @cmdFormat
              WORD    @cmdStats, @cmdInfo, @cmdDir, @cmdLs
              WORD    @cmdCd, @cmdPwd, @cmdMkdir
              WORD    @cmdType, @cmdCat, @cmdHexdump, @cmdHd
              WORD    @cmdRen, @cmdMv, @cmdCopy, @cmdCp
              WORD    @cmdDel, @cmdRm, @cmdRmdir
              WORD    @cmdDemo, @cmdCard, @cmdCid
              WORD    @cmdBenchmark, @cmdPerf, @cmdTouch
cmdTableEnd   ' last entry must be immediately above this line
' ------------------------------------------------------------
cmdCt         BYTE    (@cmdTableEnd - @cmdTable) >> 1


DAT { demo file content }

  demo_hello    byte    "Hello from the P2 SD Card Filesystem!", 13, 10
                byte    "This file was created by the demo command.", 13, 10
                byte    0

  demo_readme   byte    "P2 SD Card Driver Demo", 13, 10
                byte    "======================", 13, 10
                byte    13, 10
                byte    "This SD card filesystem driver provides:", 13, 10
                byte    "- FAT32 support for cards up to 32GB", 13, 10
                byte    "- Multiple simultaneous file handles", 13, 10
                byte    "- High-speed SPI transfers with CRC", 13, 10
                byte    "- Smart pin hardware acceleration", 13, 10
                byte    13, 10
                byte    "Type 'help' for available commands.", 13, 10
                byte    0

  demo_numbers  byte    "1 One", 13, 10
                byte    "2 Two", 13, 10
                byte    "3 Three", 13, 10
                byte    "4 Four", 13, 10
                byte    "5 Five", 13, 10
                byte    "6 Six", 13, 10
                byte    "7 Seven", 13, 10
                byte    "8 Eight", 13, 10
                byte    "9 Nine", 13, 10
                byte    "10 Ten", 13, 10
                byte    0


CON { setup }


PUB setup()

'' Configure IO and objects for application

  serial.start(BR_TERM)                                         ' start terminal io


PUB wait_for_terminal(clear, delay)

'' Wait for terminal to be open and key pressed

  serial.rxflush()
  serial.rx()
  if (clear)
    serial.tx(serial.CLS)
    waitms(delay #> 0)


CON { license }

{{

  Terms of Use: MIT License

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

}}
