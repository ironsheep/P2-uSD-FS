{{┌──────────────────────────────────────────┐
  │ SD card driver                           │  Verified with Panasonic 512MB SD
  │ Author: Chris Gadd                       │                PNY 8GB SDHC
  │ Copyright (c) 2023 Chris Gadd            │                SanDisk Extreme 32GB SDHC                                       3V3
  │ See end of file for terms of use.        │                GSKILL 32GB Micro SDHC                                              ┌─────┐
  └──────────────────────────────────────────┘  cards must be formatted as FAT32                                               │   ┤ Read / write        ├─────┐
                                                                                                                             ─┼───┤ CS                  │     │
  sd.mount(CS,MOSI,MISO,SCK)                            ' mount SD card                                                      ─┼───┤ MOSI                │     │
  sd.newDirectory(string("folder1"))                    ' create a new directory                                               │ ┌─┤ Gnd                 │     │
  sd.changeDirectory(string("folder1"))                 ' switch to newly created directory                                    └─┼─┤ Vcc                 │     │
  sd.newFile(string("fileA.txt"))                       ' create a new file, leaves file open for writing                    ───┼─┤ SCK                 │     │
  sd.writeString(string("this is file A"))              ' write to newly created file                                            ┣─┤ Gnd                 │     │
  sd.closeFile()                                        ' close file, update filesize information                            ───┼─┤ MISO                │     │
                                                                                                                                 │ ┤ IRQ                 │     │
  sd.openFile(string("fileA.txt"))                      ' open file in current directory                                         │ ┤ Card detect         │     │
  -or-                                                  ' -or-                                                                   │ ┤ Write protect       ├─────┘
  sd.openFile(string("/folder1/fileA.txt"))             ' open file from path (1st "/" resets directory to root)                 │ └─┳───────────────────┘
  sd.read(@buffer,sd.fileSize())                        ' read opened file into buffer                                              
  debug(zstr(@buffer))
}}
CON  '' flags
  F_OPEN    = decod 0
  F_NEWDIR  = decod 1
  F_NEWDATA = decod 2
  F_MOUNTED = decod 3

CON '' command codes for worker cog
  CMD_NONE      = 0         ' Idle / command complete
  CMD_MOUNT     = 1         ' Mount filesystem
  CMD_UNMOUNT   = 2         ' Unmount filesystem
  CMD_OPEN      = 3         ' Open file: param0=filename ptr
  CMD_CLOSE     = 4         ' Close file
  CMD_READ      = 5         ' Read: param0=buffer ptr, param1=count
  CMD_WRITE     = 6         ' Write: param0=buffer ptr, param1=count
  CMD_SEEK      = 7         ' Seek: param0=position
  CMD_NEWFILE   = 8         ' Create new file: param0=filename ptr
  CMD_NEWDIR    = 9         ' Create new directory: param0=dirname ptr
  CMD_DELETE    = 10        ' Delete file: param0=filename ptr
  CMD_RENAME    = 11        ' Rename: param0=oldname, param1=newname
  CMD_CHDIR     = 12        ' Change directory: param0=dirname ptr
  CMD_READDIR   = 13        ' Read directory entry: param0=index
  CMD_FILESIZE  = 14        ' Get file size
  CMD_FREESPACE = 15        ' Get free space
  CMD_SYNC      = 16        ' Flush buffers
  CMD_MOVEFILE  = 17        ' Move file: param0=name, param1=dest folder

CON '' error codes
  SUCCESS           = 0
  E_TIMEOUT         = -1        ' Card didn't respond in time
  E_NO_RESPONSE     = -2        ' Card not responding
  E_BAD_RESPONSE    = -3        ' Unexpected response from card
  E_CRC_ERROR       = -4        ' Data CRC mismatch
  E_WRITE_REJECTED  = -5        ' Card rejected write operation
  E_CARD_BUSY       = -6        ' Card busy
  E_NOT_MOUNTED     = -20       ' Filesystem not mounted
  E_INIT_FAILED     = -21       ' Card initialization failed
  E_NOT_FAT32       = -22       ' Card not formatted as FAT32
  E_BAD_SECTOR_SIZE = -23       ' Sector size not 512 bytes
  E_FILE_NOT_FOUND  = -40       ' File doesn't exist
  E_FILE_EXISTS     = -41       ' File already exists
  E_NOT_A_FILE      = -42       ' Expected file, found directory
  E_NOT_A_DIR       = -43       ' Expected directory, found file
  E_FILE_NOT_OPEN   = -45       ' File not open
  E_END_OF_FILE     = -46       ' Read past end of file
  E_DISK_FULL       = -60       ' No free clusters
  E_NO_LOCK         = -64       ' Couldn't allocate hardware lock

CON '' worker cog stack size
  STACK_SIZE = 128              ' 128 longs = 512 bytes

CON '' streamer configuration (compile-time constants for bulk sector transfers)
  ' Reference: flash_loader.spin2 pattern, P2 Silicon Doc streamer section
  ' Streamer modes for SPI sector I/O:
  ' X_1P_1DAC1_WFBYTE = capture 1 pin to WFBYTE (RX to hub)
  ' X_RFBYTE_1P_1DAC1 = RFBYTE to 1 pin output (TX from hub)
  ' X_WRITE_ON = enable WRFAST for capture modes
  ' X_PINS_ON = enable pin output for transmit modes
  ' X_ALT_ON = MSB-first bit order (required for SPI)
  ' Pin field: bits [22:17] = pin number, added at runtime
  STREAM_RX_BASE = X_1P_1DAC1_WFBYTE | X_WRITE_ON | X_ALT_ON   ' RX mode
  STREAM_TX_BASE = X_RFBYTE_1P_1DAC1 | X_PINS_ON | X_ALT_ON    ' TX mode

DAT '' singleton control - SHARED across all object instances
  ' ═══════════════════════════════════════════════════════════════════════
  ' SINGLETON CONTROL - Must be initialized to "not started" state
  ' ═══════════════════════════════════════════════════════════════════════
  cog_id        LONG    -1              ' Worker cog ID (-1 = not started)
  api_lock      LONG    -1              ' Hardware lock ID (-1 = not allocated)

  ' ═══════════════════════════════════════════════════════════════════════
  ' PARAMETER BLOCK - Communication between API and worker cog
  ' ═══════════════════════════════════════════════════════════════════════
  pb_cmd        LONG    0               ' Command (0 = idle/done)
  pb_status     LONG    0               ' Result status code
  pb_caller     LONG    0               ' Caller's cog ID (for COGATN signal)
  pb_param0     LONG    0               ' Parameter 0 (varies by command)
  pb_param1     LONG    0               ' Parameter 1
  pb_param2     LONG    0               ' Parameter 2
  pb_param3     LONG    0               ' Parameter 3
  pb_data0      LONG    0               ' Result data 0 (handle, count, etc.)
  pb_data1      LONG    0               ' Result data 1

  ' ═══════════════════════════════════════════════════════════════════════
  ' WORKER COG STACK
  ' ═══════════════════════════════════════════════════════════════════════
  cog_stack     LONG    0[STACK_SIZE]   ' Worker cog stack

  ' ═══════════════════════════════════════════════════════════════════════
  ' SPI PIN CONFIGURATION (set once at start)
  ' ═══════════════════════════════════════════════════════════════════════
  cs            LONG    0               ' Chip select pin
  mosi          LONG    0               ' Master out, slave in pin
  miso          LONG    0               ' Master in, slave out pin
  sck           LONG    0               ' Serial clock pin

  ' ═══════════════════════════════════════════════════════════════════════
  ' SMART PIN SPI CONFIGURATION (Phase 1 Performance Sprint)
  ' P_TRANSITION for clock, P_SYNC_TX for transmit, P_SYNC_RX for receive
  ' B-input offset links MOSI/MISO to SCK for synchronized operation
  ' ═══════════════════════════════════════════════════════════════════════
  spi_clk_mode  LONG    0               ' P_PULSE | P_OE for SCK
  spi_tx_mode   LONG    0               ' P_SYNC_TX | P_OE for MOSI
  spi_rx_mode   LONG    0               ' P_SYNC_RX for MISO
  spi_period    LONG    0               ' Current SPI half-period (for sysclk-independent timing)
  spi_freq      LONG    0               ' Actual achieved SPI frequency (Hz)
  spi_event     LONG    0               ' Event config for waitse1 (%01_000000 | sck)
  use_smartpin  LONG    0               ' 0 = bit-bang (fallback), 1 = smart pin mode
  sp_debug_ctr  LONG    0               ' Debug counter for sp_transfer_8

  ' ═══════════════════════════════════════════════════════════════════════
  ' FILESYSTEM STATE (moved from VAR)
  ' ═══════════════════════════════════════════════════════════════════════
  fat_sec       LONG    0               ' Starting sector of FAT
  fat2_sec      LONG    0               ' Starting sector of FAT2 (mirror)
  sec_per_fat   LONG    0               ' Sectors per FAT
  sec_per_clus  LONG    0               ' Sectors per cluster
  root_sec      LONG    0               ' Starting sector of root directory
  cluster_offset LONG   0               ' Cluster offset calculation
  dir_sec       LONG    0               ' Current directory sector
  entry_address LONG    0               ' Current entry byte address
  date_stamp    LONG    0               ' Timestamp for new files
  n_sec         LONG    0               ' Current sector number
  file_idx      LONG    0               ' Position within file
  flags         LONG    0               ' Open/new file flags
  sec_in_buf    LONG    0               ' Sector currently in buffer
  bit_delay     LONG    0               ' SPI bit delay
  hcs           LONG    0               ' High capacity support flag
  fsinfo_sec    LONG    0               ' FSInfo sector number
  fsi_free_count LONG   0               ' Cached free cluster count
  fsi_nxt_free  LONG    0               ' Cached next free cluster hint
  vbr_sec       LONG    0               ' Volume Boot Record sector
  ocr_value     LONG    0               ' Cached OCR register (from CMD58)

  ' ═══════════════════════════════════════════════════════════════════════
  ' PER-COG ERROR STORAGE (for thread-safe error reporting)
  ' ═══════════════════════════════════════════════════════════════════════
  last_error    LONG    0[8]            ' One slot per possible cog

  ' ═══════════════════════════════════════════════════════════════════════
  ' BUFFERS (must be in DAT for worker cog access)
  ' ═══════════════════════════════════════════════════════════════════════
  buf           BYTE    0[512]          ' Main sector buffer
  entry_buffer  BYTE    0[32]           ' Directory entry buffer
  vol_label     BYTE    0[12]           ' Volume label (11 chars + null)

PUB null()                                                                      '' not a top-level object

CON '' ═══════════════════════════════════════════════════════════════════════════
    '' MULTI-COG LIFECYCLE METHODS
    '' ═══════════════════════════════════════════════════════════════════════════

PUB start(_cs, _mosi, _miso, _sck) : result                                     '' Start worker cog (singleton)
  '' Initialize SD card driver and launch dedicated worker cog.
  '' This method is idempotent - calling multiple times is safe.
  '' Returns cog ID (0-7) on success, -1 on failure.
  ''
  '' @param _cs   - Chip select pin number
  '' @param _mosi - Master Out Slave In pin number
  '' @param _miso - Master In Slave Out pin number
  '' @param _sck  - Serial clock pin number

  ' Check if already started (singleton pattern)
  if cog_id <> -1
    debug("  [start] Already started (cog ", udec_(cog_id), ")")
    return cog_id

  ' Store pin configuration
  longmove(@cs, @_cs, 4)

  ' Allocate hardware lock for API serialization
  api_lock := locknew()
  if api_lock == -1
    debug("  [start] FAIL: Could not allocate lock")
    return set_error(E_NO_LOCK)

  ' Initialize parameter block
  pb_cmd := CMD_NONE
  pb_status := SUCCESS
  sec_in_buf := -1                                                              ' Invalidate buffer

  ' Launch worker cog
  cog_id := cogspin(NEWCOG, fs_worker(), @cog_stack)
  if cog_id == -1
    lockret(api_lock)
    api_lock := -1
    debug("  [start] FAIL: Could not start worker cog")
    return set_error(E_NO_LOCK)

  debug("  [start] Worker cog ", udec_(cog_id), " started, lock ", udec_(api_lock))
  return cog_id

PUB stop()                                                                      '' Stop worker cog
  '' Cleanly shut down the worker cog and release resources.
  '' Safe to call even if not started.

  if cog_id <> -1
    ' Send unmount command if mounted
    if flags & F_MOUNTED
      send_command(CMD_UNMOUNT, 0, 0, 0, 0)

    ' Stop the worker cog
    cogstop(cog_id)
    debug("  [stop] Worker cog ", udec_(cog_id), " stopped")
    cog_id := -1

  ' Release hardware lock
  if api_lock <> -1
    lockret(api_lock)
    api_lock := -1

  ' Clear state
  flags := 0
  sec_in_buf := -1

PUB error() : status                                                            '' Get last error for this cog
  '' Returns the error code from the most recent operation on this cog.
  '' Thread-safe: each cog has its own error slot.
  return LONG[@last_error][COGID()]

PRI set_error(code) : code_out                                                  '' Set error code for this cog
  '' Store error code in per-cog slot and return the code (for chained returns).
  LONG[@last_error][COGID()] := code
  return code

PRI fs_worker() | cur_cmd                                                       '' Worker cog main loop
  '' This method runs in the dedicated worker cog.
  '' It owns the SPI pins and handles all filesystem operations.

  debug("  [fs_worker] Starting on cog ", udec_(COGID()))

  ' Initialize SPI pins (this cog owns them)
  pinh(cs)                                                                      ' CS HIGH = deselected
  pinh(mosi)                                                                    ' MOSI HIGH idle
  pinl(sck)                                                                     ' SCK LOW (SPI mode 0)

  debug("  [fs_worker] Pins initialized: CS=P", udec_(cs), " MOSI=P", udec_(mosi), " MISO=P", udec_(miso), " SCK=P", udec_(sck))

  ' Main command loop
  repeat
    ' Wait for command (polling - will optimize to WAITATN later)
    repeat until (cur_cmd := pb_cmd) <> CMD_NONE

    debug("  [fs_worker] Received command ", udec_(cur_cmd))

    ' Dispatch command
    case cur_cmd
      CMD_MOUNT:
        pb_status := do_mount()

      CMD_UNMOUNT:
        pb_status := do_unmount()

      CMD_OPEN:
        pb_status := do_open(pb_param0)

      CMD_CLOSE:
        do_close()
        pb_status := SUCCESS

      CMD_READ:
        pb_data0 := do_read(pb_param0, pb_param1)
        pb_status := SUCCESS

      CMD_WRITE:
        do_write(pb_param0, pb_param1)
        pb_status := SUCCESS

      CMD_SEEK:
        pb_status := do_seek(pb_param0)

      CMD_NEWFILE:
        pb_status := do_newfile(pb_param0)

      CMD_NEWDIR:
        pb_status := do_newdir(pb_param0)

      CMD_DELETE:
        pb_status := do_delete(pb_param0)

      CMD_CHDIR:
        pb_status := do_chdir(pb_param0)

      CMD_FILESIZE:
        pb_data0 := fileSize()
        pb_status := SUCCESS

      CMD_FREESPACE:
        pb_data0 := do_freespace()
        pb_status := SUCCESS

      CMD_SYNC:
        do_sync()
        pb_status := SUCCESS

      CMD_RENAME:
        pb_status := do_rename(pb_param0, pb_param1)

      CMD_MOVEFILE:
        pb_status := do_movefile(pb_param0, pb_param1)

      CMD_READDIR:
        pb_status := do_readdir(pb_param0)

      other:
        debug("  [fs_worker] Unknown command: ", udec_(cur_cmd))
        pb_status := E_BAD_RESPONSE

    ' Signal completion
    pb_cmd := CMD_NONE
    COGATN(1 << pb_caller)                                                      ' Wake the caller

PRI send_command(op_cmd, p0, p1, p2, p3) : status                               '' Send command to worker and wait
  '' Acquire lock, send command to worker cog, wait for completion.
  '' Returns status code from worker.

  ' Verify worker cog is running
  if cog_id == -1
    debug("  [send_command] ERROR: Worker not running")
    return E_NOT_MOUNTED

  ' Acquire API lock (serialize multi-cog access)
  repeat until locktry(api_lock)

  ' Store caller ID and parameters
  pb_caller := COGID()
  pb_param0 := p0
  pb_param1 := p1
  pb_param2 := p2
  pb_param3 := p3

  ' Issue command (triggers worker)
  pb_cmd := op_cmd

  ' Wait for completion using WAITATN (efficient sleep)
  WAITATN()

  ' Get result
  status := pb_status

  ' Release lock
  lockrel(api_lock)

  return status

CON '' ═══════════════════════════════════════════════════════════════════════════
    '' INTERNAL WORKER OPERATIONS (called by fs_worker, not directly by API)
    '' ═══════════════════════════════════════════════════════════════════════════

PRI do_mount() : result | reserved                                              '' Internal mount operation
  sec_in_buf := -1
  debug("  [do_mount] Calling initCard()...")
  if initCard()
    debug("  [do_mount] initCard OK, reading MBR sector 0...")
    readSector(0)                                                               '  read master boot record
    debug("  [do_mount] MBR type code at $1C2: ", uhex_(buf[$1C2]))
    if buf[$1C2] == $0B or buf[$1C2] == $0C                                     '  offset $1C2 contains type code, $0B and $0C specify FAT32
      vbr_sec := long[@buf + $1C6]                                              '  offset $1C6 contains volume boot record sector number
      debug("  [do_mount] FAT32 detected, VBR at sector ", udec(vbr_sec))
      readSector(vbr_sec)                                                       '  read volume boot record
    else
      debug("  [do_mount] FAIL: Not FAT32 (type=", uhex_(buf[$1C2]), ")")
      return E_NOT_FAT32
    debug("  [do_mount] Bytes/sector: ", udec(word[@buf + $0B]))
    if word[@buf + $0B] <> 512
      debug("  [do_mount] FAIL: Bytes/sector not 512")
      return E_BAD_SECTOR_SIZE
    sec_per_clus := buf[$0D]
    debug("  [do_mount] Sectors/cluster: ", udec(sec_per_clus))
    if (sec_per_clus & (sec_per_clus - 1))
      debug("  [do_mount] FAIL: sec_per_clus not power of 2")
      return E_NOT_FAT32
    reserved := word[@buf + $0E]
    debug("  [do_mount] Reserved sectors: ", udec(reserved))
    debug("  [do_mount] Number of FATs: ", udec(buf[$10]))
    if buf[$10] <> 2
      debug("  [do_mount] FAIL: FAT count not 2")
      return E_NOT_FAT32
    sec_per_fat := long[@buf + $24]
    fsinfo_sec := word[@buf + $30]
    fat_sec := vbr_sec + reserved
    fat2_sec := fat_sec + sec_per_fat
    root_sec := (fat_sec + 2 * sec_per_fat)
    dir_sec := root_sec
    cluster_offset := root_sec // sec_per_clus
    bytemove(@vol_label, @buf + $47, 11)
    vol_label[11] := 0
    debug("  [do_mount] Volume label: ", zstr(@vol_label))

    ' Read FSInfo sector for free cluster count and next-free hint
    if fsinfo_sec > 0 and fsinfo_sec < reserved
      readSector(vbr_sec + fsinfo_sec)
      if long[@buf + 0] == $4161_5252 and long[@buf + 484] == $6141_7272
        fsi_free_count := long[@buf + 488]
        fsi_nxt_free := long[@buf + 492]
        debug("  [do_mount] FSInfo: free_count=", udec(fsi_free_count), " nxt_free=", udec(fsi_nxt_free))
      else
        fsi_free_count := $FFFF_FFFF
        fsi_nxt_free := $FFFF_FFFF
        debug("  [do_mount] FSInfo: invalid signatures, ignoring")
    else
      fsi_free_count := $FFFF_FFFF
      fsi_nxt_free := $FFFF_FFFF
      debug("  [do_mount] FSInfo: sector not present")

    debug("  [do_mount] SUCCESS")
    if date_stamp == 0
      setdate(2009,01,27,07,00,00)
    flags |= F_MOUNTED
    return SUCCESS
  else
    debug("  [do_mount] FAIL: initCard() returned false")
    return E_INIT_FAILED

PRI do_unmount() : result                                                       '' Internal unmount operation
  do_close()
  result := updateFSInfo()
  flags := flags & !F_MOUNTED
  debug("  [do_unmount] Card unmounted cleanly")
  return SUCCESS

PRI do_open(name_ptr) : result                                                  '' Internal open file operation
  do_close()
  if searchDirectory(name_ptr)
    if attributes() & %0001_1110 == 0
      flags |= F_OPEN
      return SUCCESS
  return E_FILE_NOT_FOUND

PRI do_close()                                                                  '' Internal close file operation
  '' Close the file and write changed data to the card
  if flags & F_NEWDATA
    writeSector(n_sec)
  if flags & (F_NEWDIR | F_NEWDATA)
    readSector(entry_address >> 9)
    bytemove(@buf + entry_address & 511, @entry_buffer, 32)
    writeSector(entry_address >> 9)
  bytefill(@entry_buffer, 0, 32)
  flags := flags & !F_NEWDATA & !F_NEWDIR & !F_OPEN
  file_idx := 0

PRI do_read(p_buffer, count) : bytes_read | delta                               '' Internal read operation
  if (flags & F_OPEN) and not (attributes() & %0001_1110)
    count <#= (fileSize() - file_idx)
    readSector(n_sec)
    repeat while count > 0
      delta := (512 - (file_idx & 511)) <# count
      bytemove(p_buffer, @buf + (file_idx & 511), delta)
      file_idx += delta
      bytes_read += delta
      p_buffer += delta
      count -= delta
      if file_idx & 511 == 0
        readNextSector()

PRI do_write(p_buffer, count) | delta, temp                                     '' Internal write operation
  if (flags & F_OPEN) and (count > 0) and not (attributes() & %0001_1111)
    if fileSize() & (sec_per_clus << 9 - 1) == 0
      temp := firstCluster()
      repeat (fileSize()-1) / (sec_per_clus << 9)
        temp := long[readFat(temp)]
      temp := allocateCluster(temp)
      if fileSize() == 0
        word[@entry_buffer + $14] := temp >> 16
        word[@entry_buffer + $1A] := temp & $FFFF
      n_sec := clus2sec(temp)
      bytefill(@buf,0,512)
    else
      do_seek(fileSize())                                                       ' Use internal seek to avoid deadlock
    repeat while count > 0
      delta := (512 - (file_idx & 511)) <# count
      bytemove(@buf + file_idx & 511, p_buffer, delta)
      sec_in_buf := n_sec
      file_idx += delta
      p_buffer += delta
      long[@entry_buffer + $1C] += delta
      count -= delta
      if count > 0 and file_idx & 511 == 0
        writeSector(n_sec++)
        bytefill(@buf,0,512)
        if ((n_sec - cluster_offset) & (sec_per_clus - 1)) == 0
          temp := allocateCluster(sec2clus(n_sec-1))
          n_sec := clus2sec(temp)
    flags |= F_NEWDATA

PRI do_seek(pos) : result | cluster                                             '' Internal seek operation
  if pos > fileSize()
    return E_END_OF_FILE
  cluster := firstCluster()
  repeat (pos / (sec_per_clus << 9))
    cluster := long[readFat(cluster)]
  n_sec := clus2sec(cluster)
  n_sec += (pos / 512) // sec_per_clus
  readSector(n_sec)
  file_idx := pos
  return SUCCESS

PRI do_newfile(name_ptr) : result | temp                                        '' Internal new file operation
  do_close()
  if searchDirectory(name_ptr)
    return E_FILE_EXISTS

  temp := (entry_address + cluster_offset << 9) & (sec_per_clus << 9 - 1)
  if temp == (sec_per_clus << 9 - 32)
    if buf[480] == $00
      temp := allocateCluster(byte2clus(entry_address))
      clearCluster(temp)

  byte[@entry_buffer + 11] := $20
  long[@entry_buffer + 14] := date_stamp
  word[@entry_buffer + 20] := $0000
  long[@entry_buffer + 22] := date_stamp
  word[@entry_buffer + 26] := $0000
  long[@entry_buffer + 28] := 0
  flags |= F_OPEN | F_NEWDIR
  return SUCCESS

PRI do_newdir(name_ptr) : result | temp                                         '' Internal new directory operation
  do_close()
  if searchDirectory(name_ptr)
    return E_FILE_EXISTS

  temp := (entry_address + cluster_offset << 9) & (sec_per_clus << 9 - 1)
  if temp == sec_per_clus << 9 - 32
    if buf[480] == $00
      temp := allocateCluster(byte2clus(entry_address))
      clearCluster(temp)

  temp := allocateCluster(0)
  byte[@entry_buffer + 11] := $10
  long[@entry_buffer + 14] := date_stamp
  word[@entry_buffer + 20] := temp >> 16
  long[@entry_buffer + 22] := date_stamp
  word[@entry_buffer + 26] := temp & $FFFF
  long[@entry_buffer + 28] := 0

  readSector(entry_address >> 9)
  bytemove(@buf + entry_address & 511, @entry_buffer, 32)
  writeSector(entry_address >> 9)

  bytefill(@buf, 0, 512)
  bytemove(@buf[0], string(".          "), 11)
  byte[@buf + 11] := $10
  long[@buf + 14] := date_stamp
  word[@buf + 20] := temp >> 16
  long[@buf + 22] := date_stamp
  word[@buf + 26] := temp & $FFFF

  temp := byte2clus(entry_address)
  if temp == 2
    temp := 0
  bytemove(@buf[32], string("..         "), 11)
  byte[@buf + 32 + 11] := $10
  long[@buf + 32 + 14] := date_stamp
  word[@buf + 32 + 20] := temp >> 16
  long[@buf + 32 + 22] := date_stamp
  word[@buf + 32 + 26] := temp & $FFFF

  n_sec := clus2sec(firstCluster())
  writeSector(n_sec)
  sec_in_buf := n_sec
  return SUCCESS

PRI do_delete(name_ptr) : result | cluster, p_cluster, fat_sector               '' Internal delete operation
  do_close()
  if searchDirectory(name_ptr) == 0
    return E_FILE_NOT_FOUND
  if attributes() & %0000_1111                                                   ' Check read-only, hidden, system, volume label
    return E_FILE_NOT_FOUND                                                     ' Protected file (but allow directories)

  buf[entry_address & 511] := $E5
  writeSector(entry_address >> 9)

  p_cluster := firstCluster()
  repeat
    cluster := long[readFAT(p_cluster)]
    long[@buf + p_cluster << 2 & 511] := 0
    if cluster >> 7 - p_cluster >> 7 <> 0
      fat_sector := p_cluster >> 7
      writeSector(fat_sector + fat_sec)
      writeSector(fat_sector + fat2_sec)
    p_cluster := cluster
  until cluster >= $0FFF_FFF8
  return SUCCESS

PRI do_chdir(name_ptr) : result                                                 '' Internal change directory operation
  do_close()
  if searchDirectory(name_ptr)
    if (attributes() & %0001_0000) or (dir_sec == root_sec)
      dir_sec := n_sec
      return SUCCESS
  return E_NOT_A_DIR

PRI do_freespace() : result | cluster                                           '' Internal free space calculation
  if not (flags & F_MOUNTED)
    return 0
  n_sec := fat_sec
  repeat sec_per_fat
    readSector(n_sec++)
    repeat cluster from 0 to 127
      if long[@buf + cluster << 2] == 0
        result++
  result := result * sec_per_clus

PRI do_sync()                                                                   '' Internal sync operation
  if flags & F_NEWDATA
    writeSector(n_sec)
    flags := flags & !F_NEWDATA
  if flags & F_NEWDIR
    readSector(entry_address >> 9)
    bytemove(@buf + entry_address & 511, @entry_buffer, 32)
    writeSector(entry_address >> 9)
    flags := flags & !F_NEWDIR

PRI do_rename(old_name, new_name) : result | bookmark, temp_sec, i              '' Internal rename operation
  if searchDirectory(old_name)
    bookmark := entry_address
    temp_sec := dir_sec
    dir_sec := entry_address >> 9
    i := 0
    repeat until byte[new_name + i] == $00
      if byte[new_name + i] == "/"
        new_name += i+1
        i := 1
      i++
    if searchDirectory(new_name) == 0
      readSector(bookmark >> 9)
      bytemove(@buf + bookmark & 511, @entry_buffer, 11)
      writeSector(bookmark >> 9)
      dir_sec := temp_sec
      return SUCCESS
  return E_FILE_NOT_FOUND

PRI do_movefile(name_ptr, dest_folder) : result | bookmark, p_temp, temp_sec    '' Internal move file operation
  p_temp := @"FILENAME.TXT"
  if do_open(name_ptr) == SUCCESS
    bookmark := entry_address
    bytemove(p_temp, filename(), 12)
    temp_sec := dir_sec
    if do_chdir(dest_folder) == SUCCESS
      if bookmark >> 9 == n_sec
        return E_FILE_EXISTS                                                    ' Same directory
      if do_newfile(p_temp) == SUCCESS
        readSector(bookmark >> 9)
        bytemove(@entry_buffer, @buf + bookmark & 511, 32)
        byte[@buf + bookmark & 511] := $E5
        writeSector(bookmark >> 9)
        do_close()
        dir_sec := temp_sec
        return SUCCESS
    dir_sec := temp_sec
  return E_FILE_NOT_FOUND

PRI do_readdir(entry_num) : result | idx, char, attrib                          '' Internal read directory operation
  idx := 0
  n_sec := dir_sec
  readSector(n_sec)

  repeat until entry_num == -1
    char := byte[@buf + idx & 511]
    attrib := byte[@buf + idx & 511 + 11]

    if char == $00
      return E_FILE_NOT_FOUND
    elseif char <> $E5
      if attrib & %0000_1110 == 0
        entry_num--
        if entry_num == -1
          bytemove(@entry_buffer, @buf + idx & 511, 32)
          return SUCCESS
    idx += 32
    if idx & 511 == 0
      readNextSector()
  return E_FILE_NOT_FOUND

CON '' ═══════════════════════════════════════════════════════════════════════════
    '' PUBLIC API - Multi-cog safe via worker cog
    '' All operations are serialized through send_command()
    '' ═══════════════════════════════════════════════════════════════════════════

CON     '' management methods
PUB mount(_cs, _mosi, _miso, _sck) : result                                     '' mount SD card (multi-cog safe)
  '' Starts worker cog (if needed) and mounts the SD card filesystem.
  '' Returns true on success, false on failure.
  '' @param _cs   - Chip select pin number
  '' @param _mosi - Master Out Slave In pin number
  '' @param _miso - Master In Slave Out pin number
  '' @param _sck  - Serial clock pin number

  ' Start worker cog if not already running
  if cog_id == -1
    if start(_cs, _mosi, _miso, _sck) == -1
      debug("  [mount] Failed to start worker cog")
      return false

  ' Send mount command to worker
  result := send_command(CMD_MOUNT, 0, 0, 0, 0)
  if result == SUCCESS
    debug("  [mount] Mount successful")
    return true
  else
    debug("  [mount] Mount failed with error ", sdec_(result))
    set_error(result)
    return false

PUB initCardOnly(_cs, _mosi, _miso, _sck) : result                              '' initialize SD card without mounting filesystem
'' Use this for low-level operations like formatting. Does NOT read filesystem.
'' Returns true if card initialized successfully, false otherwise.
  longmove(@cs, @_cs, 4)
  pinh(cs)                                                                      '  CS HIGH = deselected
  pinh(mosi)
  pinh(sck)

  debug("  [initCardOnly] Pins: CS=P", udec_(cs), " MOSI=P", udec_(mosi), " MISO=P", udec_(miso), " SCK=P", udec_(sck))
  closeFile()
  sec_in_buf := -1
  result := initCard()
  if result
    debug("  [initCardOnly] Card initialized successfully")
  else
    debug("  [initCardOnly] Card initialization failed")

PUB cardSizeSectors() : result | csd[4], c_size, read_bl_len, c_size_mult       '' get total sectors on card by reading CSD register
'' Returns total number of 512-byte sectors on the card.
'' Must call initCardOnly() or mount() first.
  ' Read CSD using CMD9
  result := readCSD(@csd)
  if result == 0
    debug("  [cardSizeSectors] Failed to read CSD")
    return 0

  ' CSD structure version is in bits [127:126] (byte 0, bits 7:6)
  if (csd.byte[0] >> 6) == 0
    ' CSD Version 1.0 (SDSC)
    ' C_SIZE is bits [73:62] (12 bits)
    ' READ_BL_LEN is bits [83:80] (4 bits)
    ' C_SIZE_MULT is bits [49:47] (3 bits)
    read_bl_len := csd.byte[5] & $0F
    c_size := (csd.byte[6] & $03) << 10
    c_size |= csd.byte[7] << 2
    c_size |= csd.byte[8] >> 6
    c_size_mult := (csd.byte[9] & $03) << 1
    c_size_mult |= csd.byte[10] >> 7
    ' Capacity = (C_SIZE + 1) * 2^(C_SIZE_MULT + 2) * 2^READ_BL_LEN bytes
    ' Sectors = Capacity / 512
    result := (c_size + 1) << (c_size_mult + 2 + read_bl_len - 9)
    debug("  [cardSizeSectors] CSD v1.0: C_SIZE=", udec(c_size), " MULT=", udec(c_size_mult), " BL_LEN=", udec(read_bl_len))
  else
    ' CSD Version 2.0 (SDHC/SDXC)
    ' C_SIZE is bits [69:48] (22 bits)
    ' Capacity = (C_SIZE + 1) * 512KB
    c_size := (csd.byte[7] & $3F) << 16
    c_size |= csd.byte[8] << 8
    c_size |= csd.byte[9]
    ' Sectors = (C_SIZE + 1) * 1024 (each unit is 512KB = 1024 sectors)
    result := (c_size + 1) * 1024
    debug("  [cardSizeSectors] CSD v2.0: C_SIZE=", udec(c_size))

  debug("  [cardSizeSectors] Total sectors: ", udec(result))

PUB writeSectorRaw(sector, p_buffer) : result                                   '' write a sector at absolute LBA address
'' Low-level sector write for formatting/partitioning. Bypasses filesystem.
'' @param sector - absolute LBA sector number
'' @param p_buffer - pointer to 512 bytes of data to write
  bytemove(@buf, p_buffer, 512)
  result := writeSector(sector)
  if result
    debug("  [writeSectorRaw] Wrote sector ", udec(sector))
  else
    debug("  [writeSectorRaw] FAILED to write sector ", udec(sector))

PUB readSectorRaw(sector, p_buffer) : result                                    '' read a sector at absolute LBA address
'' Low-level sector read for verification. Bypasses filesystem.
'' @param sector - absolute LBA sector number
'' @param p_buffer - pointer to 512-byte buffer to receive data
  sec_in_buf := -1                                                              '  force re-read
  readSector(sector)
  bytemove(p_buffer, @buf, 512)
  result := true
  debug("  [readSectorRaw] Read sector ", udec(sector))

CON '' ═══════════════════════════════════════════════════════════════════════════
    '' CARD IDENTIFICATION METHODS (for diagnostic tools)
    '' These methods provide raw register access for card characterization.
    '' Call initCardOnly() or mount() before using these methods.
    '' ═══════════════════════════════════════════════════════════════════════════

PUB readCIDRaw(p_buf) : result                                                  '' read CID register (16 bytes) into buffer
'' Reads the Card Identification register containing manufacturer, product name,
'' serial number, and manufacturing date.
'' @param p_buf - pointer to 16-byte buffer to receive CID data
'' @return true on success, false on failure
  result := readCID(p_buf)
  if result
    debug("  [readCIDRaw] CID read successfully")
  else
    debug("  [readCIDRaw] CID read FAILED")

PUB readCSDRaw(p_buf) : result                                                  '' read CSD register (16 bytes) into buffer
'' Reads the Card Specific Data register containing capacity, speed, and features.
'' @param p_buf - pointer to 16-byte buffer to receive CSD data
'' @return true on success, false on failure
  result := readCSD(p_buf)
  if result
    debug("  [readCSDRaw] CSD read successfully")
  else
    debug("  [readCSDRaw] CSD read FAILED")

PUB readSCRRaw(p_buf) : result                                                  '' read SCR register (8 bytes) into buffer
'' Reads the SD Configuration Register containing SD spec version and bus widths.
'' @param p_buf - pointer to 8-byte buffer to receive SCR data
'' @return true on success, false on failure
  result := readSCR(p_buf)
  if result
    debug("  [readSCRRaw] SCR read successfully")
  else
    debug("  [readSCRRaw] SCR read FAILED")

PUB getOCR() : ocr                                                              '' get cached OCR register value
'' Returns the Operating Conditions Register cached during card initialization.
'' Contains card capacity status (CCS) and voltage range.
'' @return 32-bit OCR value, or 0 if card not initialized
  ocr := ocr_value
  debug("  [getOCR] OCR = $", uhex_long(ocr))

PUB readVBRRaw(p_buf) : result                                                  '' read Volume Boot Record (512 bytes) into buffer
'' Reads the Volume Boot Record sector containing filesystem parameters.
'' Card must be mounted for this method to work (VBR location determined at mount).
'' @param p_buf - pointer to 512-byte buffer to receive VBR data
'' @return true on success, false if not mounted
  if not (flags & F_MOUNTED)
    debug("  [readVBRRaw] FAILED: Card not mounted")
    return false
  sec_in_buf := -1                                                              '  force re-read
  readSector(vbr_sec)
  bytemove(p_buf, @buf, 512)
  debug("  [readVBRRaw] VBR read from sector ", udec(vbr_sec))
  return true

PRI readCSD(p_csd) : result | t, i                                              '' read CSD register using CMD9
'' Reads the 16-byte CSD register into p_csd buffer
'' Returns true on success, false on failure
  transfer(-1, 8)
  pinl(cs)
  transfer(-1, 8)
  transfer($40 | 9, 8)                                                          '  CMD9 = SEND_CSD
  transfer(0, 32)                                                               '  argument = 0
  transfer($AF, 8)                                                              '  CRC (approximate)

  ' Wait for response
  t := getct() + clkfreq
  repeat
    result := transfer(-1, 8)
    if result <> $FF
      quit
    if getct() - t > 0
      pinh(cs)
      return false

  if result <> $00
    pinh(cs)
    return false

  ' Wait for data token ($FE)
  t := getct() + clkfreq
  repeat
    result := transfer(-1, 8)
    if result == $FE
      quit
    if getct() - t > 0
      pinh(cs)
      return false

  ' Read 16 bytes of CSD data
  repeat i from 0 to 15
    byte[p_csd + i] := transfer(-1, 8)

  ' Read and discard 2-byte CRC
  transfer(-1, 16)

  pinh(cs)
  return true

PRI readCID(p_cid) : result | t, i                                              '' read CID register using CMD10
'' Reads the 16-byte CID (Card Identification) register into p_cid buffer
'' Returns true on success, false on failure
  transfer(-1, 8)
  pinl(cs)
  transfer(-1, 8)
  transfer($40 | 10, 8)                                                         '  CMD10 = SEND_CID
  transfer(0, 32)                                                               '  argument = 0
  transfer($1B, 8)                                                              '  CRC for CMD10

  ' Wait for response
  t := getct() + clkfreq
  repeat
    result := transfer(-1, 8)
    if result <> $FF
      quit
    if getct() - t > 0
      pinh(cs)
      return false

  if result <> $00
    pinh(cs)
    return false

  ' Wait for data token ($FE)
  t := getct() + clkfreq
  repeat
    result := transfer(-1, 8)
    if result == $FE
      quit
    if getct() - t > 0
      pinh(cs)
      return false

  ' Read 16 bytes of CID data
  repeat i from 0 to 15
    byte[p_cid + i] := transfer(-1, 8)

  ' Read and discard 2-byte CRC
  transfer(-1, 16)

  pinh(cs)
  return true

PRI readSCR(p_scr) : result | t, i                                              '' read SCR register using ACMD51
'' Reads the 8-byte SCR (SD Configuration Register) into p_scr buffer
'' Requires CMD55 prefix before ACMD51
'' Returns true on success, false on failure

  ' Send CMD55 (APP_CMD) first
  transfer(-1, 8)
  pinl(cs)
  transfer(-1, 8)
  transfer($40 | 55, 8)                                                         '  CMD55 = APP_CMD
  transfer(0, 32)                                                               '  argument = 0
  transfer($65, 8)                                                              '  CRC for CMD55

  ' Wait for R1 response
  t := getct() + clkfreq
  repeat
    result := transfer(-1, 8)
    if result <> $FF
      quit
    if getct() - t > 0
      pinh(cs)
      return false

  if result > $01                                                               '  Accept $00 or $01 (idle)
    pinh(cs)
    return false

  pinh(cs)                                                                      '  Deselect before ACMD51

  ' Send ACMD51 (SEND_SCR)
  transfer(-1, 8)
  pinl(cs)
  transfer(-1, 8)
  transfer($40 | 51, 8)                                                         '  ACMD51 = SEND_SCR
  transfer(0, 32)                                                               '  argument = 0
  transfer($55, 8)                                                              '  CRC (approximate)

  ' Wait for R1 response
  t := getct() + clkfreq
  repeat
    result := transfer(-1, 8)
    if result <> $FF
      quit
    if getct() - t > 0
      pinh(cs)
      return false

  if result <> $00
    pinh(cs)
    return false

  ' Wait for data token ($FE)
  t := getct() + clkfreq
  repeat
    result := transfer(-1, 8)
    if result == $FE
      quit
    if getct() - t > 0
      pinh(cs)
      return false

  ' Read 8 bytes of SCR data
  repeat i from 0 to 7
    byte[p_scr + i] := transfer(-1, 8)

  ' Read and discard 2-byte CRC
  transfer(-1, 16)

  pinh(cs)
  return true

PUB newFile(name_ptr) : result                                                  '' create and open a new file (multi-cog safe)
  '' Creates a new file in the current directory and opens it for writing.
  '' Returns true on success, false if file exists or error.
  result := send_command(CMD_NEWFILE, name_ptr, 0, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

PUB newDirectory(name_ptr) : result                                             '' create a new directory (multi-cog safe)
  '' Creates a new directory in the current directory.
  '' Returns true on success, false if directory exists or error.
  result := send_command(CMD_NEWDIR, name_ptr, 0, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

PUB openFile(name_ptr) : result                                                 '' open file (multi-cog safe)
  '' Opens an existing file for reading/writing.
  '' Returns true on success, false if not found.
  result := send_command(CMD_OPEN, name_ptr, 0, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

PUB changeDirectory(name_ptr) : result                                          '' change directory (multi-cog safe)
  '' Changes the current directory.
  '' Returns true on success, false if not found.
  result := send_command(CMD_CHDIR, name_ptr, 0, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

PUB closeFile()                                                                 '' close file (multi-cog safe)
  '' Closes the currently open file, flushing any pending writes.
  send_command(CMD_CLOSE, 0, 0, 0, 0)

PUB unmount() : result                                                          '' unmount SD card (multi-cog safe)
  '' Cleanly unmounts the SD card, flushing all data and updating FSInfo.
  '' Returns true on success.
  result := send_command(CMD_UNMOUNT, 0, 0, 0, 0)
  debug("  [unmount] Card unmounted")
  return result == SUCCESS

PUB sync() : result                                                             '' flush buffers (multi-cog safe)
  '' Flushes all pending writes without closing the file.
  '' Use this to checkpoint data during long operations.
  result := send_command(CMD_SYNC, 0, 0, 0, 0)
  debug("  [sync] Buffers flushed")
  return result == SUCCESS

PRI updateFSInfo() : result | free_count                                        '' update FSInfo sector with current free cluster count
'' Scans FAT to count free clusters and writes updated FSInfo sector.
'' Called by unmount() to ensure other OSes see correct free space.
  if fsinfo_sec == 0 or fsi_free_count == $FFFF_FFFF
    debug("  [updateFSInfo] No valid FSInfo to update")
    return false                                                                '  no FSInfo sector to update

  ' Count free clusters by scanning FAT
  free_count := countFreeClusters()

  ' Read FSInfo sector
  readSector(vbr_sec + fsinfo_sec)

  ' Verify signatures before writing
  if long[@buf + 0] <> $4161_5252 or long[@buf + 484] <> $6141_7272
    debug("  [updateFSInfo] Invalid FSInfo signatures")
    return false

  ' Update free count and next-free hint
  long[@buf + 488] := free_count                                                '  FSI_Free_Count
  long[@buf + 492] := fsi_nxt_free                                              '  FSI_Nxt_Free (keep cached value)

  ' Write updated FSInfo sector
  writeSector(vbr_sec + fsinfo_sec)
  fsi_free_count := free_count                                                  '  update cached value
  debug("  [updateFSInfo] Updated: free_count=", udec(free_count))
  return true

PRI countFreeClusters() : count | fat_idx, entry                                '' count free clusters in FAT
'' Scans entire FAT and returns number of free (zero) entries.
'' This is slow on large cards but only called on unmount().
  count := 0
  fat_idx := 8                                                                  '  start at cluster 2 (skip reserved entries 0,1)
  repeat
    if fat_idx & 511 == 0                                                       '  if at sector boundary
      if fat_idx >> 9 >= sec_per_fat                                            '  if past end of FAT
        quit
      readSector(fat_sec + fat_idx >> 9)                                        '  read next FAT sector
    entry := long[@buf + fat_idx & 511]
    if (entry & $0FFF_FFFF) == 0                                                '  check only low 28 bits
      count++
    fat_idx += 4
  sec_in_buf := -1                                                              '  invalidate buffer (FAT sector loaded)

PUB deleteFile(name_ptr) : result                                               '' delete file (multi-cog safe)
  '' Deletes a file from the current directory.
  '' Returns true on success, false if not found or protected.
  result := send_command(CMD_DELETE, name_ptr, 0, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

PUB rename(old_name, new_name) : result                                         '' rename file or directory (multi-cog safe)
  '' Renames a file or directory.
  '' Returns true on success, false if source not found or dest exists.
  result := send_command(CMD_RENAME, old_name, new_name, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

PUB moveFile(name_ptr, dest_folder) : result                                    '' move file to another directory (multi-cog safe)
  '' Moves a file from the current directory to another directory.
  '' Returns true on success, false on error.
  result := send_command(CMD_MOVEFILE, name_ptr, dest_folder, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

PUB freeSpace() : result                                                        '' get free space in sectors (multi-cog safe)
  '' Returns the number of free sectors on the card.
  '' This may take a while on large cards.
  if send_command(CMD_FREESPACE, 0, 0, 0, 0) == SUCCESS
    return pb_data0
  else
    return 0

PUB setDate(year, month, day, hour, minute, second)                             '' set the current date and time for new files/folders
  date_stamp := (year - 1980) << 25 | month << 21 | day << 16 | hour << 11 | minute << 5 | second >> 1

CON     '' read/write methods
PUB read(p_buffer, count) : result                                              '' read bytes from file (multi-cog safe)
  '' Reads up to count bytes from the open file into p_buffer.
  '' Returns the number of bytes actually read.
  if send_command(CMD_READ, p_buffer, count, 0, 0) == SUCCESS
    return pb_data0                                                             ' pb_data0 contains bytes read
  else
    return 0

PUB readByte(address) : result | byte_buf                                       '' read single byte from file (multi-cog safe)
  '' Seeks to address and reads one byte.
  seek(address)
  if read(@byte_buf, 1) == 1
    return byte_buf
  else
    return 0

PUB write(p_buffer, count) : result                                             '' write bytes to file (multi-cog safe)
  '' Writes count bytes from p_buffer to the open file.
  send_command(CMD_WRITE, p_buffer, count, 0, 0)

PUB writeByte(char) : result                                                    '' write single byte to file (multi-cog safe)
  write(@char, 1)

PUB writeString(p_str) : result                                                 '' write string to file (multi-cog safe)
  write(p_str, strsize(p_str))

PUB readDirectory(entry) : result                                               '' read directory entry (multi-cog safe)
  '' Iterates through entries in the current directory.
  '' Returns pointer to entry_buffer on success, 0 if entry doesn't exist.
  if send_command(CMD_READDIR, entry, 0, 0, 0) == SUCCESS
    return @entry_buffer
  else
    return 0

PUB seek(pos) : result                                                          '' seek to position in file (multi-cog safe)
  '' Sets file position to pos bytes from start.
  '' Returns true on success, false if pos is beyond end of file.
  result := send_command(CMD_SEEK, pos, 0, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

CON     '' directory methods
PRI searchDirectory(name_ptr) : result | p_temp, p_entry, i
  p_temp := @"FILENAMETXT"
  if byte[name_ptr] == "/"
    dir_sec := root_sec
    name_ptr++
  n_sec := dir_sec

  repeat until byte[name_ptr] == $00
    bytefill(@entry_buffer,0,32)
    i := 0

    repeat until byte[name_ptr + i] == "/" or byte[name_ptr + i] == $00         '  advance i up to "/" or null
      i++
    bytemove(@entry_buffer,name_ptr,i <# 12)                                    '  copy name into entry_buffer, max 12 characters
    name_ptr += i                                                               '  advance ptr to "/" or null
    if byte[name_ptr] == "/"                                                    '  if "/"
      name_ptr++                                                                '   advance ptr to byte following "/"

    repeat i from 0 to 11                                                       '  convert name to uppercase
      case entry_buffer[i]
        "a".."z" : entry_buffer[i] -= $20

    i := 0                                                                      '  convert 8.3 filename into short filename
    if strcomp(@entry_buffer,string("..")) == 0                                 '  exception if changing directory to ".."
      repeat strsize(@entry_buffer) <# 9                                        '  search name for extension
        if entry_buffer[i++] == "."                                             '  if extension found
          bytemove(@entry_buffer + 8,@entry_buffer + i,3)                       '   move extension to byte 8
          bytefill(@entry_buffer + i-1," ",9-i)                                 '   fill space between name and extension
    bytefill(@entry_buffer + strsize(@entry_buffer)," ",12-strsize(@entry_buffer)) ' fill remaining space (in case extension < 3 characters)
    entry_buffer[11] := $00                                                     '  append null

    i := 0
    readSector(n_sec)                                                           '  read 1st sector of directory
    entry_address := 0
    repeat
      p_entry := @buf + i & 511                                                 '  locate entry in directory
      bytemove(p_temp,p_entry,11)                                               '  copy short filename into p_temp
      if strcomp(@entry_buffer,p_temp)                                          '  if matching entry located
        entry_address := n_sec << 9 | i & 511                                   '   store the byte-level address of the entry
        bytemove(@entry_buffer,p_entry,32)                                      '   copy entire entry into entry_buffer
        if firstCluster() == 0                                                  '  exception if ".." points to root directory
          n_sec := clus2sec(2)                                                  '   root directory located in cluster 2
        else
          n_sec := clus2sec(firstCluster())                                     '   set n_sec to 1st sector of 1st cluster of file
        quit
      elseif byte[name_ptr] == $00                                              '  if end of path reached
        if (entry_address == 0) and (byte[p_temp] == $E5 or byte[p_temp] == $00) '  if entry_address not set, and 1st byte is $E5 or $00
          entry_address := n_sec << 9 | i & 511                                 '    set entry_address to 1st unused entry (for newFile / newDirectory)

      if byte[p_temp] == $00                                                    '  entry not found in directory
        return false
      i += 32                                                                   '  increment to next entry
      if i & 511 == 0                                                           '  read new directory sector/cluster if needed
        readNextSector()
  file_idx := 0
  return true

PUB fileName() : result | p_temp, i                                             '' return the 8.3 filename of the currently opened file
  p_temp := @"filename.txt"
  bytemove(p_temp,@entry_buffer,11)
  i := 0
  repeat until byte[p_temp + i++] == " " or i == 9
  bytemove(p_temp + i,p_temp + 8,3)
  if attributes() & $10
    byte[p_temp + i-1] := $00
  else
    byte[p_temp + i-1] := "."
    byte[p_temp + i+3] := $00
  return p_temp

PUB attributes() : result                                                       '' return the attribute byte of the currently opened file
  return entry_buffer[$0B]

PUB volumeLabel() : result                                                      '' return pointer to volume label string
  return @vol_label

PRI firstCluster() : result                                                     '' return the 1st cluster location of the currently opened file
  return word[@entry_buffer + $14] << 16 | word[@entry_buffer + $1A]

PUB fileSize() : result                                                         '' return the size of the currently opened file in bytes
  return long[@entry_buffer + $1C]

CON     '' FAT and sector methods
PRI readFat(cluster) : result | contents, p_contents                            '' read a FAT location and return a pointer to the location of that entry
  readSector((cluster >> 7 + fat_sec))                                          '  128 entries in each FAT sector
  result := @buf + (cluster << 2) & 511

PRI allocateCluster(cluster) : result | fat_idx, buf_idx, high_bits             '' searches FAT for an empty cluster, allocates cluster, returns cluster number
  fat_idx := 0                                                                  '   if cluster parameter <> 0, writes newly allocated cluster number in parameter cell
  repeat
    if fat_idx & 511 == 0                                                       '  if lower nine bits of index are clear
      readSector(fat_sec + fat_idx >> 9)                                        '   load next sector of FAT
    buf_idx := fat_idx & 511
    result := long[@buf + buf_idx]                                              '  read a cluster cell
    if (result & $0FFF_FFFF) == $0000_0000                                      '  if cluster cell is empty (check only low 28 bits)
      high_bits := result & $F000_0000                                          '  preserve high 4 bits
      long[@buf + buf_idx] := high_bits | $0FFF_FFFF                            '  mark as end-of-chain, preserve high bits
      result := fat_idx >> 2                                                    '  store cluster number in result
      writeSector(fat_sec + result >> 7)                                        '  write FAT1 sector
      writeSector(fat2_sec + result >> 7)                                       '  write FAT2 sector (MIRROR)
      if cluster <> 0                                                           '  if allocateCluster was called with a non-zero cluster parameter
        readSector(fat_sec + cluster >> 7)                                      '   read FAT sector containing cluster cell
        buf_idx := cluster << 2 & 511
        high_bits := long[@buf + buf_idx] & $F000_0000                          '  preserve high 4 bits
        long[@buf + buf_idx] := high_bits | (result & $0FFF_FFFF)               '  link to new cluster, preserve high bits
        writeSector(fat_sec + cluster >> 7)                                     '  write FAT1 sector
        writeSector(fat2_sec + cluster >> 7)                                    '  write FAT2 sector (MIRROR)
      return
    fat_idx += 4                                                                '  advance index to next cluster cell

PRI clearCluster(cluster)                                                       '' initialize entire contents of cluster to 0
  n_sec := clus2sec(cluster)                                                    '  set n_sec to 1st sector of specified cluster
  bytefill(@buf,0,512)                                                          '  clear buffer
  repeat sec_per_clus                                                           '  repeat for all sectors in the cluster
    writeSector(n_sec++)                                                        '   overwrite sector
  sec_in_buf := n_sec - 1

PRI readNextSector() | cluster, address, contents                               '' loads the next sector into buffer
  n_sec++
  if ((n_sec - cluster_offset) & (sec_per_clus - 1)) == 0                       '  if next sector is in a different cluster
    cluster := sec2clus(n_sec-1)                                                '   find current cluster number
    readSector(cluster >> 7 + fat_sec)                                          '   read sector of FAT containing cluster number (128 cluster entries in each FAT sector)
    address := @buf + (cluster << 2) & 511                                      '   find long within sector for current cluster
    contents := long[address]                                                   '   read contents to determine next cluster number
    n_sec := clus2sec(contents)                                                 '   convert next cluster number into sector number
  readSector(n_sec)

CON     '' helper methods
PRI byte2clus(byte_address) : result                                            '' convert byte address to cluster number
  return (sec2clus(byte_address >> 9))

PRI sec2clus(sector) : result                                                   '' convert sector number to cluster number
  return (sector - root_sec) / sec_per_clus + 2

PRI clus2byte(cluster) : result                                                 '' convert cluster number to byte address
  return clus2sec(cluster) << 9

PRI clus2sec(cluster) :result                                                   '' convert cluster number to sector number
  return (cluster - 2) * sec_per_clus + root_sec

CON     '' low-level SPI routines

PRI initSPIPins()                                                               '' configure smart pins for SPI operation
  '' Initialize Smart Pins for high-speed SPI communication (configure ONCE).
  '' Pattern from working isp_tile_sensor.spin2:
  '' - DIRL -> WRPIN -> WXPIN -> DIRH (no WYPIN during config)
  '' - Smart pins stay enabled, WYPIN triggers transfers
  ''
  '' SCK uses P_PULSE for clock generation (X = period | low_time<<16)
  '' MOSI uses P_SYNC_TX for synchronized transmit (clocked by SCK)
  '' MISO uses P_SYNC_RX for synchronized receive (clocked by SCK)
  '' CS remains standard GPIO (manual control)

  ' Smart pin mode configuration using compiler constants
  ' P_TRANSITION: clock generation with X = half-period (transitions toggle output)
  ' P_SYNC_TX: synchronized serial transmit (clocked by B-input)
  ' P_SYNC_RX: synchronized serial receive (clocked by B-input)
  ' P_PLUS2_B, P_PLUS3_B: B-input pin selector for clock source
  ' Reference: ManAtWork SpiFlash.spin2 (OBEX 2872) - working smart pin SPI
  ' CRITICAL: Do NOT use P_INVERT_OUTPUT for SD card SPI mode 0!
  ' ManAtWork's flash uses different polarity. SD cards need clock idle LOW.
  spi_clk_mode := P_TRANSITION | P_OE                                           ' Transition mode, idle LOW for SPI mode 0
  spi_tx_mode := P_SYNC_TX | P_OE | P_PLUS2_B                                   ' Sync TX, clock from pin+2 (SCK)
  spi_rx_mode := P_SYNC_RX | P_PLUS3_B                                          ' Sync RX, clock from pin+3 (SCK)

  debug("    [initSPIPins] Setting up smart pins (ManAtWork pattern)...")
  debug("    [initSPIPins] Mode values:")
  debug("    [initSPIPins]   spi_clk_mode=$", uhex_long(spi_clk_mode), " (P_TRANSITION | P_OE, idle LOW)")
  debug("    [initSPIPins]   spi_tx_mode=$", uhex_long(spi_tx_mode), " (P_SYNC_TX | P_OE | P_PLUS2_B)")
  debug("    [initSPIPins]   spi_rx_mode=$", uhex_long(spi_rx_mode), " (P_SYNC_RX | P_PLUS3_B)")
  debug("    [initSPIPins]   SCK=P", udec_(sck), " MOSI=P", udec_(mosi), " MISO=P", udec_(miso))

  ' ════════════════════════════════════════════════════════════════════
  ' CS PIN: Standard GPIO (unchanged from bit-bang)
  ' CS is manually controlled - LOW = selected, HIGH = deselected
  ' ════════════════════════════════════════════════════════════════════
  pinh(cs)                                                                      ' Start deselected

  ' ════════════════════════════════════════════════════════════════════
  ' SCK PIN: P_TRANSITION mode for clock generation
  ' X register: half-period in clocks (time between transitions)
  ' Y register: Number of transitions (2 per bit) - loaded via WYPIN per transfer
  ' Configure with FLTL -> WRPIN, then WXPIN/DRVL in setSPISpeed()
  ' ════════════════════════════════════════════════════════════════════
  pinfloat(sck)                                                                 ' FLTL - reset smart pin
  wrpin(sck, spi_clk_mode)                                                      ' P_TRANSITION | P_OE | P_INVERT_OUTPUT
  ' X register (half-period) will be set by setSPISpeed()
  debug("    [initSPIPins]   SCK configured: P_TRANSITION | P_OE (awaiting setSPISpeed)")

  ' ════════════════════════════════════════════════════════════════════
  ' MOSI PIN: P_SYNC_TX mode for synchronized transmit
  ' B-input set via P_PLUS2_B (clock from SCK which is 2 pins higher)
  ' X register: %M_NNNNN where M=mode (1=start/stop), N=bits-1
  ' Y register: Data to transmit - loaded via WYPIN per transfer
  ' Configure with DIRL -> WRPIN -> WXPIN -> DIRH (no WYPIN yet)
  ' ════════════════════════════════════════════════════════════════════
  pinfloat(mosi)                                                                ' DIRL - reset smart pin
  wrpin(mosi, spi_tx_mode)                                                      ' P_SYNC_TX | P_OE | P_PLUS2_B
  wxpin(mosi, %1_00111)                                                         ' Start-stop mode, 8 bits default
  pinh(mosi)                                                                    ' DIRH - enable smart pin
  debug("    [initSPIPins]   MOSI configured: P_SYNC_TX | P_PLUS2_B (enabled)")

  ' ════════════════════════════════════════════════════════════════════
  ' MISO PIN: P_SYNC_RX mode for synchronized receive
  ' B-input set via P_PLUS3_B (clock from SCK which is 3 pins higher)
  ' X register: %M_NNNNN where M=mode (1=post-edge for SPI mode 0), N=bits-1
  ' Z register: Received data - read via RDPIN per transfer
  ' Configure with DIRL -> WRPIN -> WXPIN -> DIRH (no WYPIN needed)
  ' ════════════════════════════════════════════════════════════════════
  pinfloat(miso)                                                                ' DIRL - reset smart pin
  wrpin(miso, spi_rx_mode)                                                      ' P_SYNC_RX | P_PLUS3_B
  wxpin(miso, %1_00111)                                                         ' On-edge sample (SPI mode 0), 8 bits
  pinh(miso)                                                                    ' DIRH - enable smart pin
  debug("    [initSPIPins]   MISO configured: P_SYNC_RX | P_PLUS3_B (enabled)")

  ' Configure event SE1 for efficient waiting on SCK completion
  ' Event format: D[5:0]=pin, D[7:6]=%01 for positive edge on IN
  ' This allows waitse1 instead of polling testp loop
  spi_event := %01_000000 | sck
  configureEvent(spi_event)
  debug("    [initSPIPins]   Event SE1 configured for SCK pin ", udec_(sck))

  ' Mark smart pin mode as active
  use_smartpin := 1
  debug("    [initSPIPins] Smart pins configured and enabled")

PRI configureEvent(event_config) | ev                                           '' configure SE1 event for waitse1
  '' Helper to configure SE1 event from a computed value
  '' Event format: D[5:0]=pin, D[7:6]=%01 for positive edge on IN
  ev := event_config
  org
        setse1  ev
  end

PRI setSPISpeed(freq) | half_period, actual_freq                                '' set SPI clock frequency
  '' Configure SPI clock speed for sysclk-independent operation.
  '' Using P_TRANSITION mode: X = half-period (time between transitions)
  '' Reference: ManAtWork SpiFlash.spin2
  ''
  '' Formula: half_period = clkfreq / (freq * 2)
  '' For 400 kHz: half_period = 320M / 800k = 400 clocks
  '' For 25 MHz: half_period = 320M / 50M = 6.4 -> minimum 4
  ''
  '' @param freq - Target SPI frequency in Hz (e.g., 400_000 or 25_000_000)

  ' Calculate half-period (time between transitions) in system clocks
  ' Use ceiling division to ensure we never exceed target frequency
  ' Formula: ceil(a/b) = (a + b - 1) / b
  half_period := (clkfreq + (freq * 2) - 1) / (freq * 2)

  ' Guard against too-small period (ManAtWork uses minimum of 4)
  if half_period < 4
    half_period := 4
    debug("    [setSPISpeed] WARNING: Half-period clamped to minimum (4)")

  ' Calculate actual achieved frequency for debugging
  actual_freq := clkfreq / (half_period * 2)

  ' Store in DAT variables for debugging/monitoring
  spi_period := half_period
  spi_freq := actual_freq

  ' Configure SCK smart pin X register and enable with DRVL
  wxpin(sck, half_period)                                                       ' Set transition period
  pinl(sck)                                                                     ' DRVL enables smart pin (ManAtWork pattern)

  debug("    [setSPISpeed] Target=", udec_(freq/1000), " kHz, Actual=", udec_(actual_freq/1000), " kHz")
  debug("    [setSPISpeed] Half-period=", udec_(half_period), " clocks")

PRI sp_transfer(data, bits) : result                                            '' smart pin SPI transfer (variable bits)
  '' For now, only support 8-bit and 32-bit transfers
  if bits == 8
    result := sp_transfer_8(data)
  elseif bits == 32
    result := sp_transfer_32(data)
  else
    ' Fallback to bit-bang for unsupported sizes
    result := transfer(data, bits)

PRI sp_transfer_8(data) : result | _sck, _mosi, _miso, tx_data, raw_result      '' 8-bit smart pin SPI transfer
  '' Full-duplex 8-bit SPI transfer using smart pins
  '' Reference: ManAtWork SpiFlash.spin2 (OBEX 2872)
  '' TX: shl #24, rev, wypin data, 16 transitions
  '' RX: wait on MISO IN flag, rdpin, rev, zerox #7
  _sck := sck
  _mosi := mosi
  _miso := miso
  tx_data := data
  org
        ' Prepare TX data: shift to MSB position and reverse for LSB-first transmission
        shl     tx_data, #24                    ' Move byte to bits [31:24]
        rev     tx_data                         ' Reverse for MSB-first SPI

        ' Configure MOSI for 8-bit start-stop mode and load data
        wxpin   #$27, _mosi                     ' 8 bits, start-stop mode (%1_00111)
        wypin   tx_data, _mosi
        drvl    _mosi                           ' Enable TX smart pin

        ' Configure MISO for 8-bit receive
        ' Note: wrpin already set from initSPIPins - don't use dirl which clears it!
        wxpin   #$27, _miso                     ' 8 bits, start-stop mode
        akpin   _miso                           ' Clear any pending IN flag
        dirh    _miso                           ' Enable smart pin

        ' Start clock: 16 transitions = 8 clock cycles
        wypin   #16, _sck
        nop

        ' Wait for MISO receive complete (not clock!)
.waitRx testp   _miso                   wz      ' IN=1 when receive complete
  if_nz jmp     #.waitRx

        ' Read received data - keep raw value for debug
        rdpin   raw_result, _miso
        mov     result, raw_result
        rev     result                          ' Reverse for MSB-first
        zerox   result, #7                      ' Limit to 8 bits
  end
  ' Debug: show raw rdpin value and pin info occasionally
  if sp_debug_ctr < 5
    debug("    [sp_transfer_8] pins: miso=", udec_(_miso), " sck=", udec_(_sck), " raw=", uhex_long_(raw_result), " final=", uhex_byte_(result))
    sp_debug_ctr++

PRI sp_transfer_32(data) : result | _sck, _mosi, _miso, tx_data                 '' 32-bit smart pin SPI transfer
  '' Full-duplex 32-bit SPI transfer using smart pins
  _sck := sck
  _mosi := mosi
  _miso := miso
  tx_data := data
  org
        ' Prepare TX data: reverse for LSB-first transmission
        rev     tx_data                         ' Reverse for MSB-first SPI

        ' Configure MOSI for 32-bit start-stop mode and load data
        wxpin   #$3F, _mosi                     ' 32 bits, start-stop mode (%1_11111)
        wypin   tx_data, _mosi
        drvl    _mosi                           ' Enable TX smart pin

        ' Configure MISO for 32-bit receive
        wxpin   #$3F, _miso                     ' 32 bits, start-stop mode
        drvl    _miso                           ' Enable RX smart pin

        ' Start clock: 64 transitions = 32 clock cycles
        wypin   #64, _sck
        nop

        ' Wait for MISO receive complete
.waitRx testp   _miso                   wz      ' IN=1 when receive complete
  if_nz jmp     #.waitRx

        ' Read received data
        rdpin   result, _miso
        rev     result                          ' Reverse for MSB-first
  end

PRI initCard() : result | t, resp, card_version, acmd41_arg                     '' intialize SD card
  debug("    [initCard] Starting card init...")
  debug("    [initCard] Reference: SPI_SD_Implementation_Reference.md")
  sec_in_buf := -1

  ' ============================================
  ' STEP 1: Power-on delay
  ' Spec: VDD must be stable, then wait 1ms minimum
  ' ============================================
  debug("    [initCard] Step 1: Power-on delay (100ms)...")
  waitms(100)

  ' ============================================
  ' STEP 2: Configure SPI pins and slow clock
  ' Spec: Use 100-400 kHz during initialization
  ' ============================================
  bit_delay := clkfreq / 100_000                                                '  ~50kHz for init (conservative)
  debug("    [initCard] Step 2: SPI config, bit_delay=", udec(bit_delay), " (~50kHz)")

  ' SD card SPI mode 0: CPOL=0, CPHA=0
  ' Data sampled on rising edge, changed on falling edge
  pinh(cs)                                                                      '  CS HIGH = deselected
  pinh(mosi)                                                                    '  MOSI HIGH (card expects high during idle)
  pinl(sck)                                                                     '  SCK LOW (SPI mode 0 idle state)
  pinf(miso)                                                                    '  MISO as floating input

  debug("    [initCard] Pins: CS=", udec_(pinr(cs)), " MOSI=", udec_(pinr(mosi)), " MISO=", udec_(pinr(miso)), " SCK=", udec_(pinr(sck)))

  ' ============================================
  ' STEP 3: Card recovery + init clocks
  ' If card is stuck mid-transfer, flush with extra clocks
  ' Then send 74+ clocks per spec for power-on init
  ' ============================================
  debug("    [initCard] Step 3: Recovery flush (4096 clocks to clear stuck transfer)...")
  repeat 4096                                                                     '  Enough to flush a full 512-byte sector
    pinh(sck)
    waitus(10)
    pinl(sck)
    waitus(10)

  debug("    [initCard] MISO after recovery flush: ", udec_(pinr(miso)), " (should be 1)")

  ' ============================================
  ' STEP 3.5: Initialize smart pins for SPI
  ' ============================================
  debug("    [initCard] Step 3.5: Initializing smart pins (ManAtWork pattern)...")
  initSPIPins()
  setSPISpeed(400_000)                                                          ' 400 kHz for init
  waitus(100)                                                                   ' Let smart pins settle

  ' Send dummy clocks using smart pins
  repeat 10
    sp_transfer_8($FF)
  debug("    [initCard] Dummy clocks sent via smart pins")

  ' ============================================
  ' STEP 4: CMD0 - GO_IDLE_STATE
  ' Sends: 0x40 0x00 0x00 0x00 0x00 0x95
  ' Expected R1: 0x01 (in idle state)
  ' ============================================
  debug("    [initCard] Step 4: CMD0 (GO_IDLE_STATE)...")
  resp := 0
  repeat 5                                                                      '  try up to 5 times
    resp := cmd(0, 0)
    debug("    [initCard] CMD0 response: $", uhex_(resp))
    if resp == $01
      quit
    waitms(10)

  if resp <> $01
    debug("    [initCard] FAIL: CMD0 expected $01, got $", uhex_(resp))
    if resp == $FF
      debug("    [initCard] ($FF = no response, check wiring)")
    return false

  debug("    [initCard] CMD0 OK - card in idle state")

  ' ============================================
  ' STEP 5: CMD8 - SEND_IF_COND
  ' Sends: 0x48 0x00 0x00 0x01 0xAA 0x87
  ' Argument: VHS=0x01 (2.7-3.6V), check_pattern=0xAA
  ' Expected R7: R1 + 4 bytes echoing VHS and pattern
  ' ============================================
  debug("    [initCard] Step 5: CMD8 (SEND_IF_COND, VHS=1, pattern=$AA)...")
  resp := cmd(8, $000001AA)                                                     '  send CMD8, get 32-bit echo
  debug("    [initCard] CMD8 response (32-bit): $", uhex_long(resp))

  card_version := 1                                                             '  assume v1.x until proven otherwise
  acmd41_arg := $00000000                                                       '  HCS=0 for v1.x cards

  if resp == 0                                                                  '  timeout or no response
    debug("    [initCard] CMD8 no response -> Ver 1.x SD card (SDSC only)")
    card_version := 1
    acmd41_arg := $00000000                                                     '  no HCS for v1.x
  elseif (resp & $FFF) == $1AA                                                  '  check VHS and pattern echo
    debug("    [initCard] CMD8 echo valid ($1AA) -> Ver 2.0+ SD card")
    card_version := 2
    acmd41_arg := $40000000                                                     '  HCS=1 for v2.0+ (support SDHC/SDXC)
  else
    debug("    [initCard] CMD8 echo unexpected: $", uhex_long(resp & $FFF), " expected $1AA")
    debug("    [initCard] Treating as Ver 1.x card")
    card_version := 1
    acmd41_arg := $00000000

  ' ============================================
  ' STEP 6: ACMD41 - SD_SEND_OP_COND (loop until ready)
  ' Requires CMD55 prefix before each ACMD41
  ' CMD55: 0x77 0x00 0x00 0x00 0x00 0x65
  ' ACMD41: 0x69 [arg] CRC
  ' Expected R1: 0x00 when ready, 0x01 while initializing
  ' ============================================
  debug("    [initCard] Step 6: ACMD41 init loop (arg=$", uhex_long(acmd41_arg), ")...")
  t := getct() + clkfreq * 2                                                    '  2 second timeout

  repeat
    resp := cmd(55, 0)                                                          '  APP_CMD prefix
    if resp > $01                                                               '  error other than "in idle"
      debug("    [initCard] CMD55 error: $", uhex_(resp))
      waitms(10)
    else
      resp := cmd(41, acmd41_arg)                                               '  SD_SEND_OP_COND
      if resp == $00                                                            '  card ready (not in idle anymore)
        debug("    [initCard] ACMD41 complete - card ready!")
        quit
      elseif resp == $01                                                        '  still initializing
        ' continue looping
      else
        debug("    [initCard] ACMD41 unexpected response: $", uhex_(resp))

    if getct() - t > 0
      debug("    [initCard] FAIL: ACMD41 timeout after 2 seconds")
      debug("    [initCard] Last response: $", uhex_(resp))
      return false
    waitms(10)

  ' ============================================
  ' STEP 7: CMD58 - READ_OCR
  ' Sends: 0x7A 0x00 0x00 0x00 0x00 0xFD
  ' Expected R3: R1 + 32-bit OCR register
  ' Check bit 31 (busy), bit 30 (CCS)
  ' ============================================
  debug("    [initCard] Step 7: CMD58 (READ_OCR)...")
  resp := cmd(58, 0)
  ocr_value := resp                                                             '  Cache OCR for later retrieval
  debug("    [initCard] OCR: $", uhex_long(resp))
  debug("    [initCard]   Bit 31 (ready): ", udec((resp >> 31) & 1))
  debug("    [initCard]   Bit 30 (CCS):   ", udec((resp >> 30) & 1))

  if (resp >> 30) & 1
    hcs := 0                                                                    '  SDHC/SDXC: block addressing (no shift)
    debug("    [initCard] Card type: SDHC/SDXC (block addressing)")
  else
    hcs := 9                                                                    '  SDSC: byte addressing (shift by 9 = multiply by 512)
    debug("    [initCard] Card type: SDSC (byte addressing)")

  ' ============================================
  ' STEP 8: Increase SPI speed for data transfer
  ' PNY FIX: CS must be HIGH during clock change, then send dummy clocks
  ' ============================================
  pinh(cs)                                                                      '  ensure CS HIGH before speed change
  setSPISpeed(25_000_000)                                                       '  25 MHz SPI for high-speed data transfer
  debug("    [initCard] Step 8: Switched to 25 MHz SPI via smart pins")
  ' Send dummy clocks with CS HIGH to stabilize new clock rate
  repeat 8
    sp_transfer(-1, 8)                                                          '  8 dummy bytes = 64 clocks (using smart pins)
  debug("    [initCard] Dummy clocks sent, CS HIGH")
  debug("    [initCard] === INIT SUCCESS ===")
  return true


PRI cmd(op,parm) : result | t                                                   '' send a SPI command (using smart pins)
  if op == 0
    debug("      [cmd] CS before assert: ", udec_(pinr(cs)))
  sp_transfer(-1,8)                                                             '  required for certain cards (my 512MB card fails if not present)
  pinl(cs)                                                                      '  CS LOW = selected (standard active-LOW)
  if op == 0
    debug("      [cmd] CS after pinl: ", udec_(pinr(cs)), " MISO=", udec_(pinr(miso)))
  sp_transfer(-1,8)                                                             '  required for certain cards (my 512MB and 32GB cards fail if not present)
  sp_transfer($40 | op,8)
  sp_transfer(parm,32)
  if op == 0
    sp_transfer($95,8)                                                          '  send CRC for cmd(0,0)
    debug("      [cmd] After CMD0 sent, MISO=", udec_(pinr(miso)))
  else
    sp_transfer($87,8)                                                          '  send CRC for cmd(8,$1AA)
  t := getct() + clkfreq
  repeat
    result := sp_transfer(-1,8)                                                 '  read 1st byte of reply
    if result <> $FF
      quit
    if getct() - t > 0                                                          '  check timeout
      pinh(cs)                                                                  '  CS HIGH = deselected (standard active-LOW)
      return false
  if op == 8 or op == 58                                                        '  read 32-bit reply for cmd8 and cmd58
    result := sp_transfer(-1,32)                                                '  (memory card interface condition and operation conditions register
  if op <> 17 and op <> 24 and op <> 55                                         '  keep cs asserted if readSector, writeSector, or application command
    pinh(cs)                                                                    '  CS HIGH = deselected (standard active-LOW)

PRI readSector(sector) : result | _sck, _miso, data, loop_ctr, timeout, stream_mode, clk_count, xfrq, init_phase, p_buf  '' read a sector into buffer using P2 streamer
  '' Returns 0 on success, -1 on timeout/error
  '' Uses P2 streamer for bulk 512-byte transfer (hardware DMA)
  '' Reference: flash_loader.spin2 pattern for SPI reads
  ''
  '' Protocol:
  '' 1. CMD17 (READ_SINGLE_BLOCK) with sector address
  '' 2. Wait for $FE start token (polled via sp_transfer_8)
  '' 3. Receive 512 bytes via streamer (MISO -> hub)
  '' 4. Receive 2 CRC bytes (discarded)
  '' 5. Deselect card

  if sector == sec_in_buf
    return 0
  sec_in_buf := sector

  ' Send CMD17 (READ_SINGLE_BLOCK)
  cmd(17, sector << hcs)

  ' Wait for start token ($FE) - use sp_transfer_8 for token polling
  timeout := getct() + clkfreq                                                  ' 1 second timeout
  loop_ctr := 0
  repeat
    data := sp_transfer_8($FF)
    loop_ctr++
    if data == $FE
      quit                                                                      ' Got start token
    if data <> $FF
      debug("  [readSector] ERROR: got $", uhex_byte_(data), " instead of $FF or $FE")
      pinh(cs)
      sec_in_buf := -1
      return -1
    if getct() - timeout > 0
      debug("  [readSector] TIMEOUT waiting for start token")
      pinh(cs)
      sec_in_buf := -1
      return -1

  ' ════════════════════════════════════════════════════════════════════════════
  ' STREAMER BULK TRANSFER: Receive 512 bytes from MISO to hub buffer
  ' Pattern: SETXFRQ -> WRFAST -> WYPIN(clk) -> WAITX -> XINIT -> WAITXFI
  ' ════════════════════════════════════════════════════════════════════════════
  _sck := sck
  _miso := miso
  p_buf := @buf
  ' Mode word format: base_mode | (pin << 17) | bit_count
  ' For 512 bytes: 512 * 8 = 4096 bits = $1000
  stream_mode := STREAM_RX_BASE | (_miso << 17) | (512 * 8)                     ' RX mode + MISO pin + bit count
  clk_count := 512 * 8 * 2                                                      ' 8192 clock transitions

  ' Calculate streamer NCO frequency to match SPI clock
  ' NCO adds xfrq to phase accumulator each sysclock; sample occurs on MSB 0->1 transition
  ' Full SPI bit period = 2 * spi_period sysclocks
  ' xfrq = $8000_0000 / (full_period) = $8000_0000 / (2 * spi_period) = $4000_0000 / spi_period
  ' BUG FIX: Previous code had << 1 which DOUBLED the rate, sampling twice per bit!
  xfrq := $4000_0000 / spi_period                                               ' One sample per full clock period

  ' Phase alignment: pre-load NCO so first sample occurs 1 sysclock after xinit
  ' Without this, first sample would be delayed by a full period, missing bit 0
  ' init_phase = $8000_0000 - xfrq means: after 1 sysclock, phase crosses $8000_0000
  init_phase := $8000_0000 - xfrq                                               ' Pre-load for immediate first sample

  ' ════════════════════════════════════════════════════════════════════════════
  ' STREAMER BULK TRANSFER: 512 bytes via hardware DMA
  ' Sequence: SETXFRQ -> WRFAST -> WYPIN(clk) -> WAITX #3 -> XINIT -> WAITXFI
  ' The waitx #3 aligns clock rising edge with first streamer sample
  ' ════════════════════════════════════════════════════════════════════════════
  org
        setxfrq xfrq                             ' Set streamer bit rate
        wrfast  #0, p_buf                        ' Setup WRFAST to hub buffer
        wypin   clk_count, _sck                  ' Start clock transitions
        waitx   #3                               ' Align clock with sampling (2+3=5 cycles)
        xinit   stream_mode, init_phase          ' Start streamer with phase offset
        waitxfi                                  ' Wait for streamer to complete
  end

  ' Read and discard 2 CRC bytes (required by protocol)
  sp_transfer_8($FF)
  sp_transfer_8($FF)

  pinh(cs)                                                                      ' Deselect card
  result := 0

PRI writeSector(sector) : result | _sck, _mosi, p_buf, stream_mode, clk_count, xfrq, t, resp '' write buffer into a sector using P2 streamer
  '' Write a sector using P2 streamer for bulk 512-byte transfer (hardware DMA)
  '' Reference: flash_loader.spin2 pattern for SPI writes
  ''
  '' PNY COMPATIBILITY: This implementation follows strict SPI write protocol:
  '' 1. CMD24 with sector address
  '' 2. Data start token ($FE)
  '' 3. 512 bytes of data via streamer (hub -> MOSI)
  '' 4. 2 CRC bytes (dummy $FF since CRC disabled in SPI mode)
  '' 5. Wait for data-response token ($x5 = accepted)
  '' 6. Wait for MISO to go HIGH ($FF = programming complete)
  '' CRITICAL: CS must stay LOW and clocking must continue during entire busy period!

  _sck := sck
  _mosi := mosi
  p_buf := @buf
  cmd(24, sector << hcs)
  sp_transfer_8($FE)                                                            ' Data start token

  ' ════════════════════════════════════════════════════════════════════════════
  ' STREAMER BULK TRANSFER: Send 512 bytes from hub buffer to MOSI
  ' Pattern: SETXFRQ -> RDFAST -> XINIT -> WYPIN(clk) -> WAITXFI
  ' ════════════════════════════════════════════════════════════════════════════
  ' Mode word format: base_mode | (pin << 17) | bit_count
  ' For 512 bytes: 512 * 8 = 4096 bits = $1000
  stream_mode := STREAM_TX_BASE | (_mosi << 17) | (512 * 8)                     ' TX mode + MOSI pin + bit count
  clk_count := 512 * 8 * 2                                                      ' 8192 clock transitions

  ' Calculate streamer NCO frequency to match SPI clock
  ' Same formula as readSector: one bit per full clock period
  xfrq := $4000_0000 / spi_period                                               ' One output per full clock period

  ' For TX: xinit BEFORE wypin (data leads clock) - per flash_loader pattern
  ' This ensures data is stable before rising edge when slave samples
  org
        setxfrq xfrq                              ' Set streamer bit rate
        rdfast  #0, p_buf                         ' Setup RDFAST from hub buffer
        xinit   stream_mode, #0                   ' Start streamer output first
        wypin   clk_count, _sck                   ' Then start clock transitions
        waitxfi                                   ' Wait for streamer to complete
  end

  ' Send 2 CRC bytes (dummy values - CRC not checked in SPI mode but bytes required)
  sp_transfer_8($FF)                                                            ' CRC byte 1
  sp_transfer_8($FF)                                                            ' CRC byte 2

  ' Wait for data-response token (should be immediate, within a few bytes)
  t := getct() + clkfreq / 10                                                   ' 100ms timeout for response
  repeat
    resp := sp_transfer_8($FF)
    if resp <> $FF
      quit
    if getct() - t > 0
      debug("  [writeSector] TIMEOUT waiting for data-response")
      pinh(cs)
      return false

  ' Verify data-response token: bits [4:0] should be xxx00101 = $05 (data accepted)
  if (resp & $1F) <> $05
    debug("  [writeSector] Data rejected: response=$", uhex_(resp))
    pinh(cs)
    return false

  ' Wait for card to finish programming (busy period)
  ' Card holds MISO LOW during internal flash write, releases to HIGH ($FF) when done
  ' CRITICAL for PNY: Keep CS LOW and keep clocking until we see stable $FF!
  t := getct() + clkfreq / 2                                                    ' 500ms timeout per block (generous)
  repeat
    resp := sp_transfer_8($FF)                                                  ' Clock 8 bits while reading MISO
    if resp == $FF                                                              ' Card released MISO = programming complete
      quit
    if getct() - t > 0
      debug("  [writeSector] TIMEOUT waiting for programming complete")
      pinh(cs)
      return false

  pinh(cs)
  return true

PRI transfer(data,bits) : result | _cs, _mosi, _miso, _sck, delay               '' transfer data to/from SD card
  longmove(@_cs,@cs,4)
  delay := bit_delay
  result := data << (32-bits)                                                   '  move data to MSB
  org
                rep       @.end_rep,bits
                 rcl      result,#1                     wc                      '  send from msb of result, receive into lsb of result
                 drvl     _sck
                 drvc     _mosi
                 waitx    delay
                 drvh     _sck
                 waitx    delay
                 testp    _miso                         wc
.end_rep
                drvh      _mosi
                rcl       result,#1
  end
  if bits < 32                                                                   '  mask to requested bit count
    result &= (1 << bits) - 1                                                   '  (skip for 32 bits - mask would wrap)

CON     '' debug methods
  _CLKFREQ = 80_000_000
PUB displaySector() | address, char, ascii_ptr, i                               '' display sector in buffer
  ascii_ptr := string("0123456789ABCDEF")
  repeat address from 0 to 495 step 16
    repeat i from 0 to 15
      case char := (buf[address + i])
        $20..$7E: byte[ascii_ptr + i] := char
        other:
          if char == 0
            byte[ascii_ptr + i] := "."
          else
            byte[ascii_ptr + i] := char // 26 + "a"
    debug(uhex_word_(address),uhex_byte_array_(@buf + address,8),"-",uhex_byte_array_(@buf + address + 8,8)," | ",lstr_(ascii_ptr,16))

PUB displayEntry() | address, char, ascii_ptr, i
  ascii_ptr := string("0123456789ABCDEF")
  repeat address from 0 to 31 step 16
    repeat i from 0 to 15
      case char := (entry_buffer[address + i])
        $20..$7E: byte[ascii_ptr + i] := char
        other:
          if char == 0
            byte[ascii_ptr + i] := "."
          else
            byte[ascii_ptr + i] := char // 26 + "a"
    debug(uhex_word_(address),uhex_byte_array_(@entry_buffer + address,8),"-",uhex_byte_array_(@entry_buffer + address + 8,8)," | ",lstr_(ascii_ptr,16))

PUB displayFAT(cluster)                                                         '' display FAT sector containing cluster number
  n_sec := fat_sec + cluster >> 7
  readSector(n_sec)
  displaySector()

CON {{     FAT32 file system
  ┌─────────────────────────┐     The master boot record contains 446 bytes of boot code
  │ Master Boot Record      │      followed by four 16-byte partition entries
  │                         │      terminated with $55 $AA in the final 2 bytes
  │ Partitions      $55 $AA │     The 16-byte partition
  ├─────────────────────────┤     ┌──────┬───────┬──────┬─────┬───────┬───────────┐
  │ Reserved                │     │ Boot │ CHS   │ Type │ CHS │ LBA   │ Number of │  Type code located at byte address $1C2
  ├─────────────────────────┤     │ Flag │ Begin │ Code │ End │ Begin │ Sectors   │   Type code = $0B or $0C for FAT32
  │ Volume Boot Record 1    │     ├──────┼───────┼──────┼─────┼───────┼───────────┤  LBA Begin contains address of volume boot record (VBR)
  ├─────────────────────────┤     │      │       │  5   │     │ 9-12  │           │   VBR address located at byte address $1C6
  │ Reserved                │     └──────┴───────┴──────┴─────┴───────┴───────────┘
  ├─────────────────────────┤     Volume boot record contains
  │ Volume Boot Record 2    │     ┌─────────────────────────────────┬────────┬──────┬────────────────────┐
  ├─────────────────────────┤     │          Field                  │ Offset │ Size │ Value              │
  │ Reserved                │     ├─────────────────────────────────┼────────┼──────┼────────────────────┤
  ├─────────────────────────┤     │ Bytes per Sector                │  $0B   │ 16b  │       512          │
  │ File allocation table 1 │     │ Sectors per Cluster             │  $0D   │  8b  │1/2/4/8/16/32/64/128│
  ├─────────────────────────┤     │ Number of Reserved Sectors      │  $0E   │ 16b  │                    │
  │ File allocation table 2 │     │ Number of FATs                  │  $10   │  8b  │        2           │
  ├─────────────────────────┤     │ Sectors per FAT                 │  $24   │ 32b  │                    │
  │ Root directory and      │     │ Root Directory of First Cluster │  $2C   │ 32b  │        2           │
  │  Data region            │     │ Signature                       │ $1FE   │ 16b  │      $AA55         │
  │                         │     └─────────────────────────────────┴────────┴──────┴────────────────────┘
  │                         │      The address of the 1st FAT is VBR address + number of reserved sectors
  │                         │      The address of the root directory is FAT address + number of FATs x sectors per fat
  └─────────────────────────┘
                                  The file system directory contains 32-byte entries for each file in the root directory
                                  ┌─────────────────────────────────┬────────┬──────┐
                                  │          Field                  │ Offset │ Size │  The first byte of the short filename indicates the type of entry
                                  ├─────────────────────────────────┼────────┼──────┤   Normal entry     - as expected   "FILENAMETXT"
                                  │ Short Filename                  │  $00   │ 11B  │   Unused/deleted   - 1st byte $E5  "åILENAMETXT"
                                  │ Attrib Byte                     │  $0B   │  1B  │   End of directory - 1st byte $00
                                  │ Date of creation                │  $0E   │  4B  │
                                  │ First Cluster High              │  $14   │  2B  │
                                  │ Date of modification            │  $16   │  4B  │
                                  │ First Cluster Low               │  $1A   │  2B  │
                                  │ File Size                       │  $1C   │  4B  │
                                  └─────────────────────────────────┴────────┴──────┘
                                  Attrib byte contains bitfields
                                  ┌───┬───────────┬─────┬────────────────────────────────────┐
                                  │bit│ Function  │ LFN │ Comment                            │
                                  ├───┼───────────┼─────┼────────────────────────────────────┤
                                  │ 7 │ Unused    │  0  │ Should be zero                     │
                                  │ 6 │ Unused    │  0  │ Should be zero                     │
                                  │ 5 │ Archive   │  x  │ Has been changed since last backup │
                                  │ 4 │ Directory │  x  │ Is a subdirectory                  │
                                  │ 3 │ Volume ID │  1  │ Filename is Volume ID              │
                                  │ 2 │ System    │  1  │ File is operating system           │
                                  │ 1 │ Hidden    │  1  │ Should not show in dir listing     │
                                  │ 0 │ Read Only │  1  │ Should not allow writing           │
                                  └───┴───────────┴─────┴────────────────────────────────────┘
                                  Each entry in the file allocation table is 32 bits, entry 0 is associated with cluster 0, entry 1/cluster 1, and so on
                                   The 32-bit value contains 0 if the associated cluster is available
                                   contains $0FFF_FFFF if the data in the associated cluster ends in that cluster
                                   contains the address of the next cluster in the file if the file occupies multiple clusters
                                  ┌───────────┬───────────┬───────────┬───────────┐
              clusters $00 - $03  │ 0FFF_FFFF │ 0FFF_FFFF │ 0FFF_FFFF │ 0FFF_FFFF │  1st four clusters occupied by self-contained files
                       $04 - $07  │ 0000_0005 │ 0000_0006 │ 0000_0007 │ 0FFF_FFFF │  next four clusters occupied by a file in sequential clusters
                       $08 - $0B  │ 0000_000A │ 0FFF_FFFF │ 0000_000C │ 0FFF_FFFF │  a fragmented file starts in cluster 8, and occupies clusters 10, 12, and ends in 14
                       $0C - $0F  │ 0000_000E │ 0000_0000 │ 0FFF_FFFF │ 0000_0000 │  clusters 13 and 15 are unused
}}
CON
{{
┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                                   TERMS OF USE: MIT License                                                  │
├──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation    │
│files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,    │
│modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software│
│is furnished to do so, subject to the following conditions:                                                                   │
│                                                                                                                              │
│The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.│
│                                                                                                                              │
│THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE          │
│WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR         │
│COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,   │
│ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                         │
└──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
}}