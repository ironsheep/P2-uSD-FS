'' =================================================================================================
''
''   File....... SD_performance_benchmark.spin2
''   Purpose.... Performance benchmark for SD card driver - measures real-world throughput
''   Author..... Stephen M Moraco
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... JAN 2026
''   Updated.... 07 FEB 2026
''
'' =================================================================================================
''
'' Measures SD card driver performance across three levels:
''
''   1. RAW SINGLE-SECTOR: readSectorsRaw/writeSectorsRaw with count=1
''      - Isolates: command dispatch + SPI transfer + card latency
''      - Uses multi-sector API with count=1 to avoid debug print overhead
''
''   2. RAW MULTI-SECTOR: readSectorsRaw/writeSectorsRaw with CMD18/CMD25
''      - Shows benefit of amortizing command overhead across N sectors
''      - Tests at 8, 32, and 64 sector counts
''
''   3. FILE-LEVEL: createFileNew/openFileRead + writeHandle/readHandle + closeFileHandle
''      - Includes FAT traversal, cluster allocation, sector caching
''      - Real-world throughput an application developer will see
''
'' Run on each card, at both 320 MHz and 270 MHz sysclk, to build performance catalog.
''
'' Test sizes (embedded use cases):
''   Write: 512B (log entry), 4KB (config), 32KB (data batch)
''   Read:  4KB (config), 32KB (icon), 128KB (small image), 256KB (large image)
''
'' =================================================================================================

CON

    _CLKFREQ        = 350_000_000       ' Change to 250_000_000 for low-sysclk runs

    ' Pin configuration for P2 Edge with SD card
    SD_CS   = 60
    SD_MOSI = 59
    SD_MISO = 58
    SD_SCK  = 61

    ' Test parameters
    ITERATIONS      = 10                ' Number of iterations per test

    ' Test sizes (in bytes)
    SIZE_512B       = 512
    SIZE_4KB        = 4096
    SIZE_32KB       = 32768
    SIZE_128KB      = 131072
    SIZE_256KB      = 262144

    ' Buffer size - must accommodate largest test
    BUFFER_SIZE     = 262144 + 512      ' 256KB + margin

    ' Multi-sector test parameters
    SECTOR_SIZE     = 512
    MULTI_8         = 8                 ' 4KB
    MULTI_32        = 32                ' 16KB
    MULTI_64        = 64                ' 32KB
    TEST_SECTOR     = 200_000           ' Safe test sector (away from FAT/data area)

'' Enable full driver features for this utility
#PRAGMA EXPORTDEF SD_INCLUDE_ALL

OBJ
    sd    : "micro_sd_fat32_fs"

DAT

' Test filenames
testFile        BYTE    "PERFTEST.BIN", 0

' Large buffer for read/write tests (256KB)
testBuffer      BYTE    0[BUFFER_SIZE]

' Statistics arrays
timings         LONG    0[ITERATIONS]

' Card identification buffer
cid_buf         BYTE    0[16]

PUB go() | result, spi_hz
'' Main entry point - runs comprehensive SD card performance benchmark.

    debug(" ")
    debug("======================================================")
    debug("  SD Card Performance Benchmark v2.0")
    debug("======================================================")
    debug(" ")
    debug("SysClk: ", udec_(clkfreq / 1_000_000), " MHz")
    debug("Iterations per test: ", udec_(ITERATIONS))
    debug(" ")

    ' Mount the card first (for accurate cold-mount timing)
    result := runMountBenchmark()
    if result == false
        debug("ERROR: Could not mount SD card!")
        debug("END_SESSION")
        return

    ' Show SPI frequency and volume info
    spi_hz := sd.getSPIFrequency()
    debug("  SPI Frequency: ", udec_(spi_hz / 1000), " kHz")
    showVolumeInfo()

    ' Identify card AFTER mount (reads CID via worker cog)
    debug("------------------------------------------------------")
    debug("  CARD IDENTIFICATION")
    debug("------------------------------------------------------")
    result := identifyCard()
    if result == false
        debug("  WARNING: Could not read CID")
    debug(" ")

    ' === RAW SINGLE-SECTOR BENCHMARKS ===
    debug(" ")
    debug("------------------------------------------------------")
    debug("  RAW SINGLE-SECTOR (1x512B per operation)")
    debug("------------------------------------------------------")
    runSingleSectorBenchmarks()

    ' === RAW MULTI-SECTOR BENCHMARKS ===
    debug(" ")
    debug("------------------------------------------------------")
    debug("  RAW MULTI-SECTOR (CMD18/CMD25 bulk transfers)")
    debug("------------------------------------------------------")
    runMultiSectorBenchmarks()

    ' === FILE-LEVEL BENCHMARKS ===
    debug(" ")
    debug("------------------------------------------------------")
    debug("  FILE-LEVEL (handle API, includes FAT overhead)")
    debug("------------------------------------------------------")
    runFileLevelBenchmarks()

    ' Unmount with timing
    debug(" ")
    debug("------------------------------------------------------")
    debug("  OVERHEAD")
    debug("------------------------------------------------------")
    runFileOpenCloseBenchmark()
    runUnmountBenchmark()

    debug(" ")
    debug("======================================================")
    debug("  Benchmark Complete")
    debug("======================================================")
    debug("END_SESSION")


' ════════════════════════════════════════════════════════════════════════════════
' CARD IDENTIFICATION
' ════════════════════════════════════════════════════════════════════════════════

PRI identifyCard() : result | mid, pnm[2]
'' Identify card by reading CID (call after mount).
'' Displays MID, product name, and raw CID bytes.

    result := sd.readCIDRaw(@cid_buf)
    if result == false
        debug("  readCIDRaw FAILED")
        return false

    ' Extract MID and product name
    mid := cid_buf[0]
    bytemove(@pnm, @cid_buf + 3, 5)
    pnm.byte[5] := 0

    debug("  MID: ", uhex_byte_(mid), "  Product: ", zstr_(@pnm))
    debug("  CID: ", uhex_byte_(cid_buf[0]), " ", uhex_byte_(cid_buf[1]), " ", uhex_byte_(cid_buf[2]), " ", uhex_byte_(cid_buf[3]), " ", uhex_byte_(cid_buf[4]), " ", uhex_byte_(cid_buf[5]), " ", uhex_byte_(cid_buf[6]), " ", uhex_byte_(cid_buf[7]))
    debug("       ", uhex_byte_(cid_buf[8]), " ", uhex_byte_(cid_buf[9]), " ", uhex_byte_(cid_buf[10]), " ", uhex_byte_(cid_buf[11]), " ", uhex_byte_(cid_buf[12]), " ", uhex_byte_(cid_buf[13]), " ", uhex_byte_(cid_buf[14]), " ", uhex_byte_(cid_buf[15]))
    return true


' ════════════════════════════════════════════════════════════════════════════════
' MOUNT / UNMOUNT TIMING
' ════════════════════════════════════════════════════════════════════════════════

PRI runMountBenchmark() : result | start_ct, elapsed_ct, elapsed_us
'' Mount card and display timing.

    debug("MOUNT:")
    start_ct := getct()
    result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    elapsed_ct := getct() - start_ct

    elapsed_us := elapsed_ct / (clkfreq / 1_000_000)
    debug("  Mount time: ", udec_(elapsed_us / 1000), ".", udec_((elapsed_us // 1000) / 100), " ms")


PRI runUnmountBenchmark() | start_ct, elapsed_ct, elapsed_ms
'' Unmount card and display timing.

    debug(" ")
    debug("Unmount:")
    start_ct := getct()
    sd.unmount()
    elapsed_ct := getct() - start_ct

    elapsed_ms := elapsed_ct / (clkfreq / 1000)
    debug("  Unmount time: ", udec_(elapsed_ms), " ms")


PRI showVolumeInfo() | free_sectors, free_mb
'' Display mounted volume info.

    debug("  Volume: ", zstr_(sd.volumeLabel()))
    free_sectors := sd.freeSpace()
    free_mb := free_sectors / 2048
    debug("  Free: ", udec_(free_mb), " MB (", udec_(free_sectors), " sectors)")
    debug(" ")


' ════════════════════════════════════════════════════════════════════════════════
' RAW SINGLE-SECTOR BENCHMARKS
' ════════════════════════════════════════════════════════════════════════════════

PRI runSingleSectorBenchmarks()
'' Measure raw single-sector read and write performance.
'' Uses readSectorsRaw/writeSectorsRaw with count=1 to avoid debug print overhead.

    debug(" ")
    debug("Single-Sector Read (", udec_(ITERATIONS), " iterations):")
    runRawReadTest(1)

    debug(" ")
    debug("Single-Sector Write (", udec_(ITERATIONS), " iterations):")
    runRawWriteTest(1)


' ════════════════════════════════════════════════════════════════════════════════
' RAW MULTI-SECTOR BENCHMARKS
' ════════════════════════════════════════════════════════════════════════════════

PRI runMultiSectorBenchmarks()
'' Run all multi-sector read and write benchmarks at multiple sector counts.

    debug(" ")
    debug("Multi-Sector Read (CMD18):")
    runRawReadTest(MULTI_8)
    runRawReadTest(MULTI_32)
    runRawReadTest(MULTI_64)

    debug(" ")
    debug("Multi-Sector Write (CMD25):")
    runRawWriteTest(MULTI_8)
    runRawWriteTest(MULTI_32)
    runRawWriteTest(MULTI_64)

    debug(" ")
    debug("Single vs Multi Comparison (", udec_(MULTI_64), " sectors):")
    runComparisonTest(MULTI_64)


PRI runRawReadTest(count) | iter, start_ct, elapsed_ct, min_us, max_us, total_us, avg_us, kbps, size, readCt
'' Benchmark raw sector read at specified count.
'' Works for both single-sector (count=1) and multi-sector operations.

    size := count * SECTOR_SIZE

    ' Ensure test area has data
    fillBuffer(size, $A5)
    sd.writeSectorsRaw(TEST_SECTOR, count, @testBuffer)

    min_us := $7FFF_FFFF
    max_us := 0
    total_us := 0

    repeat iter from 0 to ITERATIONS - 1
        start_ct := getct()
        readCt := sd.readSectorsRaw(TEST_SECTOR, count, @testBuffer)
        elapsed_ct := getct() - start_ct

        if readCt == count
            timings[iter] := elapsed_ct / (clkfreq / 1_000_000)
            total_us += timings[iter]
            if timings[iter] < min_us
                min_us := timings[iter]
            if timings[iter] > max_us
                max_us := timings[iter]
        else
            debug("  ERROR: readSectorsRaw returned ", sdec_(readCt), " (expected ", udec_(count), ")")
            return

    avg_us := total_us / ITERATIONS

    if avg_us > 0
        kbps := (size * 1000) / avg_us
    else
        kbps := 0

    debug("  ", udec_(count), " sector(s) (", udec_(size), "B): Min=", udec_(min_us), " Avg=", udec_(avg_us), " Max=", udec_(max_us), " us => ", udec_(kbps), " KB/s")


PRI runRawWriteTest(count) | iter, start_ct, elapsed_ct, min_us, max_us, total_us, avg_us, kbps, size, written
'' Benchmark raw sector write at specified count.
'' Works for both single-sector (count=1) and multi-sector operations.

    size := count * SECTOR_SIZE
    fillBuffer(size, $5A)

    min_us := $7FFF_FFFF
    max_us := 0
    total_us := 0

    repeat iter from 0 to ITERATIONS - 1
        start_ct := getct()
        written := sd.writeSectorsRaw(TEST_SECTOR, count, @testBuffer)
        elapsed_ct := getct() - start_ct

        if written == count
            timings[iter] := elapsed_ct / (clkfreq / 1_000_000)
            total_us += timings[iter]
            if timings[iter] < min_us
                min_us := timings[iter]
            if timings[iter] > max_us
                max_us := timings[iter]
        else
            debug("  ERROR: writeSectorsRaw returned ", sdec_(written), " (expected ", udec_(count), ")")
            return

    avg_us := total_us / ITERATIONS

    if avg_us > 0
        kbps := (size * 1000) / avg_us
    else
        kbps := 0

    debug("  ", udec_(count), " sector(s) (", udec_(size), "B): Min=", udec_(min_us), " Avg=", udec_(avg_us), " Max=", udec_(max_us), " us => ", udec_(kbps), " KB/s")


PRI runComparisonTest(count) | i, start_ct, elapsed_ct, single_us, multi_us, size, improvement, readCt
'' Compare N individual single-sector reads vs one multi-sector read.

    size := count * SECTOR_SIZE

    ' Ensure test data exists
    fillBuffer(size, $CC)
    sd.writeSectorsRaw(TEST_SECTOR, count, @testBuffer)

    ' Time N individual single-sector reads
    start_ct := getct()
    repeat i from 0 to count - 1
        readCt := sd.readSectorsRaw(TEST_SECTOR + i, 1, @testBuffer + (i * SECTOR_SIZE))
    elapsed_ct := getct() - start_ct
    single_us := elapsed_ct / (clkfreq / 1_000_000)

    ' Time one multi-sector read
    start_ct := getct()
    readCt := sd.readSectorsRaw(TEST_SECTOR, count, @testBuffer)
    elapsed_ct := getct() - start_ct
    multi_us := elapsed_ct / (clkfreq / 1_000_000)

    if single_us > 0
        improvement := ((single_us - multi_us) * 100) / single_us
    else
        improvement := 0

    debug("  ", udec_(count), "x single-sector (CMD18x", udec_(count), "): ", udec_(single_us), " us")
    debug("  1x multi-sector  (CMD18x1):     ", udec_(multi_us), " us")
    debug("  Improvement: ", udec_(improvement), "%")


' ════════════════════════════════════════════════════════════════════════════════
' FILE-LEVEL BENCHMARKS (handle-based API)
' ════════════════════════════════════════════════════════════════════════════════

PRI runFileLevelBenchmarks()
'' Run all file-level benchmarks using handle-based API.
'' Timing includes open + transfer + close (the full user-visible cost).

    ' Clean up any leftover test file
    sd.deleteFile(@testFile)

    debug(" ")
    debug("File Write (create + write + close):")
    runFileWriteTest(SIZE_512B, string("512B"))
    runFileWriteTest(SIZE_4KB, string("4KB"))
    runFileWriteTest(SIZE_32KB, string("32KB"))

    debug(" ")
    debug("File Read (open + read + close):")
    runFileReadTest(SIZE_4KB, string("4KB"))
    runFileReadTest(SIZE_32KB, string("32KB"))
    runFileReadTest(SIZE_128KB, string("128KB"))
    runFileReadTest(SIZE_256KB, string("256KB"))

    ' Cleanup
    sd.deleteFile(@testFile)


PRI runFileWriteTest(size, p_label) | iter, handle, start_ct, elapsed_ct, min_us, max_us, total_us, avg_us, kbps, written
'' Benchmark file write: create + writeHandle + closeFileHandle.
'' Measures the full cycle an application would perform.

    fillBuffer(size, $5A)

    min_us := $7FFF_FFFF
    max_us := 0
    total_us := 0

    repeat iter from 0 to ITERATIONS - 1
        ' Delete previous iteration's file
        sd.deleteFile(@testFile)

        ' Time the full write cycle
        start_ct := getct()
        handle := sd.createFileNew(@testFile)
        if handle >= 0
            written := sd.writeHandle(handle, @testBuffer, size)
            sd.closeFileHandle(handle)
        elapsed_ct := getct() - start_ct

        if handle < 0
            debug("  ERROR: createFileNew failed (", sdec_(handle), ")")
            return

        timings[iter] := elapsed_ct / (clkfreq / 1_000_000)
        total_us += timings[iter]
        if timings[iter] < min_us
            min_us := timings[iter]
        if timings[iter] > max_us
            max_us := timings[iter]

    avg_us := total_us / ITERATIONS

    if avg_us > 0
        kbps := (size * 1000) / avg_us
    else
        kbps := 0

    debug("  ", zstr_(p_label), ": Min=", udec_(min_us), " Avg=", udec_(avg_us), " Max=", udec_(max_us), " us => ", udec_(kbps), " KB/s")


PRI runFileReadTest(size, p_label) | iter, handle, start_ct, elapsed_ct, min_us, max_us, total_us, avg_us, kbps, bytesRead
'' Benchmark file read: openFileRead + readHandle + closeFileHandle.
'' Creates a file of the target size first, then times repeated reads.

    ' Create test file of required size
    sd.deleteFile(@testFile)
    handle := sd.createFileNew(@testFile)
    if handle < 0
        debug("  ERROR: Could not create test file for read benchmark")
        return
    fillBuffer(size, $A5)
    sd.writeHandle(handle, @testBuffer, size)
    sd.closeFileHandle(handle)

    min_us := $7FFF_FFFF
    max_us := 0
    total_us := 0

    repeat iter from 0 to ITERATIONS - 1
        ' Time the full read cycle
        start_ct := getct()
        handle := sd.openFileRead(@testFile)
        if handle >= 0
            bytesRead := sd.readHandle(handle, @testBuffer, size)
            sd.closeFileHandle(handle)
        elapsed_ct := getct() - start_ct

        if handle < 0
            debug("  ERROR: openFileRead failed (", sdec_(handle), ")")
            return

        timings[iter] := elapsed_ct / (clkfreq / 1_000_000)
        total_us += timings[iter]
        if timings[iter] < min_us
            min_us := timings[iter]
        if timings[iter] > max_us
            max_us := timings[iter]

    avg_us := total_us / ITERATIONS

    if avg_us > 0
        kbps := (size * 1000) / avg_us
    else
        kbps := 0

    debug("  ", zstr_(p_label), ": Min=", udec_(min_us), " Avg=", udec_(avg_us), " Max=", udec_(max_us), " us => ", udec_(kbps), " KB/s")


' ════════════════════════════════════════════════════════════════════════════════
' FILE OPEN/CLOSE OVERHEAD
' ════════════════════════════════════════════════════════════════════════════════

PRI runFileOpenCloseBenchmark() | iter, handle, start_ct, elapsed_ct, open_min, open_max, open_total, close_min, close_max, close_total, open_avg, close_avg
'' Measure file open and close overhead independently.
'' Uses a small existing file to isolate open/close latency.

    ' Create a small test file
    sd.deleteFile(@testFile)
    handle := sd.createFileNew(@testFile)
    if handle >= 0
        fillBuffer(1024, $AA)
        sd.writeHandle(handle, @testBuffer, 1024)
        sd.closeFileHandle(handle)

    open_min := $7FFF_FFFF
    open_max := 0
    open_total := 0
    close_min := $7FFF_FFFF
    close_max := 0
    close_total := 0

    repeat iter from 0 to ITERATIONS - 1
        ' Measure open
        start_ct := getct()
        handle := sd.openFileRead(@testFile)
        elapsed_ct := getct() - start_ct
        timings[iter] := elapsed_ct / (clkfreq / 1_000_000)
        open_total += timings[iter]
        if timings[iter] < open_min
            open_min := timings[iter]
        if timings[iter] > open_max
            open_max := timings[iter]

        ' Measure close
        start_ct := getct()
        sd.closeFileHandle(handle)
        elapsed_ct := getct() - start_ct
        timings[iter] := elapsed_ct / (clkfreq / 1_000_000)
        close_total += timings[iter]
        if timings[iter] < close_min
            close_min := timings[iter]
        if timings[iter] > close_max
            close_max := timings[iter]

    open_avg := open_total / ITERATIONS
    close_avg := close_total / ITERATIONS

    debug(" ")
    debug("File Open/Close:")
    debug("  Open:  Min=", udec_(open_min), " Avg=", udec_(open_avg), " Max=", udec_(open_max), " us")
    debug("  Close: Min=", udec_(close_min), " Avg=", udec_(close_avg), " Max=", udec_(close_max), " us")

    ' Cleanup
    sd.deleteFile(@testFile)


' ════════════════════════════════════════════════════════════════════════════════
' UTILITY
' ════════════════════════════════════════════════════════════════════════════════

PRI fillBuffer(size, value)
'' Fill the test buffer with a byte value.
    bytefill(@testBuffer, value, size)


con { license }

{{
  =================================================================================================

  Terms of Use: MIT License

  Copyright (c) 2026 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  =================================================================================================
}}
