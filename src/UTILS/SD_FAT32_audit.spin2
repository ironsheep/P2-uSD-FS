'' =================================================================================================
''
''   File....... SD_FAT32_audit.spin2
''   Purpose.... Standalone FAT32 filesystem audit tool - verifies filesystem integrity
''   Author..... Stephen M Moraco
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... JAN 2026
''
'' =================================================================================================
''
''  This tool audits an SD card's FAT32 structure WITHOUT reformatting.
''  Use it to verify filesystem integrity after testing.
''
''  WHAT IT CHECKS:
''    - MBR structure and partition table
''    - VBR (Volume Boot Record) and backup
''    - FSInfo sector and backup
''    - FAT table consistency (FAT1 == FAT2)
''    - Root directory structure
''    - Basic mount/unmount capability
''
''  USAGE:
''    Run this tool after regression testing to verify the filesystem is intact.
''    It will NOT modify any data on the card.
''
'' =================================================================================================

CON

    _CLKFREQ        = 320_000_000

    ' Pin configuration for P2 Edge with SD card
    SD_CS   = 60
    SD_MOSI = 59
    SD_MISO = 58
    SD_SCK  = 61

    ' Expected FAT32 constants
    MBR_SIGNATURE       = $AA55
    PARTITION_TYPE_FAT32_LBA = $0C
    FSINFO_SIG1         = $41615252  ' "RRaA"
    FSINFO_SIG2         = $61417272  ' "rrAa"
    FSINFO_TRAIL_SIG    = $AA550000  ' Trail signature (stored little-endian)
    FAT32_MEDIA_TYPE    = $F8        ' Fixed disk
    EXT_BOOT_SIG        = $29        ' Extended boot signature

'' Enable full driver features for this utility
#PRAGMA EXPORTDEF SD_INCLUDE_ALL

OBJ

    sd    : "SD_card_driver"

VAR

    BYTE    buf[512]
    BYTE    buf2[512]
    LONG    sectorsPerFat
    LONG    totalSectors
    LONG    partitionStart
    LONG    passCount
    LONG    failCount
    LONG    testNumber

PUB go() | result, dataStart, fat1Start, fat2Start, idx, mismatch, cardSectors
'' Main entry point - runs FAT32 filesystem audit.
'' Verifies MBR, VBR, FSInfo, FAT tables, and root directory.

    passCount := 0
    failCount := 0
    testNumber := 0

    debug("==============================================")
    debug("  FAT32 Filesystem Audit Tool")
    debug("  (Read-only - does not modify card)")
    debug("==============================================")
    debug(" ")

    ' Initialize card for raw access
    debug("* Initializing card...")
    result := sd.initCardOnly(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    if result == false
        debug("ERROR: Cannot initialize card!")
        debug("END_SESSION")
        return

    cardSectors := sd.cardSizeSectors()
    debug("  Card size: ", udec(cardSectors), " sectors (", udec(cardSectors / 2048), " MB)")
    debug(" ")

    ' ========================================
    ' MBR VERIFICATION (Sector 0)
    ' ========================================
    debug("--- MBR Verification ---")

    sd.readSectorRaw(0, @buf)

    runTest(@"MBR boot signature ($AA55)", WORD[@buf + $1FE] == MBR_SIGNATURE)

    result := buf[$1BE]
    runTest(@"Partition 1 bootable flag ($00 or $80)", result == $00 OR result == $80)

    result := buf[$1C2]
    runTest(@"Partition 1 type ($0C = FAT32 LBA)", result == PARTITION_TYPE_FAT32_LBA)

    partitionStart := LONG[@buf + $1C6]
    runTest(@"Partition 1 start (typically 8192)", partitionStart > 0)
    debug("  Partition starts at sector ", udec(partitionStart))

    result := LONG[@buf + $1CA]
    runTest(@"Partition 1 size > 0", result > 0)
    debug("  Partition size: ", udec(result), " sectors")

    debug(" ")

    ' ========================================
    ' VBR VERIFICATION (Primary Boot Sector)
    ' ========================================
    debug("--- VBR Verification ---")

    sd.readSectorRaw(partitionStart, @buf)

    result := buf[0]
    runTest(@"VBR jump instruction ($EB or $E9)", result == $EB OR result == $E9)

    runTest(@"VBR boot signature ($AA55)", WORD[@buf + $1FE] == MBR_SIGNATURE)

    result := buf[$03]
    runTest(@"OEM name present (printable)", result >= $20 AND result <= $7E)
    debug("  OEM name: ", lstr_(@buf + $03, 8))

    result := WORD[@buf + $0B]
    runTest(@"Bytes per sector = 512", result == 512)

    result := buf[$0D]
    runTest(@"Sectors/cluster power of 2", result >= 1 AND result <= 128 AND (result & (result - 1)) == 0)
    debug("  Sectors per cluster: ", udec(result))

    result := WORD[@buf + $0E]
    runTest(@"Reserved sectors = 32", result == 32)

    result := buf[$10]
    runTest(@"Number of FATs = 2", result == 2)

    result := WORD[@buf + $11]
    runTest(@"Root entry count = 0 (FAT32)", result == 0)

    result := WORD[@buf + $13]
    runTest(@"Total sectors 16-bit = 0 (FAT32)", result == 0)

    result := buf[$15]
    runTest(@"Media type = $F8", result == FAT32_MEDIA_TYPE)

    result := WORD[@buf + $16]
    runTest(@"FAT size 16-bit = 0 (FAT32)", result == 0)

    result := LONG[@buf + $1C]
    runTest(@"Hidden sectors = partition start", result == partitionStart)

    totalSectors := LONG[@buf + $20]
    runTest(@"Total sectors 32-bit > 0", totalSectors > 0)
    debug("  Total sectors: ", udec(totalSectors))

    sectorsPerFat := LONG[@buf + $24]
    runTest(@"Sectors per FAT > 0", sectorsPerFat > 0)
    debug("  Sectors per FAT: ", udec(sectorsPerFat))

    result := LONG[@buf + $2C]
    runTest(@"Root cluster = 2", result == 2)

    result := WORD[@buf + $30]
    runTest(@"FSInfo at sector 1", result == 1)

    result := WORD[@buf + $32]
    runTest(@"Backup boot at sector 6", result == 6)

    result := buf[$42]
    runTest(@"Extended boot signature = $29", result == EXT_BOOT_SIG)

    result := true
    if buf[$52] <> "F" OR buf[$53] <> "A" OR buf[$54] <> "T" OR buf[$55] <> "3" OR buf[$56] <> "2"
        result := false
    runTest(@"FS type string = FAT32", result)
    debug("  FS Type: ", lstr_(@buf + $52, 8))
    debug("  Volume Label: ", lstr_(@buf + $47, 11))

    debug(" ")

    ' ========================================
    ' BACKUP VBR VERIFICATION
    ' ========================================
    debug("--- Backup VBR Verification ---")

    sd.readSectorRaw(partitionStart + 6, @buf2)

    ' Reload primary VBR for comparison
    sd.readSectorRaw(partitionStart, @buf)

    mismatch := false
    repeat idx from 0 to 511
        if buf[idx] <> buf2[idx]
            mismatch := true
            debug("  Mismatch at offset ", udec(idx), ": $", uhex_(buf[idx]), " vs $", uhex_(buf2[idx]))
            quit
    runTest(@"Backup VBR matches primary", mismatch == false)

    debug(" ")

    ' ========================================
    ' FSINFO VERIFICATION
    ' ========================================
    debug("--- FSInfo Verification ---")

    sd.readSectorRaw(partitionStart + 1, @buf)

    result := LONG[@buf + 0]
    runTest(@"FSInfo lead signature ($41615252)", result == FSINFO_SIG1)

    result := LONG[@buf + 484]
    runTest(@"FSInfo structure signature ($61417272)", result == FSINFO_SIG2)

    result := LONG[@buf + $1FC]
    runTest(@"FSInfo trail signature ($AA550000)", result == FSINFO_TRAIL_SIG)

    result := LONG[@buf + 488]
    runTest(@"Free cluster count set", result <> 0)
    debug("  Free clusters: ", udec(result))

    result := LONG[@buf + 492]
    runTest(@"Next free hint valid", result == $FFFFFFFF OR result >= 2)
    debug("  Next free hint: ", udec(result))

    ' Check backup FSInfo
    sd.readSectorRaw(partitionStart + 7, @buf2)
    sd.readSectorRaw(partitionStart + 1, @buf)  ' Reload primary

    mismatch := false
    repeat idx from 0 to 511
        if buf[idx] <> buf2[idx]
            mismatch := true
            quit
    runTest(@"Backup FSInfo matches primary", mismatch == false)

    debug(" ")

    ' ========================================
    ' FAT TABLE VERIFICATION
    ' ========================================
    debug("--- FAT Table Verification ---")

    fat1Start := partitionStart + 32
    fat2Start := fat1Start + sectorsPerFat

    sd.readSectorRaw(fat1Start, @buf)

    result := LONG[@buf + 0]
    runTest(@"FAT[0] = $0FFFFFF8 (media type)", result == $0FFFFFF8)

    result := LONG[@buf + 4]
    runTest(@"FAT[1] = $0FFFFFFF (EOC)", result == $0FFFFFFF)

    result := LONG[@buf + 8]
    runTest(@"FAT[2] = $0FFFFFFF (root EOC)", result == $0FFFFFFF)

    result := LONG[@buf + 12]
    runTest(@"FAT[3] = 0 (free)", result == 0)

    ' Compare FAT1 and FAT2 first sector
    sd.readSectorRaw(fat2Start, @buf2)

    mismatch := false
    repeat idx from 0 to 511
        if buf[idx] <> buf2[idx]
            mismatch := true
            debug("  FAT mismatch at offset ", udec(idx))
            quit
    runTest(@"FAT1 first sector == FAT2", mismatch == false)

    debug(" ")

    ' ========================================
    ' ROOT DIRECTORY VERIFICATION
    ' ========================================
    debug("--- Root Directory Verification ---")

    dataStart := partitionStart + 32 + 2 * sectorsPerFat
    debug("  Data region starts at sector ", udec(dataStart))

    sd.readSectorRaw(dataStart, @buf)

    result := buf[$0B]
    runTest(@"Volume label entry present (attr=$08)", result == $08)

    debug("  Volume label: ", lstr_(@buf, 11))

    result := buf[0]
    runTest(@"Valid volume label chars", result >= $20 AND result <= $7E)

    result := buf[$20]
    runTest(@"Second entry valid or end", result == $00 OR result == $E5 OR (result >= $20 AND result <= $7E))

    debug(" ")

    ' ========================================
    ' MOUNT TEST
    ' ========================================
    debug("--- Mount Test ---")

    result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    runTest(@"mount() succeeds", result)

    if result
        debug("  Mounted volume: ", zstr_(sd.volumeLabel()))

        result := sd.freeSpace()
        runTest(@"Free space > 0", result > 0)
        debug("  Free space: ", udec(result), " sectors")

        sd.unmount()
        debug("  Unmounted successfully")

    ' ========================================
    ' Summary
    ' ========================================
    debug(" ")
    debug("==============================================")
    debug("  AUDIT COMPLETE")
    debug("==============================================")
    debug("  Tests: ", udec(passCount + failCount))
    debug("  Pass:  ", udec(passCount))
    debug("  Fail:  ", udec(failCount))
    if failCount == 0
        debug(" ")
        debug("  FILESYSTEM INTEGRITY: OK")
    else
        debug(" ")
        debug("  FILESYSTEM INTEGRITY: ISSUES DETECTED")
    debug("==============================================")
    debug(" ")
    debug("END_SESSION")

PRI runTest(pTestName, passed)
' Run a single test and record pass/fail result.
'
' @param pTestName - Pointer to test name string
' @param passed - TRUE if test passed, FALSE if failed

    testNumber++
    if passed
        passCount++
        debug("  [PASS] ", zstr_(pTestName))
    else
        failCount++
        debug("  [FAIL] ", zstr_(pTestName))

CON { license }

{{
  =================================================================================================

  Terms of Use: MIT License

  Copyright (c) 2026 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  =================================================================================================
}}
