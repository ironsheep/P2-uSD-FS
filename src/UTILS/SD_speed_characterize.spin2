{
  SD Card SPI Speed Characterization Utility (Read-Only)
  ======================================================

  Tests SD card at various SPI clock speeds to find maximum reliable frequency.
  Uses CRC-16 verification to detect transmission errors.

  Test Strategy:
    Phase 1: 1,000 single-sector reads (quick check)
    Phase 2: If Phase 1 passes -> 10,000 single-sector reads (statistical confidence)
    Phase 3: If Phase 2 passes -> 100 x 8-sector reads (sustained transfer test)

  If any phase fails, testing stops for that speed and higher speeds are skipped.

  Timing Accuracy:
    Reports delta percentage from ideal frequency at each speed level.
    P2 SPI clock = SYSCLK / (2 * half_period), where half_period is integer.
    This shows how close we get to target vs actual achievable frequency.

  Author: Claude Code + Stephen M Moraco
  Date: 2026-02-02
  Target: P2 Edge with SD card breakout
}

CON
  _clkfreq  = 200_000_000                                       ' 200 MHz system clock

  ' SD Card Pin Assignments (P2 Edge microSD socket)
  CS_PIN    = 60
  MOSI_PIN  = 59
  MISO_PIN  = 58
  SCK_PIN   = 61

  ' Test Configuration
  TEST_SECTOR_BASE   = 1_000_000                                ' Safe area away from FAT
  TEST_SECTOR_RANGE  = 10_000                                   ' Randomize across 10K sectors
  PHASE1_ITERATIONS  = 1_000                                    ' Quick check iterations
  PHASE2_ITERATIONS  = 10_000                                   ' Statistical confidence iterations
  PHASE3_ITERATIONS  = 100                                      ' Multi-sector read iterations
  PHASE3_SECTORS     = 8                                        ' Sectors per multi-sector read

  ' Speed test levels (Hz)
  NUM_SPEED_LEVELS   = 11

'' Enable full driver features for this utility
#PRAGMA EXPORTDEF SD_INCLUDE_ALL

OBJ
  sd : "micro_sd_fat32_fs"

VAR
  ' Random number generator state
  long  rand_seed

  ' Test results per speed level
  long  speed_hz[NUM_SPEED_LEVELS]
  long  actual_hz[NUM_SPEED_LEVELS]
  long  delta_pct_x10[NUM_SPEED_LEVELS]                         ' Delta % x 10 for one decimal
  long  half_period[NUM_SPEED_LEVELS]
  long  phase1_ok[NUM_SPEED_LEVELS]
  long  phase1_crc_err[NUM_SPEED_LEVELS]
  long  phase1_timeout[NUM_SPEED_LEVELS]
  long  phase2_ok[NUM_SPEED_LEVELS]
  long  phase2_crc_err[NUM_SPEED_LEVELS]
  long  phase2_timeout[NUM_SPEED_LEVELS]
  long  phase3_ok[NUM_SPEED_LEVELS]
  long  phase3_crc_err[NUM_SPEED_LEVELS]
  long  phase3_timeout[NUM_SPEED_LEVELS]
  long  level_passed[NUM_SPEED_LEVELS]

  ' Card info
  long  card_capacity_mb
  long  cmd6_supported
  long  hs_mode_active

  ' Buffers
  byte  read_buf[512]
  byte  multi_buf[512 * 8]                                      ' For 8-sector reads

DAT
  ' Speed levels to test (Hz) - from 18 MHz to 50 MHz
  test_speeds   long  18_000_000
                long  20_000_000
                long  22_000_000
                long  25_000_000
                long  27_000_000
                long  30_000_000
                long  33_000_000
                long  36_000_000
                long  40_000_000
                long  45_000_000
                long  50_000_000

PUB main() | result, level, max_passed_level
'' Main entry point - runs SPI speed characterization tests.
'' Tests SD card at various SPI clock speeds to find maximum reliable frequency.

  debug("##############################################")
  debug("#  SPI Speed Characterization (Read-Only)   #")
  debug("##############################################")
  debug(" ")

  ' Initialize card at safe slow speed
  debug("Initializing SD card (no-mount mode)...")
  result := sd.initCardOnly(CS_PIN, MOSI_PIN, MISO_PIN, SCK_PIN)
  if not result
    debug("FATAL: Failed to initialize SD card!")
    debug("END_CHARACTERIZATION")
    repeat  ' Halt

  debug("Card initialized successfully.")
  debug(" ")

  ' Display card information
  displayCardInfo()

  ' Check CMD6 support for High Speed mode
  checkHighSpeedSupport()

  ' Initialize random seed
  rand_seed := $DEADBEEF

  ' Initialize speed array from DAT
  initSpeedArray()

  ' Calculate timing accuracy for all speeds
  calculateTimingAccuracy()

  ' Run speed tests
  debug(" ")
  debug("========================================")
  debug("  Starting Speed Characterization")
  debug("========================================")
  debug(" ")
  displayTestConfig()

  max_passed_level := -1

  ' Test each speed level
  repeat level from 0 to NUM_SPEED_LEVELS - 1
    if not testSpeedLevel(level)
      ' Failed - stop testing higher speeds
      debug(" ")
      debug("*** Stopping at ", udec_(speed_hz[level] / 1_000_000), " MHz ***")
      quit
    else
      max_passed_level := level

  ' Display summary
  displaySummary(max_passed_level)

  debug(" ")
  debug("END_CHARACTERIZATION")
  debug("##############################################")

  repeat  ' Halt

PRI initSpeedArray() | i
' Copy test speeds from DAT table to VAR array and initialize results.

  ' Copy speeds from DAT to VAR array
  repeat i from 0 to NUM_SPEED_LEVELS - 1
    speed_hz[i] := long[@test_speeds][i]
    level_passed[i] := false

PRI calculateTimingAccuracy() | i, target, hp, actual, delta
' Calculate half_period, actual frequency, and delta for each test speed.
' Shows timing accuracy achievable with P2 integer clock division.

  ' Calculate half_period, actual frequency, and delta for each speed
  ' This shows timing accuracy achievable with P2 integer clock division
  debug(" ")
  debug("Timing Accuracy Analysis (SYSCLK=", udec_(clkfreq/1_000_000), " MHz):")
  debug("------------------------------------------------")
  debug("| Target  | HalfPer | Actual  | Delta %  |")
  debug("|---------|---------|---------|----------|")

  repeat i from 0 to NUM_SPEED_LEVELS - 1
    target := speed_hz[i]

    ' Calculate half-period (same formula as driver)
    hp := (clkfreq + (target * 2) - 1) / (target * 2)
    if hp < 4
      hp := 4

    ' Calculate actual achievable frequency
    actual := clkfreq / (hp * 2)

    ' Calculate delta percentage x 10 (for one decimal place)
    ' delta = ((actual - target) / target) * 100
    ' delta_x10 = ((actual - target) * 1000) / target
    if target > 0
      delta := ((actual - target) * 1000) / target
    else
      delta := 0

    half_period[i] := hp
    actual_hz[i] := actual
    delta_pct_x10[i] := delta

    ' Display: target, half_period, actual, delta%
    debug("| ", udec_(target/1_000_000), " MHz  |   ", udec_(hp))
    debug("    | ", udec_(actual/1_000_000), ".", udec_((actual/100_000)//10), " MHz |")
    if delta >= 0
      debug("  +", udec_(delta/10), ".", udec_(delta//10 #> 0), "%   |")
    else
      delta := -delta
      debug("  -", udec_(delta/10), ".", udec_(delta//10 #> 0), "%   |")

  debug("------------------------------------------------")
  debug(" ")

PRI displayCardInfo() | cid[4], mid, sectors, cap_mb
' Display card information including manufacturer ID and capacity.

  debug("Card Information:")
  debug("------------------------------------------------")

  ' Read CID
  if sd.readCIDRaw(@cid)
    mid := cid.byte[0]
    debug("  Manufacturer ID: $", uhex_byte_(mid))
    debug("  Product: ", uhex_byte_(cid.byte[3]), " ")
    debug(uhex_byte_(cid.byte[4]), " ", uhex_byte_(cid.byte[5]))
    debug(" ", uhex_byte_(cid.byte[6]), " ", uhex_byte_(cid.byte[7]))
  else
    debug("  CID: Read failed")

  ' Get capacity from sectors (sectors * 512 bytes / 1MB)
  sectors := sd.cardSizeSectors()
  cap_mb := sectors / 2048                                         ' sectors / 2048 = MB
  card_capacity_mb := cap_mb
  debug("  Capacity: ~", udec_(cap_mb / 1024), " GB")
  debug("  Current SPI: ", udec_(sd.getSPIFrequency() / 1000), " kHz")
  debug(" ")

PRI checkHighSpeedSupport()
' Check if card supports CMD6 for High Speed mode switching.

  debug("High Speed Support:")
  debug("------------------------------------------------")

  cmd6_supported := sd.checkCMD6Support()
  if cmd6_supported
    debug("  CMD6: Supported (SD 2.0+)")
  else
    debug("  CMD6: Not supported")

  hs_mode_active := false
  debug(" ")

PRI displayTestConfig()
' Display test configuration parameters.

  debug("Test Configuration:")
  debug("  SYSCLK: ", udec_(clkfreq / 1_000_000), " MHz")
  debug("  Phase 1: ", udec_(PHASE1_ITERATIONS), " single-sector reads")
  debug("  Phase 2: ", udec_(PHASE2_ITERATIONS), " single-sector reads")
  debug("  Phase 3: ", udec_(PHASE3_ITERATIONS), " x ")
  debug(udec_(PHASE3_SECTORS), "-sector reads")
  debug("  Test sectors: ", udec_(TEST_SECTOR_BASE), " to ")
  debug(udec_(TEST_SECTOR_BASE + TEST_SECTOR_RANGE))
  debug(" ")

PRI testSpeedLevel(level) : passed | target_hz, ok, crc_err, timeout, delta
' Test a specific speed level through all three phases.
'
' @param level - Index into speed array
' @returns passed - TRUE if all phases passed, FALSE otherwise

  target_hz := speed_hz[level]

  debug("----------------------------------------")
  debug("Testing: ", udec_(target_hz / 1_000_000), " MHz")
  debug("----------------------------------------")

  ' Set SPI speed
  sd.setSPISpeed(target_hz)

  ' Display timing info
  delta := delta_pct_x10[level]
  debug("  Target: ", udec_(target_hz / 1_000_000), " MHz")
  debug("  Actual: ", udec_(actual_hz[level] / 1_000_000), ".")
  debug(udec_((actual_hz[level] / 100_000) // 10), " MHz")
  debug("  HalfPeriod: ", udec_(half_period[level]), " clocks")
  if delta >= 0
    debug("  Delta: +", udec_(delta/10), ".", udec_(delta//10), "%")
  else
    delta := -delta
    debug("  Delta: -", udec_(delta/10), ".", udec_(delta//10), "%")

  ' For speeds > 25 MHz, try High Speed mode
  if target_hz > 25_000_000 and cmd6_supported and not hs_mode_active
    debug("  Attempting CMD6 High Speed switch...")
    if sd.attemptHighSpeed()
      hs_mode_active := true
      debug("  High Speed: ACTIVE")
    else
      debug("  High Speed: Failed")

  ' Phase 1: Quick check
  debug(" ")
  debug("  Phase 1: ", udec_(PHASE1_ITERATIONS), " reads...")

  runSingleSectorTest(PHASE1_ITERATIONS, @ok, @crc_err, @timeout)

  phase1_ok[level] := ok
  phase1_crc_err[level] := crc_err
  phase1_timeout[level] := timeout

  debug("    OK=", udec_(ok), " CRC_Err=", udec_(crc_err))
  debug(" Timeout=", udec_(timeout))

  if crc_err > 0 or timeout > 0
    debug("  Phase 1: FAILED")
    level_passed[level] := false
    return false

  debug("  Phase 1: PASSED")

  ' Phase 2: Statistical confidence
  debug(" ")
  debug("  Phase 2: ", udec_(PHASE2_ITERATIONS), " reads...")

  runSingleSectorTest(PHASE2_ITERATIONS, @ok, @crc_err, @timeout)

  phase2_ok[level] := ok
  phase2_crc_err[level] := crc_err
  phase2_timeout[level] := timeout

  debug("    OK=", udec_(ok), " CRC_Err=", udec_(crc_err))
  debug(" Timeout=", udec_(timeout))

  if crc_err > 0 or timeout > 0
    debug("  Phase 2: FAILED")
    level_passed[level] := false
    return false

  debug("  Phase 2: PASSED")

  ' Phase 3: Multi-sector reads
  debug(" ")
  debug("  Phase 3: ", udec_(PHASE3_ITERATIONS), " x ")
  debug(udec_(PHASE3_SECTORS), "-sector reads...")

  runMultiSectorTest(PHASE3_ITERATIONS, PHASE3_SECTORS, @ok, @crc_err, @timeout)

  phase3_ok[level] := ok
  phase3_crc_err[level] := crc_err
  phase3_timeout[level] := timeout

  debug("    OK=", udec_(ok), " CRC_Err=", udec_(crc_err))
  debug(" Timeout=", udec_(timeout))

  if crc_err > 0 or timeout > 0
    debug("  Phase 3: FAILED")
    level_passed[level] := false
    return false

  debug("  Phase 3: PASSED")
  debug(" ")
  debug("  *** ", udec_(target_hz / 1_000_000), " MHz PASSED ***")

  level_passed[level] := true
  return true

PRI runSingleSectorTest(iterations, p_ok, p_crc_err, p_timeout) | i, sector, result, recv_crc, calc_crc
' Run single-sector read tests with CRC verification.
'
' @param iterations - Number of read iterations
' @param p_ok - Pointer to store successful read count
' @param p_crc_err - Pointer to store CRC error count
' @param p_timeout - Pointer to store timeout count

  long[p_ok] := 0
  long[p_crc_err] := 0
  long[p_timeout] := 0

  repeat i from 1 to iterations
    ' Get random sector within test range
    sector := getRandomTestSector()

    ' Read sector (returns true on success, false on failure)
    result := sd.readSectorRaw(sector, @read_buf)

    if result
      ' Read succeeded - check CRC match
      recv_crc := sd.getLastReceivedCRC()
      calc_crc := sd.getLastCalculatedCRC()
      if recv_crc == calc_crc
        long[p_ok]++
      else
        long[p_crc_err]++
        debug("      CRC mismatch sec ", udec_(sector))
    else
      ' Read failed - count as timeout
      long[p_timeout]++

    ' Progress every 2500
    if (i // 2500) == 0 and i > 0
      debug("      Progress: ", udec_(i))

PRI runMultiSectorTest(iterations, sectors_per_read, p_ok, p_crc_err, p_timeout) | i, start_sector, result
' Run multi-sector read tests (CMD18 bulk transfers).
'
' @param iterations - Number of multi-sector read iterations
' @param sectors_per_read - Number of sectors per read operation
' @param p_ok - Pointer to store successful sector count
' @param p_crc_err - Pointer to store CRC error count
' @param p_timeout - Pointer to store timeout count

  long[p_ok] := 0
  long[p_crc_err] := 0
  long[p_timeout] := 0

  repeat i from 1 to iterations
    ' Get random start sector
    start_sector := getRandomTestSector()
    if start_sector + sectors_per_read > TEST_SECTOR_BASE + TEST_SECTOR_RANGE
      start_sector := TEST_SECTOR_BASE

    ' Read multiple sectors (returns count of sectors read)
    result := sd.readSectorsRaw(start_sector, sectors_per_read, @multi_buf)

    if result == sectors_per_read
      long[p_ok] += sectors_per_read
    elseif result > 0
      long[p_ok] += result
      long[p_crc_err] += (sectors_per_read - result)
    else
      long[p_timeout] += sectors_per_read

PRI getRandomTestSector() : sector
' Generate a random sector number within the test range using LFSR.
'
' @returns sector - Random sector number within TEST_SECTOR_BASE..TEST_SECTOR_BASE+TEST_SECTOR_RANGE

  ' Simple LFSR-based pseudo-random for sector selection
  rand_seed := rand_seed << 1
  if rand_seed == 0
    rand_seed := $DEADBEEF
  if rand_seed & $8000_0000
    rand_seed ^= $04C1_1DB7                                        ' CRC-32 polynomial
  sector := TEST_SECTOR_BASE + (rand_seed +// TEST_SECTOR_RANGE)

PRI displaySummary(max_passed_level) | level
' Display test summary with recommended maximum speed.
'
' @param max_passed_level - Highest speed level that passed all tests

  debug(" ")
  debug("========================================")
  debug("  SPEED CHARACTERIZATION SUMMARY")
  debug("========================================")
  debug(" ")
  debug("SYSCLK: ", udec_(clkfreq / 1_000_000), " MHz")
  debug(" ")

  repeat level from 0 to NUM_SPEED_LEVELS - 1
    if phase1_ok[level] > 0 or phase1_crc_err[level] > 0
      debug(udec_(speed_hz[level] / 1_000_000), " MHz: ")
      if level_passed[level]
        debug("PASS (all phases)")
      else
        debug("FAIL")

  debug(" ")
  if max_passed_level >= 0
    debug("========================================")
    debug("  RECOMMENDED MAX: ", udec_(speed_hz[max_passed_level] / 1_000_000), " MHz")
    debug("  Actual: ", udec_(actual_hz[max_passed_level] / 1_000_000), ".")
    debug(udec_((actual_hz[max_passed_level]/100_000)//10), " MHz")
    debug("========================================")
  else
    debug("WARNING: No speeds passed!")
