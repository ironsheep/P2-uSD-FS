'' =================================================================================================
''
''   File....... SD_FAT32_fsck.spin2
''   Purpose.... FAT32 filesystem check and repair utility
''   Author..... Stephen M Moraco
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... FEB 2026
''   Updated.... 07 FEB 2026
''
'' =================================================================================================
''
''  Full filesystem check and repair (FSCK) for SD cards formatted as FAT32.
''  Detects and repairs filesystem corruption. Auto-repair mode (no prompts).
''
''  FOUR-PASS APPROACH:
''    Pass 1: Structural integrity - VBR/FSInfo backups, FAT signatures
''    Pass 2: Directory walk + chain validation - cross-links, loops, bad refs
''    Pass 3: Lost cluster recovery - free unreferenced allocated clusters
''    Pass 4: FAT sync + free count - FAT1->FAT2 sync, FSInfo update
''
''  MEMORY:
''    Cluster bitmap uses 256KB (LONG[65536]) covering up to 2,097,152 clusters.
''    Cards with more clusters get structural checks only (passes 1 and 4).
''
''  USAGE:
''    Flash this to P2 and run. It initializes the card for raw sector access
''    and performs all checks/repairs automatically. Results via debug output.
''
'' =================================================================================================

CON

    _CLKFREQ        = 320_000_000

    ' Pin configuration for P2 Edge with SD card
    SD_CS   = 60
    SD_MOSI = 59
    SD_MISO = 58
    SD_SCK  = 61

    ' FAT32 structure signatures
    MBR_SIGNATURE               = $AA55
    PARTITION_TYPE_FAT32_LBA    = $0C
    FSINFO_SIG1                 = $41615252      ' "RRaA"
    FSINFO_SIG2                 = $61417272      ' "rrAa"
    FSINFO_TRAIL_SIG            = $AA550000      ' Trail signature

    ' FAT entry constants
    FAT_MASK        = $0FFFFFFF     ' Lower 28 bits (cluster value)
    FAT_EOC_MIN     = $0FFFFFF8     ' Minimum end-of-chain marker
    FAT_EOC         = $0FFFFFFF     ' Standard EOC
    FAT_FREE        = $00000000     ' Free cluster
    FAT_BAD         = $0FFFFFF7     ' Bad cluster marker

    ' Bitmap capacity (256KB covers up to 2M clusters - sufficient for cards up to 64GB)
    BITMAP_LONGS        = 65536             ' 256KB
    MAX_BITMAP_CLUSTERS = BITMAP_LONGS * 32 ' 2,097,152 clusters

    ' Safety limits
    MAX_DIR_DEPTH       = 16
    MAX_CHAIN_LENGTH    = 2_000_000

'' Enable full driver features for this utility
#PRAGMA EXPORTDEF SD_INCLUDE_ALL

OBJ

    sd    : "micro_sd_fat32_fs"

VAR

    ' Sector buffers
    BYTE    buf[512]            ' General purpose / directory entries
    BYTE    buf2[512]           ' Comparison buffer
    BYTE    fatBuf[512]         ' FAT sector cache

    ' FAT cache state
    LONG    fatBufSector        ' Which FAT1 sector is cached (-1 = none)
    LONG    fatBufDirty         ' TRUE if fatBuf needs writing

    ' Filesystem geometry
    LONG    partitionStart
    LONG    sectorsPerFat
    LONG    sectorsPerCluster
    LONG    totalClusters
    LONG    totalSectors
    LONG    reservedSectors
    LONG    fat1Start
    LONG    fat2Start
    LONG    dataStart
    LONG    rootCluster

    ' Statistics
    LONG    repairCount
    LONG    errorCount
    LONG    warningCount
    LONG    dirCount
    LONG    fileCount
    LONG    scanDepth
    LONG    bitmapCapable       ' TRUE if card fits in bitmap

    ' Cluster bitmap (256KB)
    LONG    bitmapData[BITMAP_LONGS]

PUB go() | result, cardSectors
'' Main entry point - runs FAT32 filesystem check and repair.
'' Initializes card, reads geometry, then runs 4 repair passes.

    repairCount := 0
    errorCount := 0
    warningCount := 0
    dirCount := 0
    fileCount := 0
    scanDepth := 0
    fatBufSector := -1
    fatBufDirty := false

    debug("==============================================")
    debug("  FAT32 Filesystem Check & Repair (FSCK)")
    debug("==============================================")
    debug(" ")

    ' Initialize card for raw sector access
    debug("* Initializing card...")
    result := sd.initCardOnly(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    if result == false
        debug("FATAL: Cannot initialize card!")
        debug("END_SESSION")
        return

    cardSectors := sd.cardSizeSectors()
    debug("  Card: ", udec(cardSectors), " sectors (", udec(cardSectors / 2048), " MB)")
    debug(" ")

    ' Read filesystem geometry from MBR and VBR
    if not readGeometry()
        debug("FATAL: Cannot read filesystem geometry!")
        debug("END_SESSION")
        return

    ' Determine if bitmap can cover the whole card
    bitmapCapable := (totalClusters <= MAX_BITMAP_CLUSTERS)
    if not bitmapCapable
        debug("NOTE: Card has ", udec(totalClusters), " clusters")
        debug("  Bitmap max: ", udec(MAX_BITMAP_CLUSTERS))
        debug("  Deep scan (passes 2-3) will be skipped")
        warningCount++
    debug(" ")

    ' Pass 1: Structural integrity checks and repairs
    pass1_Structural()

    ' Pass 2: Directory walk + chain validation (requires bitmap)
    if bitmapCapable
        pass2_DirectoryChains()

    ' Pass 3: Lost cluster recovery (requires bitmap)
    if bitmapCapable
        pass3_LostClusters()

    ' Pass 4: FAT1->FAT2 sync and free cluster count
    pass4_SyncAndCount()

    ' Final summary
    showSummary()

    debug("END_SESSION")

PRI readGeometry() : ok | numFats
' Read MBR and VBR to extract filesystem geometry.
' Populates all geometry VARs needed by subsequent passes.
'
' @returns ok - TRUE if geometry read successfully

    ' Read MBR to get partition start
    sd.readSectorRaw(0, @buf)
    if WORD[@buf + $1FE] <> MBR_SIGNATURE
        debug("  ERROR: Invalid MBR signature")
        return false

    partitionStart := LONG[@buf + $1C6]
    if partitionStart == 0
        debug("  ERROR: Partition start is 0")
        return false

    ' Read VBR (Volume Boot Record)
    sd.readSectorRaw(partitionStart, @buf)
    if WORD[@buf + $1FE] <> MBR_SIGNATURE
        debug("  ERROR: Invalid VBR signature")
        return false

    ' Extract geometry fields
    sectorsPerCluster := buf[$0D]
    reservedSectors := WORD[@buf + $0E]
    numFats := buf[$10]
    sectorsPerFat := LONG[@buf + $24]
    totalSectors := LONG[@buf + $20]
    rootCluster := LONG[@buf + $2C]

    ' Validate critical fields
    if sectorsPerCluster == 0 OR sectorsPerFat == 0 OR totalSectors == 0
        debug("  ERROR: Zero in critical VBR field")
        return false

    if numFats < 1 OR numFats > 2
        debug("  ERROR: Invalid number of FATs: ", udec(numFats))
        return false

    ' Compute derived values
    fat1Start := partitionStart + reservedSectors
    fat2Start := fat1Start + sectorsPerFat
    dataStart := fat1Start + (numFats * sectorsPerFat)
    totalClusters := (totalSectors - reservedSectors - (numFats * sectorsPerFat)) / sectorsPerCluster

    debug("  Geometry:")
    debug("    Partition start:  ", udec(partitionStart))
    debug("    Sectors/cluster:  ", udec(sectorsPerCluster))
    debug("    Reserved sectors: ", udec(reservedSectors))
    debug("    Sectors/FAT:      ", udec(sectorsPerFat))
    debug("    Total clusters:   ", udec(totalClusters))
    debug("    Root cluster:     ", udec(rootCluster))
    debug("    FAT1 start:       ", udec(fat1Start))
    debug("    FAT2 start:       ", udec(fat2Start))
    debug("    Data start:       ", udec(dataStart))

    ok := true

PRI pass1_Structural() | idx, mismatch, fsinfoDirty, startRepairs
' Pass 1: Check and repair structural elements.
' Verifies VBR backup, FSInfo signatures and backup, FAT[0] and FAT[1].

    debug("--- Pass 1: Structural Integrity ---")
    startRepairs := repairCount

    ' === VBR backup (sector 6) ===
    sd.readSectorRaw(partitionStart, @buf)
    sd.readSectorRaw(partitionStart + 6, @buf2)

    mismatch := false
    repeat idx from 0 to 511
        if buf[idx] <> buf2[idx]
            mismatch := true
            quit

    if mismatch
        debug("  REPAIR: Backup VBR does not match primary - copying")
        sd.writeSectorRaw(partitionStart + 6, @buf)
        repairCount++
    else
        debug("  [OK] Backup VBR matches primary")

    ' === FSInfo signatures (sector 1) ===
    sd.readSectorRaw(partitionStart + 1, @buf)
    fsinfoDirty := false

    if LONG[@buf] <> FSINFO_SIG1
        debug("  REPAIR: FSInfo lead signature bad - fixing")
        LONG[@buf] := FSINFO_SIG1
        fsinfoDirty := true
        repairCount++

    if LONG[@buf + 484] <> FSINFO_SIG2
        debug("  REPAIR: FSInfo struct signature bad - fixing")
        LONG[@buf + 484] := FSINFO_SIG2
        fsinfoDirty := true
        repairCount++

    if LONG[@buf + $1FC] <> FSINFO_TRAIL_SIG
        debug("  REPAIR: FSInfo trail signature bad - fixing")
        LONG[@buf + $1FC] := FSINFO_TRAIL_SIG
        fsinfoDirty := true
        repairCount++

    if fsinfoDirty
        sd.writeSectorRaw(partitionStart + 1, @buf)
    else
        debug("  [OK] FSInfo signatures correct")

    ' === FSInfo backup (sector 7) ===
    sd.readSectorRaw(partitionStart + 1, @buf)
    sd.readSectorRaw(partitionStart + 7, @buf2)

    mismatch := false
    repeat idx from 0 to 511
        if buf[idx] <> buf2[idx]
            mismatch := true
            quit

    if mismatch
        debug("  REPAIR: Backup FSInfo does not match primary - copying")
        sd.writeSectorRaw(partitionStart + 7, @buf)
        repairCount++
    else
        debug("  [OK] Backup FSInfo matches primary")

    ' === FAT[0] media type ===
    sd.readSectorRaw(fat1Start, @buf)

    if (LONG[@buf] & FAT_MASK) <> ($0FFFFFF8 & FAT_MASK)
        debug("  REPAIR: FAT[0] media type bad - fixing")
        LONG[@buf] := $0FFFFFF8 | (LONG[@buf] & $F0000000)
        sd.writeSectorRaw(fat1Start, @buf)
        repairCount++
    else
        debug("  [OK] FAT[0] media type correct")

    ' === FAT[1] EOC marker ===
    if (LONG[@buf + 4] & FAT_MASK) <> FAT_EOC
        debug("  REPAIR: FAT[1] EOC marker bad - fixing")
        LONG[@buf + 4] := FAT_EOC | (LONG[@buf + 4] & $F0000000)
        sd.writeSectorRaw(fat1Start, @buf)
        repairCount++
    else
        debug("  [OK] FAT[1] EOC marker correct")

    ' === FAT[2] root cluster (must not be free) ===
    if (LONG[@buf + 8] & FAT_MASK) == FAT_FREE
        debug("  REPAIR: FAT[2] root cluster was free - setting EOC")
        LONG[@buf + 8] := FAT_EOC | (LONG[@buf + 8] & $F0000000)
        sd.writeSectorRaw(fat1Start, @buf)
        repairCount++
    else
        debug("  [OK] FAT[2] root cluster allocated")

    debug("  Pass 1: ", udec(repairCount - startRepairs), " repairs")
    debug(" ")

PRI pass2_DirectoryChains() | startRepairs
' Pass 2: Walk directory tree and validate all cluster chains.
' Builds a bitmap of referenced clusters to detect cross-links.

    debug("--- Pass 2: Directory & Chain Validation ---")
    startRepairs := repairCount

    ' Clear cluster bitmap
    longfill(@bitmapData, 0, BITMAP_LONGS)

    ' Mark clusters 0 and 1 as used (they don't exist as data clusters)
    setBit(0)
    setBit(1)

    ' Validate and mark root directory's own cluster chain in bitmap
    ' (subdirectory chains are marked by validateChain calls inside scanDirectory)
    validateChain(rootCluster, 0, true)

    ' Scan root directory tree
    dirCount := 0
    fileCount := 0
    scanDepth := 0
    scanDirectory(rootCluster)

    debug("  Directories scanned: ", udec(dirCount))
    debug("  Files scanned:       ", udec(fileCount))
    debug("  Pass 2: ", udec(repairCount - startRepairs), " repairs")
    debug(" ")

PRI scanDirectory(dirCluster) | sector, entSector, entIdx, pEntry, attr, startClus, fSize, name0, nextClus
' Recursively scan a directory's cluster chain, validating all entries.
' For each file/subdir found, validates its cluster chain.
' Re-reads parent sector after returning from subdirectory recursion.
'
' @param dirCluster - First cluster of the directory to scan

    dirCount++
    scanDepth++

    if scanDepth > MAX_DIR_DEPTH
        debug("  WARNING: Max directory depth exceeded")
        warningCount++
        scanDepth--
        return

    ' Follow the directory's cluster chain
    repeat while dirCluster >= 2 AND dirCluster < (totalClusters + 2)
        sector := clus2sec(dirCluster)

        ' Read each sector in this cluster
        repeat entSector from 0 to sectorsPerCluster - 1
            sd.readSectorRaw(sector + entSector, @buf)

            ' Process 16 directory entries per sector
            repeat entIdx from 0 to 15
                pEntry := @buf + (entIdx * 32)
                name0 := BYTE[pEntry]

                ' $00 = end of directory
                if name0 == $00
                    scanDepth--
                    return

                ' $E5 = deleted entry, skip
                if name0 == $E5
                    next

                attr := BYTE[pEntry + $0B]

                ' Long filename entry (attr $0F), skip
                if (attr & $3F) == $0F
                    next

                ' Volume label, skip
                if attr & $08
                    next

                ' Skip . and .. entries
                if isDot(pEntry)
                    next

                ' Extract start cluster and file size
                startClus := WORD[pEntry + $1A] | (WORD[pEntry + $14] << 16)
                fSize := LONG[pEntry + $1C]

                if attr & $10
                    ' --- Subdirectory ---
                    if startClus >= 2 AND startClus < (totalClusters + 2)
                        validateChain(startClus, 0, true)
                        scanDirectory(startClus)
                        ' Re-read our sector after recursion
                        sd.readSectorRaw(sector + entSector, @buf)
                    elseif startClus <> 0
                        debug("  ERROR: Bad dir start cluster ", udec(startClus))
                        errorCount++
                else
                    ' --- Regular file ---
                    fileCount++
                    if startClus >= 2 AND startClus < (totalClusters + 2)
                        validateChain(startClus, fSize, false)
                    elseif startClus == 0 AND fSize > 0
                        debug("  ERROR: File has size ", udec(fSize), " but no cluster")
                        errorCount++
                    ' startClus == 0, fSize == 0: valid empty file

        ' Advance to next cluster in directory chain
        nextClus := readFAT(dirCluster) & FAT_MASK
        if nextClus >= FAT_EOC_MIN
            quit
        if nextClus < 2 OR nextClus >= (totalClusters + 2)
            debug("  ERROR: Bad cluster in directory chain: ", udec(nextClus))
            errorCount++
            quit
        dirCluster := nextClus

    scanDepth--

PRI validateChain(startClus, fSize, isDir) | clus, nextClus, chainLen, expectedLen
' Follow a cluster chain and validate integrity.
' Marks each visited cluster in the bitmap to detect cross-links.
' Truncates chains at bad cluster references.
'
' @param startClus - First cluster of the chain
' @param fSize - Expected file size (0 for directories)
' @param isDir - TRUE if this chain belongs to a directory

    chainLen := 0
    clus := startClus

    repeat while clus >= 2 AND clus < (totalClusters + 2)
        ' Check for cross-link (cluster already referenced by another chain)
        if testBit(clus)
            debug("  ERROR: Cross-linked cluster ", udec(clus))
            errorCount++
            return

        ' Mark cluster as referenced
        setBit(clus)
        chainLen++

        ' Safety: detect infinite loops
        if chainLen > MAX_CHAIN_LENGTH
            debug("  ERROR: Chain too long (loop?) from cluster ", udec(startClus))
            errorCount++
            return

        ' Read next cluster in chain
        nextClus := readFAT(clus) & FAT_MASK

        ' End of chain?
        if nextClus >= FAT_EOC_MIN
            quit

        ' Bad cluster reference?
        if nextClus < 2 OR (nextClus >= (totalClusters + 2) AND nextClus <> FAT_BAD)
            debug("  ERROR: Bad ref ", udec(nextClus), " in chain from ", udec(startClus))
            ' Truncate chain here by writing EOC
            writeFAT(clus, FAT_EOC)
            debug("  REPAIR: Truncated chain at cluster ", udec(clus))
            repairCount++
            quit

        ' Bad cluster marker - skip but continue
        if nextClus == FAT_BAD
            quit

        clus := nextClus

    ' For files, check chain length vs expected
    if not isDir AND fSize > 0
        expectedLen := (fSize + (sectorsPerCluster * 512) - 1) / (sectorsPerCluster * 512)
        if chainLen <> expectedLen
            debug("  WARNING: Chain ", udec(chainLen), " clusters, expected ", udec(expectedLen))
            warningCount++

PRI pass3_LostClusters() | clus, fatVal, lostCount, startRepairs
' Pass 3: Find and free lost clusters.
' A "lost" cluster is allocated in the FAT but not referenced by any directory entry.
' These are freed to reclaim space.

    debug("--- Pass 3: Lost Cluster Recovery ---")
    startRepairs := repairCount
    lostCount := 0

    repeat clus from 2 to totalClusters + 1
        ' Stay within bitmap range
        if clus >= MAX_BITMAP_CLUSTERS
            quit

        ' If not in bitmap, it was not referenced by any file/dir
        if not testBit(clus)
            fatVal := readFAT(clus) & FAT_MASK
            if fatVal <> FAT_FREE AND fatVal <> FAT_BAD
                ' Cluster is allocated but unreferenced - free it
                writeFAT(clus, FAT_FREE)
                lostCount++

    ' Flush any pending FAT writes
    flushFAT()

    if lostCount > 0
        debug("  REPAIR: Freed ", udec(lostCount), " lost clusters")
        repairCount += lostCount
    else
        debug("  [OK] No lost clusters found")

    debug("  Pass 3: ", udec(repairCount - startRepairs), " repairs")
    debug(" ")

PRI pass4_SyncAndCount() | fatSector, entIdx, clus, fatVal, freeCount, syncCount, mismatch, idx, startRepairs
' Pass 4: Synchronize FAT1 -> FAT2 and correct the free cluster count.
' Reads each FAT1 sector, counts free entries, compares with FAT2, syncs if different.
' Updates FSInfo free cluster count and backup.

    debug("--- Pass 4: FAT Sync & Free Count ---")
    startRepairs := repairCount

    ' Ensure all prior FAT writes are flushed
    flushFAT()

    freeCount := 0
    syncCount := 0
    clus := 0

    repeat fatSector from 0 to sectorsPerFat - 1
        ' Read FAT1 sector
        sd.readSectorRaw(fat1Start + fatSector, @buf)

        ' Count free clusters in this sector
        repeat entIdx from 0 to 127
            if clus >= 2 AND clus < (totalClusters + 2)
                fatVal := LONG[@buf + (entIdx * 4)] & FAT_MASK
                if fatVal == FAT_FREE
                    freeCount++
            clus++

        ' Read FAT2 sector and compare
        sd.readSectorRaw(fat2Start + fatSector, @buf2)

        mismatch := false
        repeat idx from 0 to 511
            if buf[idx] <> buf2[idx]
                mismatch := true
                quit

        if mismatch
            ' Copy FAT1 to FAT2
            sd.writeSectorRaw(fat2Start + fatSector, @buf)
            syncCount++

    if syncCount > 0
        debug("  REPAIR: Synced ", udec(syncCount), " FAT sectors (FAT1 -> FAT2)")
        repairCount += syncCount
    else
        debug("  [OK] FAT1 and FAT2 in sync")

    debug("  Free clusters: ", udec(freeCount))

    ' Update FSInfo free cluster count
    sd.readSectorRaw(partitionStart + 1, @buf)

    if LONG[@buf + 488] <> freeCount
        debug("  REPAIR: FSInfo free count ", udec(LONG[@buf + 488]), " -> ", udec(freeCount))
        LONG[@buf + 488] := freeCount
        sd.writeSectorRaw(partitionStart + 1, @buf)
        ' Update backup FSInfo too
        sd.writeSectorRaw(partitionStart + 7, @buf)
        repairCount++
    else
        debug("  [OK] FSInfo free count correct")

    debug("  Pass 4: ", udec(repairCount - startRepairs), " repairs")
    debug(" ")

PRI showSummary()
' Display final results summary.

    debug("==============================================")
    debug("  FSCK COMPLETE")
    debug("==============================================")
    debug("  Errors found:  ", udec(errorCount))
    debug("  Repairs made:  ", udec(repairCount))
    debug("  Warnings:      ", udec(warningCount))
    if bitmapCapable
        debug("  Directories:   ", udec(dirCount))
        debug("  Files:         ", udec(fileCount))
    if errorCount == 0 AND repairCount == 0
        debug(" ")
        debug("  FILESYSTEM STATUS: CLEAN")
    elseif errorCount == 0
        debug(" ")
        debug("  FILESYSTEM STATUS: REPAIRED")
    else
        debug(" ")
        debug("  FILESYSTEM STATUS: ERRORS REMAIN")
    debug("==============================================")
    debug(" ")

PRI readFAT(cluster) : value | sector, offset
' Read a FAT entry with sector caching.
' Caches one FAT sector at a time for efficient sequential access.
'
' @param cluster - Cluster number to read
' @returns value - Raw 32-bit FAT entry (caller must mask with FAT_MASK)

    sector := fat1Start + (cluster >> 7)
    offset := (cluster & $7F) * 4

    if sector <> fatBufSector
        flushFAT()
        sd.readSectorRaw(sector, @fatBuf)
        fatBufSector := sector

    value := LONG[@fatBuf + offset]

PRI writeFAT(cluster, value) | sector, offset, existing
' Write a FAT entry with sector caching. Preserves upper 4 reserved bits.
' Marks the cache as dirty; actual write happens on flushFAT().
'
' @param cluster - Cluster number to write
' @param value - New FAT entry value (only lower 28 bits used)

    sector := fat1Start + (cluster >> 7)
    offset := (cluster & $7F) * 4

    if sector <> fatBufSector
        flushFAT()
        sd.readSectorRaw(sector, @fatBuf)
        fatBufSector := sector

    ' Preserve upper 4 bits of existing entry
    existing := LONG[@fatBuf + offset]
    LONG[@fatBuf + offset] := (value & FAT_MASK) | (existing & $F0000000)
    fatBufDirty := true

PRI flushFAT()
' Write cached FAT sector to disk (both FAT1 and FAT2) if dirty.

    if fatBufDirty AND fatBufSector >= 0
        sd.writeSectorRaw(fatBufSector, @fatBuf)
        sd.writeSectorRaw(fatBufSector - fat1Start + fat2Start, @fatBuf)
        fatBufDirty := false

PRI clus2sec(cluster) : sector
' Convert cluster number to absolute sector number.
'
' @param cluster - Cluster number (2-based)
' @returns sector - Absolute LBA sector number

    sector := dataStart + ((cluster - 2) * sectorsPerCluster)

PRI setBit(cluster)
' Set a bit in the cluster bitmap, marking the cluster as referenced.
'
' @param cluster - Cluster number to mark

    bitmapData[cluster >> 5] |= (1 << (cluster & $1F))

PRI testBit(cluster) : result
' Test whether a cluster is marked in the bitmap.
'
' @param cluster - Cluster number to test
' @returns result - TRUE if cluster is marked, FALSE otherwise

    result := (bitmapData[cluster >> 5] >> (cluster & $1F)) & 1

PRI isDot(pEntry) : result
' Check if a directory entry is the "." or ".." special entry.
'
' @param pEntry - Pointer to 32-byte directory entry
' @returns result - TRUE if entry is . or ..

    result := false
    if BYTE[pEntry] == "."
        if BYTE[pEntry + 1] == " " OR BYTE[pEntry + 1] == "."
            result := true

CON { license }

{{
  =================================================================================================

  Terms of Use: MIT License

  Copyright (c) 2026 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  =================================================================================================
}}
