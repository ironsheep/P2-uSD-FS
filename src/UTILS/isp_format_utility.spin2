'' =================================================================================================
''
''   File....... isp_format_utility.spin2
''   Purpose.... FAT32 format utility for SD cards using the SD_card_driver
''   Author..... Stephen M Moraco
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... JAN 2026
''   Updated.... 16 JAN 2026
''
'' =================================================================================================
''
''  This utility formats an SD card with a FAT32 filesystem.
''
''  USAGE:
''    fmt.format(cs, mosi, miso, sck)                    ' Format with default label "P2-XFER"
''    fmt.formatWithLabel(cs, mosi, miso, sck, @"MYCARD")  ' Format with custom label (max 11 chars)
''
''  WARNING: This will ERASE ALL DATA on the card!
''
'' =================================================================================================

CON

    DEBUG_DISABLE = 0   ' Enable debug output

    ' FAT32 constants
    BYTES_PER_SECTOR    = 512
    RESERVED_SECTORS    = 32        ' Standard for FAT32
    NUM_FATS            = 2         ' Always 2 for FAT32 compliance
    ROOT_CLUSTER        = 2         ' Root directory starts at cluster 2

    ' MBR constants
    MBR_SIGNATURE       = $AA55
    PARTITION_TYPE_FAT32_LBA = $0C  ' FAT32 with LBA

    ' FAT32 special values
    FAT32_EOC           = $0FFFFFFF ' End of chain marker
    FAT32_MEDIA_TYPE    = $0FFFFFF8 ' Media descriptor in FAT[0]

    ' Multi-sector write batch size for initFAT/initRootDirectory
    MULTI_BATCH_SIZE    = 64        ' Sectors per CMD25 batch (32 KB)

    ' FSInfo signatures
    FSINFO_SIG1         = $41615252 ' "RRaA"
    FSINFO_SIG2         = $61417272 ' "rrAa"
    FSINFO_SIG3         = $AA550000

    ' Volume label (11 chars, space padded) - "P2-XFER    "
    DEFAULT_LABEL_0     = $58_2D_32_50  ' "P2-X" (little endian: P, 2, -, X)
    DEFAULT_LABEL_1     = $20_52_45_46  ' "FER " (little endian: F, E, R, space)
    DEFAULT_LABEL_2     = $00_20_20_20  ' "   " + null (spaces to pad to 11)

'' Enable full driver features for this utility
#PRAGMA EXPORTDEF SD_INCLUDE_ALL

OBJ

    sd : "SD_card_driver"                ' Use V3 driver with smart pins for formatting

VAR

    ' Pin configuration
    LONG    pinCS, pinMOSI, pinMISO, pinSCK

    ' Sector buffer
    BYTE    buf[BYTES_PER_SECTOR]
    BYTE    verifyBuf[BYTES_PER_SECTOR]
    BYTE    zeroBuf[MULTI_BATCH_SIZE * BYTES_PER_SECTOR]  ' 32 KB zero buffer for CMD25 batches

    ' Card geometry
    LONG    totalSectors
    LONG    sectorsPerCluster
    LONG    sectorsPerFat
    LONG    dataSectors
    LONG    totalClusters
    LONG    partitionStart      ' LBA of partition start (VBR)
    LONG    fat1Start           ' LBA of first FAT
    LONG    fat2Start           ' LBA of second FAT
    LONG    dataStart           ' LBA of data area

    ' Volume label (12 bytes: 11 chars + null)
    BYTE    volumeLabel[12]

PUB format(cs, mosi, miso, sck) : result
'' Format the SD card with default volume label "P2-XFER".
''
'' @param cs - Chip Select pin number
'' @param mosi - Master Out Slave In pin number
'' @param miso - Master In Slave Out pin number
'' @param sck - Serial Clock pin number
'' @returns result - TRUE if successful, FALSE if failed

    pinCS := cs
    pinMOSI := mosi
    pinMISO := miso
    pinSCK := sck
    setDefaultLabel()
    result := doFormat()

PUB formatWithLabel(cs, mosi, miso, sck, pLabel) : result | i, ch
'' Format the SD card with a custom volume label.
''
'' @param cs - Chip Select pin number
'' @param mosi - Master Out Slave In pin number
'' @param miso - Master In Slave Out pin number
'' @param sck - Serial Clock pin number
'' @param pLabel - Pointer to null-terminated string (max 11 chars)
'' @returns result - TRUE if successful, FALSE if failed

    pinCS := cs
    pinMOSI := mosi
    pinMISO := miso
    pinSCK := sck

    ' Copy and pad label to 11 characters
    bytefill(@volumeLabel, " ", 11)
    volumeLabel[11] := 0

    i := 0
    repeat while i < 11
        ch := BYTE[pLabel][i]
        if ch == 0
            quit
        ' Convert to uppercase for FAT compatibility
        if ch >= "a" and ch <= "z"
            ch -= 32
        volumeLabel[i] := ch
        i++

    result := doFormat()

PUB stop()
'' Stop the driver worker cog and release SPI pins.
'' Call this after format() or formatWithLabel() to allow other drivers to use the card.

    sd.stop()

PRI setDefaultLabel()
' Set default volume label "P2-XFER" (11 chars, space padded).

    ' Set default label "P2-XFER    " (11 chars, space padded)
    LONG[@volumeLabel][0] := DEFAULT_LABEL_0
    LONG[@volumeLabel][1] := DEFAULT_LABEL_1
    BYTE[@volumeLabel][8] := " "
    BYTE[@volumeLabel][9] := " "
    BYTE[@volumeLabel][10] := " "
    volumeLabel[11] := 0

PRI doFormat() : result | i
' Execute the format operation: MBR, VBR, FSInfo, FAT tables, root directory.
'
' @returns result - TRUE if all steps succeeded, FALSE otherwise

    debug("==============================================")
    debug("  SD Card FAT32 Formatter")
    debug("  Volume Label: [", zstr_(@volumeLabel), "]")
    debug("==============================================")
    debug(" ")

    ' Initialize card (low-level, no filesystem mount)
    debug("* Initializing SD card...")
    result := sd.initCardOnly(pinCS, pinMOSI, pinMISO, pinSCK)
    if result == false
        debug("ERROR: Could not initialize SD card!")
        return false

    ' Get card size
    debug("* Reading card size...")
    totalSectors := sd.cardSizeSectors()
    if totalSectors == 0
        debug("ERROR: Could not read card size!")
        return false

    debug("  Total sectors: ", udec_(totalSectors))
    debug("  Card size: ", udec_(totalSectors / 2048), " MB")

    ' Calculate filesystem parameters
    debug("* Calculating filesystem parameters...")
    if not calculateParameters()
        debug("ERROR: Card too small for FAT32!")
        return false

    debug("  Sectors/cluster: ", udec_(sectorsPerCluster))
    debug("  Sectors/FAT: ", udec_(sectorsPerFat))
    debug("  Total clusters: ", udec_(totalClusters))
    debug("  Partition start: ", udec_(partitionStart))
    debug("  FAT1 start: ", udec_(fat1Start))
    debug("  FAT2 start: ", udec_(fat2Start))
    debug("  Data start: ", udec_(dataStart))

    ' Write MBR
    debug(" ")
    debug("* Writing MBR...")
    if not writeMBR()
        debug("ERROR: Failed to write MBR!")
        showWriteDiag()
        return false

    ' Verify MBR read-back
    sd.readSectorRaw(0, @verifyBuf)
    debug("  MBR readback: sig=$", uhex_word_(WORD[@verifyBuf + $1FE]), ...
      " type=$", uhex_byte_(verifyBuf[$1C2]), ...
      " start=", udec_(LONG[@verifyBuf + $1C6]))
    debug("  MBR read[0..7]: $", uhex_byte_(verifyBuf[0]), " $", uhex_byte_(verifyBuf[1]), ...
      " $", uhex_byte_(verifyBuf[2]), " $", uhex_byte_(verifyBuf[3]), ...
      " $", uhex_byte_(verifyBuf[4]), " $", uhex_byte_(verifyBuf[5]), ...
      " $", uhex_byte_(verifyBuf[6]), " $", uhex_byte_(verifyBuf[7]))
    debug("  verify buf addr: $", uhex_long_(@verifyBuf))
    if WORD[@verifyBuf + $1FE] <> MBR_SIGNATURE
        debug("  *** MBR READBACK MISMATCH! Written data not on card ***")

    ' Write VBR (Volume Boot Record)
    debug("* Writing VBR...")
    if not writeVBR()
        debug("ERROR: Failed to write VBR!")
        showWriteDiag()
        return false

    ' Verify VBR read-back
    sd.readSectorRaw(partitionStart, @verifyBuf)
    debug("  VBR readback: jump=$", uhex_byte_(verifyBuf[0]), ...
      " OEM=$", uhex_byte_(verifyBuf[3]), uhex_byte_(verifyBuf[4]), ...
      " bps=", udec_(WORD[@verifyBuf + $0B]), ...
      " spc=", udec_(verifyBuf[$0D]), ...
      " sig=$", uhex_word_(WORD[@verifyBuf + $1FE]))
    if verifyBuf[0] <> $EB
        debug("  *** VBR READBACK MISMATCH! Expected $EB got $", uhex_byte_(verifyBuf[0]), " ***")

    ' Write FSInfo sector
    debug("* Writing FSInfo...")
    if not writeFSInfo()
        debug("ERROR: Failed to write FSInfo!")
        return false

    ' Write backup boot sector (sector 6 of partition)
    debug("* Writing backup boot sector...")
    if not writeBackupBoot()
        debug("ERROR: Failed to write backup boot!")
        return false

    ' Initialize FAT tables
    debug("* Initializing FAT1...")
    if not initFAT(fat1Start)
        debug("ERROR: Failed to initialize FAT1!")
        return false

    debug("* Initializing FAT2...")
    if not initFAT(fat2Start)
        debug("ERROR: Failed to initialize FAT2!")
        return false

    ' Initialize root directory
    debug("* Initializing root directory...")
    if not initRootDirectory()
        debug("ERROR: Failed to initialize root directory!")
        return false

    debug(" ")
    debug("==============================================")
    debug("  FORMAT COMPLETE")
    debug("  Volume: [", zstr_(@volumeLabel), "]")
    debug("  Size: ", udec_(totalSectors / 2048), " MB")
    debug("  Clusters: ", udec_(totalClusters))
    debug("==============================================")

    return true

PRI calculateParameters() : success | clusterSize
' Calculate filesystem parameters based on card size.
'
' @returns success - TRUE if card large enough for FAT32, FALSE otherwise

    ' Partition starts at sector 8192 (4MB aligned for modern cards)
    partitionStart := 8192

    ' Calculate data sectors available
    dataSectors := totalSectors - partitionStart

    ' Determine sectors per cluster based on volume size
    ' Microsoft recommends:
    '   <= 8GB:   8 sectors (4KB clusters)
    '   <= 16GB: 16 sectors (8KB clusters)
    '   <= 32GB: 32 sectors (16KB clusters)
    '   > 32GB:  64 sectors (32KB clusters)

    if dataSectors <= 16_777_216        ' <= 8GB
        sectorsPerCluster := 8
    elseif dataSectors <= 33_554_432    ' <= 16GB
        sectorsPerCluster := 16
    elseif dataSectors <= 67_108_864    ' <= 32GB
        sectorsPerCluster := 32
    else
        sectorsPerCluster := 64

    ' Calculate sectors per FAT
    ' Formula: sectorsPerFat = (dataSectors - RESERVED) / (clusterSize * 2 / 4 + NUM_FATS)
    ' Simplified approximation that works well:
    totalClusters := (dataSectors - RESERVED_SECTORS) / sectorsPerCluster
    sectorsPerFat := (totalClusters * 4 + BYTES_PER_SECTOR - 1) / BYTES_PER_SECTOR

    ' Recalculate actual data area
    fat1Start := partitionStart + RESERVED_SECTORS
    fat2Start := fat1Start + sectorsPerFat
    dataStart := fat2Start + sectorsPerFat

    ' Recalculate total clusters with actual layout
    dataSectors := totalSectors - dataStart
    totalClusters := dataSectors / sectorsPerCluster

    ' FAT32 requires at least 65525 clusters
    if totalClusters < 65525
        return false

    return true

PRI writeMBR() : success | partitionSectors
' Write the Master Boot Record (sector 0) with partition table.
'
' @returns success - TRUE if write succeeded, FALSE otherwise

    ' Clear buffer
    bytefill(@buf, 0, BYTES_PER_SECTOR)

    ' Partition table entry at offset $1BE (446)
    partitionSectors := totalSectors - partitionStart

    buf[$1BE] := $00                    ' Boot indicator (not bootable)
    buf[$1BF] := $00                    ' Starting head (CHS - ignored for LBA)
    buf[$1C0] := $00                    ' Starting sector (CHS)
    buf[$1C1] := $00                    ' Starting cylinder (CHS)
    buf[$1C2] := PARTITION_TYPE_FAT32_LBA  ' Partition type
    buf[$1C3] := $FE                    ' Ending head (CHS)
    buf[$1C4] := $FF                    ' Ending sector (CHS)
    buf[$1C5] := $FF                    ' Ending cylinder (CHS)

    ' Partition start LBA (little endian)
    LONG[@buf + $1C6] := partitionStart

    ' Partition size in sectors (little endian)
    LONG[@buf + $1CA] := partitionSectors

    ' MBR signature
    WORD[@buf + $1FE] := MBR_SIGNATURE

    ' Diagnostic: dump write buffer before writing
    debug("  MBR write buf: sig=$", uhex_word_(WORD[@buf + $1FE]), ...
      " type=$", uhex_byte_(buf[$1C2]), ...
      " start=", udec_(LONG[@buf + $1C6]))
    debug("  MBR buf[0..7]: $", uhex_byte_(buf[0]), " $", uhex_byte_(buf[1]), ...
      " $", uhex_byte_(buf[2]), " $", uhex_byte_(buf[3]), ...
      " $", uhex_byte_(buf[4]), " $", uhex_byte_(buf[5]), ...
      " $", uhex_byte_(buf[6]), " $", uhex_byte_(buf[7]))
    debug("  MBR buf addr: $", uhex_long_(@buf))

    ' Write MBR to sector 0
    success := sd.writeSectorRaw(0, @buf)

PRI writeVBR() : success | i
' Write the Volume Boot Record (first sector of partition).
'
' @returns success - TRUE if write succeeded, FALSE otherwise

    ' Clear buffer
    bytefill(@buf, 0, BYTES_PER_SECTOR)

    ' Jump instruction
    buf[$00] := $EB
    buf[$01] := $58
    buf[$02] := $90

    ' OEM name (8 bytes)
    bytemove(@buf + $03, @"P2FMTER ", 8)

    ' BPB (BIOS Parameter Block)
    WORD[@buf + $0B] := BYTES_PER_SECTOR    ' Bytes per sector
    buf[$0D] := sectorsPerCluster           ' Sectors per cluster
    WORD[@buf + $0E] := RESERVED_SECTORS    ' Reserved sectors
    buf[$10] := NUM_FATS                    ' Number of FATs
    WORD[@buf + $11] := 0                   ' Root entries (0 for FAT32)
    WORD[@buf + $13] := 0                   ' Total sectors 16-bit (0 for FAT32)
    buf[$15] := $F8                         ' Media type (fixed disk)
    WORD[@buf + $16] := 0                   ' Sectors per FAT (16-bit, 0 for FAT32)
    WORD[@buf + $18] := 63                  ' Sectors per track (legacy)
    WORD[@buf + $1A] := 255                 ' Number of heads (legacy)
    LONG[@buf + $1C] := partitionStart      ' Hidden sectors (partition start)
    LONG[@buf + $20] := totalSectors - partitionStart  ' Total sectors 32-bit

    ' FAT32 extended BPB
    LONG[@buf + $24] := sectorsPerFat       ' Sectors per FAT (32-bit)
    WORD[@buf + $28] := 0                   ' Flags
    WORD[@buf + $2A] := 0                   ' Version
    LONG[@buf + $2C] := ROOT_CLUSTER        ' Root cluster
    WORD[@buf + $30] := 1                   ' FSInfo sector
    WORD[@buf + $32] := 6                   ' Backup boot sector
    ' Bytes $34-$3F reserved (already 0)

    buf[$40] := $80                         ' Drive number
    buf[$41] := 0                           ' Reserved
    buf[$42] := $29                         ' Extended boot signature
    LONG[@buf + $43] := getct()             ' Volume serial number (random)

    ' Volume label (11 bytes)
    bytemove(@buf + $47, @volumeLabel, 11)

    ' File system type (8 bytes)
    bytemove(@buf + $52, @"FAT32   ", 8)

    ' Boot signature
    WORD[@buf + $1FE] := MBR_SIGNATURE

    ' Write VBR to partition start
    success := sd.writeSectorRaw(partitionStart, @buf)

PRI writeFSInfo() : success
' Write the FSInfo sector with free cluster count and hint.
'
' @returns success - TRUE if write succeeded, FALSE otherwise

    ' Clear buffer
    bytefill(@buf, 0, BYTES_PER_SECTOR)

    ' FSInfo signatures
    LONG[@buf + $000] := FSINFO_SIG1        ' Lead signature
    LONG[@buf + $1E4] := FSINFO_SIG2        ' Structure signature
    LONG[@buf + $1E8] := totalClusters - 1  ' Free cluster count
    LONG[@buf + $1EC] := 3                  ' Next free cluster hint
    LONG[@buf + $1FC] := FSINFO_SIG3        ' Trail signature (includes $AA55)

    ' Write FSInfo to sector 1 of partition
    success := sd.writeSectorRaw(partitionStart + 1, @buf)

PRI writeBackupBoot() : success
' Write backup VBR and FSInfo to sectors 6 and 7 of partition.
'
' @returns success - TRUE if writes succeeded, FALSE otherwise

    ' Re-create VBR in buffer
    writeVBR()

    ' Write to sector 6 of partition (backup VBR location)
    if not sd.writeSectorRaw(partitionStart + 6, @buf)
        return false

    ' Write backup FSInfo to sector 7
    writeFSInfo()
    success := sd.writeSectorRaw(partitionStart + 7, @buf)

PRI initFAT(fatStart) : success | sector, remaining, batch, written
' Initialize a FAT table with media type and root cluster.
' Uses CMD25 multi-sector writes in 64-sector batches for ~5.5x speedup.
'
' @param fatStart - Starting sector of the FAT
' @returns success - TRUE if all sectors written, FALSE otherwise

    ' Clear buffer
    bytefill(@buf, 0, BYTES_PER_SECTOR)

    ' First sector of FAT has special entries
    LONG[@buf + 0] := FAT32_MEDIA_TYPE      ' FAT[0] - media type
    LONG[@buf + 4] := FAT32_EOC             ' FAT[1] - end of chain marker
    LONG[@buf + 8] := FAT32_EOC             ' FAT[2] - root directory (end of chain)

    ' Write first FAT sector (single-sector, has special entries)
    if not sd.writeSectorRaw(fatStart, @buf)
        return false

    ' Write remaining FAT sectors in CMD25 batches (all zeros = free clusters)
    ' zeroBuf is zero-initialized by Spin2 VAR section
    sector := 1
    remaining := sectorsPerFat - 1
    repeat while remaining > 0
        batch := remaining <# MULTI_BATCH_SIZE                                   ' Clamp to 64 or remainder
        written := sd.writeSectorsRaw(fatStart + sector, batch, @zeroBuf)
        if written <> batch
            debug("  FAT batch write FAILED at sector ", udec_(sector), " wrote ", udec_(written), "/", udec_(batch))
            return false
        if (sector & $FF) == 0 or remaining <= batch
            debug("  Progress: ", udec_(sector + batch), "/", udec_(sectorsPerFat))
        sector += batch
        remaining -= batch

    return true

PRI initRootDirectory() : success | written
' Initialize the root directory cluster with volume label entry.
'
' @returns success - TRUE if all sectors written, FALSE otherwise

    ' Clear buffer
    bytefill(@buf, 0, BYTES_PER_SECTOR)

    ' Create volume label directory entry at offset 0
    ' Filename (11 bytes) = volume label
    bytemove(@buf, @volumeLabel, 11)

    ' Attributes = $08 (volume label)
    buf[$0B] := $08

    ' Creation time/date (use some default)
    WORD[@buf + $0E] := $0000   ' Creation time
    WORD[@buf + $10] := $0021   ' Creation date (1980-01-01)
    WORD[@buf + $12] := $0021   ' Access date
    WORD[@buf + $14] := $0000   ' High word of cluster (0)
    WORD[@buf + $16] := $0000   ' Modification time
    WORD[@buf + $18] := $0021   ' Modification date
    WORD[@buf + $1A] := $0000   ' Low word of cluster (0)
    LONG[@buf + $1C] := 0       ' File size (0 for volume label)

    ' Write first sector of root directory
    if not sd.writeSectorRaw(dataStart, @buf)
        return false

    ' Clear remaining sectors of root cluster using CMD25 batch write
    ' zeroBuf is zero-initialized by Spin2 VAR section; max 63 sectors fits in 32 KB
    if sectorsPerCluster > 1
        written := sd.writeSectorsRaw(dataStart + 1, sectorsPerCluster - 1, @zeroBuf)
        if written <> sectorsPerCluster - 1
            debug("  Root dir batch write FAILED: wrote ", udec_(written), "/", udec_(sectorsPerCluster - 1))
            return false

    return true

PRI showWriteDiag() | wResult, wR1, wDresp, wSector
' Display write diagnostic info from driver after a write failure.

    wResult, wR1, wDresp, wSector := sd.getWriteDiag()
    debug("  DIAG: result=", udec_(wResult), " R1=$", uhex_byte_(wR1), " dresp=$", uhex_byte_(wDresp), " sector=", udec_(wSector))
    debug("  (1=CMD24fatal 2=drespTimeout 3=CRCreject 4=writeErr 5=unknownReject 6=busyTimeout 7=OK)")

CON { license }

{{
  =================================================================================================

  Terms of Use: MIT License

  Copyright (c) 2026 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  =================================================================================================
}}
