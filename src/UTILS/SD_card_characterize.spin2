{{
┌──────────────────────────────────────────┐
│ SD Card Characterization Diagnostic V3   │
│ Author: Stephen M Moraco                 │
│ Copyright (c) 2026 Iron Sheep Productions│
│ See end of file for terms of use.        │
└──────────────────────────────────────────┘

  Comprehensive diagnostic tool to characterize SD cards.
  Extracts and displays ALL fields from card registers:
    - CID (Card Identification Register) - 16 bytes
    - CSD (Card Specific Data Register) - 16 bytes
    - SCR (SD Configuration Register) - 8 bytes
    - OCR (Operating Conditions Register) - 4 bytes
    - VBR/BPB (Volume Boot Record / BIOS Parameter Block)

  Output: Formatted debug report with ALL fields.
  Fields marked with [USED] are actively used by V3 driver.
  Fields marked with [INFO] are informational only.

  Usage: Run from tools/ with:
    ./run_test.sh ../regression-tests/SD_card_characterize.spin2 -t 60
}}

CON
  _CLKFREQ = 270_000_000

  ' SD card pins - P2 EC32MB Edge Module
  CS_PIN   = 60
  MOSI_PIN = 59
  MISO_PIN = 58
  SCK_PIN  = 61

  ' Buffer sizes
  CID_SIZE = 16
  CSD_SIZE = 16
  SCR_SIZE = 8
  VBR_SIZE = 512

OBJ
  sd : "SD_card_driver"

DAT
  ' Register buffers
  cid_buf       BYTE    0[CID_SIZE]
  csd_buf       BYTE    0[CSD_SIZE]
  scr_buf       BYTE    0[SCR_SIZE]
  vbr_buf       BYTE    0[VBR_SIZE]
  ocr_val       LONG    0

  ' ===== CID FIELDS (16 bytes, 128 bits) =====
  cid_mid       BYTE    0           ' [127:120] Manufacturer ID
  cid_oid       WORD    0           ' [119:104] OEM/Application ID (2 ASCII chars)
  cid_pnm       BYTE    0[6]        ' [103:64]  Product Name (5 ASCII chars + null)
  cid_prv_major BYTE    0           ' [63:60]   Product Revision major (BCD)
  cid_prv_minor BYTE    0           ' [59:56]   Product Revision minor (BCD)
  cid_psn       LONG    0           ' [55:24]   Product Serial Number
  cid_mdt_year  WORD    0           ' [19:8]    Manufacturing Year (2000 + value)
  cid_mdt_month BYTE    0           ' [11:8]    Manufacturing Month
  cid_crc       BYTE    0           ' [7:1]     CRC7 checksum

  ' ===== CSD FIELDS (16 bytes, 128 bits) =====
  ' Common fields (both CSD v1.0 and v2.0)
  csd_structure     BYTE    0       ' [127:126] CSD structure version
  csd_taac          BYTE    0       ' [119:112] Data read access time-1
  csd_nsac          BYTE    0       ' [111:104] Data read access time-2 (CLK cycles)
  csd_tran_speed    BYTE    0       ' [103:96]  Max data transfer rate
  csd_ccc           WORD    0       ' [95:84]   Card command classes (12 bits)
  csd_read_bl_len   BYTE    0       ' [83:80]   Max read data block length
  csd_read_bl_partial   BYTE  0     ' [79]      Partial blocks for read allowed
  csd_write_blk_misalign BYTE 0     ' [78]      Write block misalignment
  csd_read_blk_misalign  BYTE 0     ' [77]      Read block misalignment
  csd_dsr_imp       BYTE    0       ' [76]      DSR implemented
  ' CSD v1.0 specific (SDSC)
  csd_v1_c_size     WORD    0       ' [73:62]   Device size (12 bits)
  csd_v1_vdd_r_curr_min BYTE 0      ' [61:59]   Max read current @ VDD min
  csd_v1_vdd_r_curr_max BYTE 0      ' [58:56]   Max read current @ VDD max
  csd_v1_vdd_w_curr_min BYTE 0      ' [55:53]   Max write current @ VDD min
  csd_v1_vdd_w_curr_max BYTE 0      ' [52:50]   Max write current @ VDD max
  csd_v1_c_size_mult    BYTE 0      ' [49:47]   Device size multiplier (3 bits)
  ' CSD v2.0 specific (SDHC/SDXC)
  csd_v2_c_size     LONG    0       ' [69:48]   Device size (22 bits for SDHC, 28 for SDXC)
  ' Common fields continued
  csd_erase_blk_en  BYTE    0       ' [46]      Erase single block enable
  csd_sector_size   BYTE    0       ' [45:39]   Erase sector size (7 bits)
  csd_wp_grp_size   BYTE    0       ' [38:32]   Write protect group size (7 bits)
  csd_wp_grp_enable BYTE    0       ' [31]      Write protect group enable
  csd_r2w_factor    BYTE    0       ' [28:26]   Write speed factor (3 bits)
  csd_write_bl_len  BYTE    0       ' [25:22]   Max write data block length (4 bits)
  csd_write_bl_partial BYTE 0       ' [21]      Partial blocks for write allowed
  csd_file_format_grp BYTE  0       ' [15]      File format group
  csd_copy          BYTE    0       ' [14]      Copy flag
  csd_perm_write_protect BYTE 0     ' [13]      Permanent write protection
  csd_tmp_write_protect  BYTE 0     ' [12]      Temporary write protection
  csd_file_format   BYTE    0       ' [11:10]   File format (2 bits)
  csd_crc           BYTE    0       ' [7:1]     CRC7 checksum

  ' Calculated values from CSD
  csd_capacity_mb   LONG    0       ' Calculated capacity in MB
  csd_max_speed_hz  LONG    0       ' Calculated max transfer speed in Hz
  csd_read_timeout_ms  LONG 0       ' Calculated read timeout in ms
  csd_write_timeout_ms LONG 0       ' Calculated write timeout in ms

  ' ===== SCR FIELDS (8 bytes, 64 bits) =====
  scr_structure     BYTE    0       ' [63:60]   SCR structure version
  scr_sd_spec       BYTE    0       ' [59:56]   SD spec version
  scr_data_stat_after_erase BYTE 0  ' [55]      Data status after erase
  scr_sd_security   BYTE    0       ' [54:52]   SD security support (3 bits)
  scr_sd_bus_widths BYTE    0       ' [51:48]   Supported bus widths (4 bits)
  scr_sd_spec3      BYTE    0       ' [47]      SD spec 3.0 support
  scr_ex_security   BYTE    0       ' [46:43]   Extended security (4 bits)
  scr_sd_spec4      BYTE    0       ' [42]      SD spec 4.0 support
  scr_sd_specx      BYTE    0       ' [41:38]   SD specX (4 bits, for 5.x/6.x)
  scr_cmd_support   BYTE    0       ' [33:32]   Command support bits

  ' ===== OCR FIELDS (4 bytes, 32 bits) =====
  ocr_busy          BYTE    0       ' [31]      Card power up status (0=busy, 1=ready)
  ocr_ccs           BYTE    0       ' [30]      Card Capacity Status (0=SDSC, 1=SDHC/SDXC)
  ocr_uhsii         BYTE    0       ' [29]      UHS-II card status
  ocr_s18a          BYTE    0       ' [24]      Switching to 1.8V accepted
  ocr_voltage_27_28 BYTE    0       ' [15]      2.7-2.8V supported
  ocr_voltage_28_29 BYTE    0       ' [16]      2.8-2.9V supported
  ocr_voltage_29_30 BYTE    0       ' [17]      2.9-3.0V supported
  ocr_voltage_30_31 BYTE    0       ' [18]      3.0-3.1V supported
  ocr_voltage_31_32 BYTE    0       ' [19]      3.1-3.2V supported
  ocr_voltage_32_33 BYTE    0       ' [20]      3.2-3.3V supported
  ocr_voltage_33_34 BYTE    0       ' [21]      3.3-3.4V supported
  ocr_voltage_34_35 BYTE    0       ' [22]      3.4-3.5V supported
  ocr_voltage_35_36 BYTE    0       ' [23]      3.5-3.6V supported

  ' ===== VBR FIELDS =====
  vbr_bytes_per_sec   WORD    0
  vbr_sec_per_clus    BYTE    0
  vbr_reserved_sec    WORD    0
  vbr_num_fats        BYTE    0
  vbr_total_sectors   LONG    0
  vbr_sec_per_fat     LONG    0
  vbr_root_cluster    LONG    0
  vbr_volume_serial   LONG    0
  vbr_volume_label    BYTE    0[12]
  vbr_fs_type         BYTE    0[9]
  vbr_oem_name        BYTE    0[9]

  ' Manufacturer lookup table (ID, Name)
  mfr_table     BYTE    $00, "Budget OEM", 0
                BYTE    $01, "Panasonic", 0
                BYTE    $02, "Toshiba/Kioxia", 0
                BYTE    $03, "SanDisk", 0
                BYTE    $06, "Ritek", 0
                BYTE    $09, "ATP", 0
                BYTE    $12, "Gigastone OEM", 0
                BYTE    $13, "Kingmax", 0
                BYTE    $19, "Dynacard", 0
                BYTE    $1A, "PQI", 0
                BYTE    $1B, "Samsung", 0
                BYTE    $1C, "Bravera", 0
                BYTE    $1D, "AData", 0
                BYTE    $27, "Phison", 0
                BYTE    $28, "Lexar (old)", 0
                BYTE    $31, "Silicon Power", 0
                BYTE    $41, "Kingston", 0
                BYTE    $45, "SanDisk", 0
                BYTE    $4D, "SanDisk", 0
                BYTE    $53, "SanDisk", 0
                BYTE    $55, "SanDisk", 0
                BYTE    $5D, "SwissBit", 0
                BYTE    $6F, "STMicro", 0
                BYTE    $73, "SanDisk", 0
                BYTE    $74, "Transcend", 0
                BYTE    $76, "Patriot", 0
                BYTE    $82, "Sony", 0
                BYTE    $89, "Silicon Motion", 0
                BYTE    $9C, "Barun", 0
                BYTE    $9E, "GSKILL", 0
                BYTE    $9F, "Shared OEM", 0
                BYTE    $AD, "Longsys/Lexar", 0
                BYTE    $FE, "PNY OEM", 0
                BYTE    $FF                   ' End marker

  ' TRAN_SPEED unit table (bits [2:0])
  tran_unit_table   LONG    100_000       ' 0: 100 kbit/s
                    LONG    1_000_000     ' 1: 1 Mbit/s
                    LONG    10_000_000    ' 2: 10 Mbit/s
                    LONG    100_000_000   ' 3: 100 Mbit/s
                    LONG    0             ' 4: reserved
                    LONG    0             ' 5: reserved
                    LONG    0             ' 6: reserved
                    LONG    0             ' 7: reserved

  ' TRAN_SPEED time value table (bits [6:3]) - multiply by 10 to get actual
  tran_time_table   BYTE    0             ' 0: reserved
                    BYTE    10            ' 1: 1.0
                    BYTE    12            ' 2: 1.2
                    BYTE    13            ' 3: 1.3
                    BYTE    15            ' 4: 1.5
                    BYTE    20            ' 5: 2.0
                    BYTE    25            ' 6: 2.5
                    BYTE    30            ' 7: 3.0
                    BYTE    35            ' 8: 3.5
                    BYTE    40            ' 9: 4.0
                    BYTE    45            ' A: 4.5
                    BYTE    50            ' B: 5.0
                    BYTE    55            ' C: 5.5
                    BYTE    60            ' D: 6.0
                    BYTE    70            ' E: 7.0
                    BYTE    80            ' F: 8.0

  ' TAAC time unit table (bits [2:0])
  taac_unit_table   LONG    1             ' 0: 1 ns
                    LONG    10            ' 1: 10 ns
                    LONG    100           ' 2: 100 ns
                    LONG    1_000         ' 3: 1 us
                    LONG    10_000        ' 4: 10 us
                    LONG    100_000       ' 5: 100 us
                    LONG    1_000_000     ' 6: 1 ms
                    LONG    10_000_000    ' 7: 10 ms

  ' Unique card ID string buffer
  card_id_str   BYTE    0[64]

PUB main() | result

  debug("##############################################")
  debug("#  SD Card Characterization Report V3       #")
  debug("#  All register fields - comprehensive      #")
  debug("##############################################")
  debug(" ")

  ' Initialize card WITHOUT mounting filesystem
  ' This allows characterization of cards with any filesystem (exFAT, NTFS, etc.)
  debug("Initializing SD card (no-mount mode)...")
  result := sd.initCardOnly(CS_PIN, MOSI_PIN, MISO_PIN, SCK_PIN)
  if not result
    debug("FATAL: Failed to initialize SD card!")
    debug("Check card insertion and wiring.")
    repeat  ' halt

  debug("Card initialized successfully.")
  debug(" ")

  ' Read all registers
  readAllRegisters()

  ' Parse and display each register with ALL fields
  parseCID()
  displayCID()

  parseCSD()
  displayCSD()

  parseOCR()
  displayOCR()

  parseSCR()
  displaySCR()

  ' Display raw registers for verification
  displayRawRegisters()

  ' Read and display filesystem info
  findAndReadVBR()
  parseVBR()
  displayVBR()

  ' Generate unique card ID
  generateCardID()
  displayCardID()

  ' Display driver usage summary
  displayDriverUsage()

  debug(" ")
  debug("##############################################")
  debug("END_CHARACTERIZATION")
  debug("##############################################")

  repeat  ' halt

PRI readAllRegisters() | result

  debug("--- Reading Card Registers ---")

  ' Read CID (Card Identification)
  result := sd.readCIDRaw(@cid_buf)
  if result
    debug("  CID: OK (16 bytes)")
  else
    debug("  CID: FAILED")

  ' Read CSD (Card Specific Data)
  result := sd.readCSDRaw(@csd_buf)
  if result
    debug("  CSD: OK (16 bytes)")
  else
    debug("  CSD: FAILED")

  ' Read SCR (SD Configuration Register)
  result := sd.readSCRRaw(@scr_buf)
  if result
    debug("  SCR: OK (8 bytes)")
  else
    debug("  SCR: FAILED")

  ' Get cached OCR
  ocr_val := sd.getOCR()
  debug("  OCR: OK (4 bytes)")

  debug(" ")

' ============================================================
' CID PARSING AND DISPLAY
' ============================================================

PRI parseCID() | i
  '' Parse all CID register fields
  '' CID structure (128 bits = 16 bytes):
  ''   [127:120] MID - Manufacturer ID (8 bits)
  ''   [119:104] OID - OEM/Application ID (16 bits, 2 ASCII chars)
  ''   [103:64]  PNM - Product Name (40 bits, 5 ASCII chars)
  ''   [63:56]   PRV - Product Revision (8 bits, BCD n.m)
  ''   [55:24]   PSN - Product Serial Number (32 bits)
  ''   [23:20]   reserved (4 bits)
  ''   [19:8]    MDT - Manufacturing Date (12 bits)
  ''   [7:1]     CRC7 checksum (7 bits)
  ''   [0]       always 1

  cid_mid := cid_buf[0]
  cid_oid := (cid_buf[1] << 8) | cid_buf[2]

  repeat i from 0 to 4
    cid_pnm[i] := cid_buf[3 + i]
  cid_pnm[5] := 0  ' null terminate

  cid_prv_major := cid_buf[8] >> 4
  cid_prv_minor := cid_buf[8] & $0F

  cid_psn := (cid_buf[9] << 24) | (cid_buf[10] << 16) | (cid_buf[11] << 8) | cid_buf[12]

  cid_mdt_year := 2000 + ((cid_buf[13] & $0F) << 4) + ((cid_buf[14] >> 4) & $0F)
  cid_mdt_month := cid_buf[14] & $0F

  cid_crc := cid_buf[15] >> 1

PRI displayCID() | p_mfr, oid_c1, oid_c2
  debug(" ")
  debug("======== CID REGISTER (Card Identification) ========")
  debug("[USED] = Field used by V3 driver")
  debug("[INFO] = Informational only")
  debug(" ")

  p_mfr := lookupManufacturer(cid_mid)
  debug("[USED] MID (Manufacturer ID):     $", uhex_byte_(cid_mid), " (", zstr_(p_mfr), ")")

  oid_c1 := cid_oid >> 8
  oid_c2 := cid_oid & $FF
  if oid_c1 >= 32 and oid_c1 < 127 and oid_c2 >= 32 and oid_c2 < 127
    debug("[INFO] OID (OEM/Application ID): $", uhex_byte_(oid_c1), " $", uhex_byte_(oid_c2), " (ASCII)")
  else
    debug("[INFO] OID (OEM/Application ID): $", uhex_byte_(oid_c1), " $", uhex_byte_(oid_c2))

  debug("[INFO] PNM (Product Name):        [", zstr_(@cid_pnm), "]")
  debug("[INFO] PRV (Product Revision):    ", udec_(cid_prv_major), ".", udec_(cid_prv_minor))
  debug("[INFO] PSN (Serial Number):       $", uhex_long_(cid_psn))

  if cid_mdt_month < 10
    debug("[INFO] MDT (Manufacturing Date): ", udec_(cid_mdt_year), "-0", udec_(cid_mdt_month))
  else
    debug("[INFO] MDT (Manufacturing Date): ", udec_(cid_mdt_year), "-", udec_(cid_mdt_month))

  debug("[INFO] CRC7:                      $", uhex_byte_(cid_crc))

PRI lookupManufacturer(mid) : p_name | p_entry, entry_id
  p_entry := @mfr_table
  repeat
    entry_id := BYTE[p_entry]
    if entry_id == $FF
      return @"Unknown"
    if entry_id == mid
      return p_entry + 1
    p_entry++
    repeat while BYTE[p_entry] <> 0
      p_entry++
    p_entry++

' ============================================================
' CSD PARSING AND DISPLAY
' ============================================================

PRI parseCSD() | time_val, time_unit, c_size
  '' Parse all CSD register fields

  ' CSD Structure [127:126]
  csd_structure := (csd_buf[0] >> 6) & $03

  ' TAAC [119:112]
  csd_taac := csd_buf[1]

  ' NSAC [111:104]
  csd_nsac := csd_buf[2]

  ' TRAN_SPEED [103:96]
  csd_tran_speed := csd_buf[3]

  ' CCC [95:84] - spans bytes 4 and 5
  csd_ccc := ((csd_buf[4] & $FF) << 4) | ((csd_buf[5] >> 4) & $0F)

  ' READ_BL_LEN [83:80]
  csd_read_bl_len := csd_buf[5] & $0F

  ' READ_BL_PARTIAL [79]
  csd_read_bl_partial := (csd_buf[6] >> 7) & 1

  ' WRITE_BLK_MISALIGN [78]
  csd_write_blk_misalign := (csd_buf[6] >> 6) & 1

  ' READ_BLK_MISALIGN [77]
  csd_read_blk_misalign := (csd_buf[6] >> 5) & 1

  ' DSR_IMP [76]
  csd_dsr_imp := (csd_buf[6] >> 4) & 1

  if csd_structure == 0
    ' CSD Version 1.0 (SDSC)
    ' C_SIZE [73:62] - 12 bits
    csd_v1_c_size := ((csd_buf[6] & $03) << 10) | (csd_buf[7] << 2) | ((csd_buf[8] >> 6) & $03)
    ' VDD_R_CURR_MIN [61:59]
    csd_v1_vdd_r_curr_min := (csd_buf[8] >> 3) & $07
    ' VDD_R_CURR_MAX [58:56]
    csd_v1_vdd_r_curr_max := csd_buf[8] & $07
    ' VDD_W_CURR_MIN [55:53]
    csd_v1_vdd_w_curr_min := (csd_buf[9] >> 5) & $07
    ' VDD_W_CURR_MAX [52:50]
    csd_v1_vdd_w_curr_max := (csd_buf[9] >> 2) & $07
    ' C_SIZE_MULT [49:47]
    csd_v1_c_size_mult := ((csd_buf[9] & $03) << 1) | ((csd_buf[10] >> 7) & 1)
    ' Calculate capacity
    csd_capacity_mb := ((csd_v1_c_size + 1) << (csd_v1_c_size_mult + 2)) >> (20 - csd_read_bl_len)
  else
    ' CSD Version 2.0 (SDHC/SDXC)
    ' C_SIZE [69:48] - 22 bits
    csd_v2_c_size := ((csd_buf[7] & $3F) << 16) | (csd_buf[8] << 8) | csd_buf[9]
    ' Calculate capacity: (C_SIZE + 1) * 512KB
    csd_capacity_mb := (csd_v2_c_size + 1) / 2

  ' ERASE_BLK_EN [46]
  csd_erase_blk_en := (csd_buf[10] >> 6) & 1

  ' SECTOR_SIZE [45:39] - 7 bits
  csd_sector_size := ((csd_buf[10] & $3F) << 1) | ((csd_buf[11] >> 7) & 1)

  ' WP_GRP_SIZE [38:32] - 7 bits
  csd_wp_grp_size := csd_buf[11] & $7F

  ' WP_GRP_ENABLE [31]
  csd_wp_grp_enable := (csd_buf[12] >> 7) & 1

  ' R2W_FACTOR [28:26] - 3 bits
  csd_r2w_factor := (csd_buf[12] >> 2) & $07

  ' WRITE_BL_LEN [25:22] - 4 bits
  csd_write_bl_len := ((csd_buf[12] & $03) << 2) | ((csd_buf[13] >> 6) & $03)

  ' WRITE_BL_PARTIAL [21]
  csd_write_bl_partial := (csd_buf[13] >> 5) & 1

  ' FILE_FORMAT_GRP [15]
  csd_file_format_grp := (csd_buf[14] >> 7) & 1

  ' COPY [14]
  csd_copy := (csd_buf[14] >> 6) & 1

  ' PERM_WRITE_PROTECT [13]
  csd_perm_write_protect := (csd_buf[14] >> 5) & 1

  ' TMP_WRITE_PROTECT [12]
  csd_tmp_write_protect := (csd_buf[14] >> 4) & 1

  ' FILE_FORMAT [11:10] - 2 bits
  csd_file_format := (csd_buf[14] >> 2) & $03

  ' CRC [7:1]
  csd_crc := csd_buf[15] >> 1

  ' Calculate TRAN_SPEED in Hz
  time_val := tran_time_table[(csd_tran_speed >> 3) & $0F]
  time_unit := tran_unit_table[csd_tran_speed & $07]
  csd_max_speed_hz := (time_val * time_unit) / 10

  ' Calculate timeouts (simplified - SDHC uses fixed 100ms/250ms)
  if csd_structure == 0
    ' SDSC: Calculate from TAAC/NSAC
    time_val := tran_time_table[(csd_taac >> 3) & $0F]
    time_unit := taac_unit_table[csd_taac & $07]
    csd_read_timeout_ms := (time_val * time_unit) / 10_000  ' Convert ns to ms approx
    if csd_read_timeout_ms < 100
      csd_read_timeout_ms := 100
    csd_write_timeout_ms := csd_read_timeout_ms << csd_r2w_factor
  else
    ' SDHC/SDXC: Fixed timeouts per spec
    csd_read_timeout_ms := 100
    csd_write_timeout_ms := 250

PRI displayCSD() | cap_gb, total_sectors, i
  debug(" ")
  debug("======== CSD REGISTER (Card Specific Data) ========")
  debug(" ")

  debug("[USED] CSD_STRUCTURE:        ", udec_(csd_structure), " (CSD Version ", udec_(csd_structure + 1), ".0)")

  if csd_structure == 0
    debug("       Card Type:            SDSC (Standard Capacity)")
  else
    debug("       Card Type:            SDHC/SDXC (High/Extended Capacity)")

  debug(" ")
  debug("--- Timing Parameters ---")
  debug("[USED] TRAN_SPEED:           $", uhex_byte_(csd_tran_speed), " (", udec_(csd_max_speed_hz / 1_000_000), " MHz max)")
  debug("[USED] TAAC:                 $", uhex_byte_(csd_taac), " (read access time-1)")
  debug("[USED] NSAC:                 ", udec_(csd_nsac), " (read access time-2, CLK cycles)")
  debug("[USED] R2W_FACTOR:           ", udec_(csd_r2w_factor), " (write time = read time x ", udec_(1 << csd_r2w_factor), ")")
  debug("       Read Timeout:         ", udec_(csd_read_timeout_ms), " ms (calculated)")
  debug("       Write Timeout:        ", udec_(csd_write_timeout_ms), " ms (calculated)")

  debug(" ")
  debug("--- Capacity ---")
  if csd_structure == 0
    debug("[USED] C_SIZE:               ", udec_(csd_v1_c_size), " (SDSC device size)")
    debug("[USED] C_SIZE_MULT:          ", udec_(csd_v1_c_size_mult))
    debug("[USED] READ_BL_LEN:          ", udec_(csd_read_bl_len), " (max block = ", udec_(1 << csd_read_bl_len), " bytes)")
  else
    debug("[USED] C_SIZE:               ", udec_(csd_v2_c_size), " (", udec_(csd_capacity_mb), " MB)")

  cap_gb := csd_capacity_mb / 1024
  if cap_gb > 0
    debug("       Capacity:             ~", udec_(cap_gb), " GB")
  else
    debug("       Capacity:             ", udec_(csd_capacity_mb), " MB")

  total_sectors := csd_capacity_mb * 2048
  debug("       Total Sectors:        ", udec_(total_sectors))

  debug(" ")
  debug("--- Command Classes (CCC) ---")
  debug("[INFO] CCC:                  $", uhex_(csd_ccc))
  debug("       Class 0 (basic):      ", zstr_(csd_ccc & $001 ? @"Yes" : @"No"))
  debug("       Class 2 (block read): ", zstr_(csd_ccc & $004 ? @"Yes" : @"No"))
  debug("       Class 4 (block write):", zstr_(csd_ccc & $010 ? @"Yes" : @"No"))
  debug("       Class 5 (erase):      ", zstr_(csd_ccc & $020 ? @"Yes" : @"No"))
  debug("       Class 6 (write prot): ", zstr_(csd_ccc & $040 ? @"Yes" : @"No"))
  debug("       Class 7 (lock card):  ", zstr_(csd_ccc & $080 ? @"Yes" : @"No"))
  debug("       Class 8 (app spec):   ", zstr_(csd_ccc & $100 ? @"Yes" : @"No"))
  debug("       Class 10 (switch):    ", zstr_(csd_ccc & $400 ? @"Yes" : @"No"))

  debug(" ")
  debug("--- Block Parameters ---")
  debug("[INFO] READ_BL_LEN:          ", udec_(csd_read_bl_len), " (", udec_(1 << csd_read_bl_len), " bytes)")
  debug("[INFO] WRITE_BL_LEN:         ", udec_(csd_write_bl_len), " (", udec_(1 << csd_write_bl_len), " bytes)")
  debug("[INFO] READ_BL_PARTIAL:      ", udec_(csd_read_bl_partial))
  debug("[INFO] WRITE_BL_PARTIAL:     ", udec_(csd_write_bl_partial))
  debug("[INFO] READ_BLK_MISALIGN:    ", udec_(csd_read_blk_misalign))
  debug("[INFO] WRITE_BLK_MISALIGN:   ", udec_(csd_write_blk_misalign))

  debug(" ")
  debug("--- Erase Parameters ---")
  debug("[INFO] ERASE_BLK_EN:         ", udec_(csd_erase_blk_en), " (", zstr_(csd_erase_blk_en ? @"512-byte erase" : @"SECTOR_SIZE erase"), ")")
  debug("[INFO] SECTOR_SIZE:          ", udec_(csd_sector_size), " (erase sector = ", udec_((csd_sector_size + 1) * 512), " bytes)")

  debug(" ")
  debug("--- Write Protection ---")
  debug("[INFO] WP_GRP_SIZE:          ", udec_(csd_wp_grp_size))
  debug("[INFO] WP_GRP_ENABLE:        ", udec_(csd_wp_grp_enable))
  debug("[INFO] PERM_WRITE_PROTECT:   ", udec_(csd_perm_write_protect))
  debug("[INFO] TMP_WRITE_PROTECT:    ", udec_(csd_tmp_write_protect))

  debug(" ")
  debug("--- Other Fields ---")
  debug("[INFO] DSR_IMP:              ", udec_(csd_dsr_imp), " (Driver Stage Register ", zstr_(csd_dsr_imp ? @"implemented" : @"not implemented"), ")")
  debug("[INFO] FILE_FORMAT_GRP:      ", udec_(csd_file_format_grp))
  debug("[INFO] FILE_FORMAT:          ", udec_(csd_file_format))
  debug("[INFO] COPY:                 ", udec_(csd_copy))
  debug("[INFO] CRC7:                 $", uhex_byte_(csd_crc))

  if csd_structure == 0
    debug(" ")
    debug("--- SDSC Current Requirements ---")
    debug("[INFO] VDD_R_CURR_MIN:       ", udec_(csd_v1_vdd_r_curr_min))
    debug("[INFO] VDD_R_CURR_MAX:       ", udec_(csd_v1_vdd_r_curr_max))
    debug("[INFO] VDD_W_CURR_MIN:       ", udec_(csd_v1_vdd_w_curr_min))
    debug("[INFO] VDD_W_CURR_MAX:       ", udec_(csd_v1_vdd_w_curr_max))

' ============================================================
' OCR PARSING AND DISPLAY
' ============================================================

PRI parseOCR()
  '' Parse all OCR register fields

  ocr_busy := (ocr_val >> 31) & 1
  ocr_ccs := (ocr_val >> 30) & 1
  ocr_uhsii := (ocr_val >> 29) & 1
  ocr_s18a := (ocr_val >> 24) & 1

  ocr_voltage_35_36 := (ocr_val >> 23) & 1
  ocr_voltage_34_35 := (ocr_val >> 22) & 1
  ocr_voltage_33_34 := (ocr_val >> 21) & 1
  ocr_voltage_32_33 := (ocr_val >> 20) & 1
  ocr_voltage_31_32 := (ocr_val >> 19) & 1
  ocr_voltage_30_31 := (ocr_val >> 18) & 1
  ocr_voltage_29_30 := (ocr_val >> 17) & 1
  ocr_voltage_28_29 := (ocr_val >> 16) & 1
  ocr_voltage_27_28 := (ocr_val >> 15) & 1

PRI displayOCR()
  debug(" ")
  debug("======== OCR REGISTER (Operating Conditions) ========")
  debug(" ")

  debug("       OCR Value:            $", uhex_long_(ocr_val))
  debug(" ")

  debug("[INFO] Bit 31 (Power Up):    ", udec_(ocr_busy), " (", zstr_(ocr_busy ? @"Ready" : @"Busy"), ")")
  debug("[USED] Bit 30 (CCS):         ", udec_(ocr_ccs), " (", zstr_(ocr_ccs ? @"SDHC/SDXC" : @"SDSC"), ") ** CRITICAL: Determines addressing mode **")
  debug("[INFO] Bit 29 (UHS-II):      ", udec_(ocr_uhsii), " (", zstr_(ocr_uhsii ? @"UHS-II card" : @"Not UHS-II"), ")")
  debug("[INFO] Bit 24 (S18A):        ", udec_(ocr_s18a), " (", zstr_(ocr_s18a ? @"1.8V switching accepted" : @"3.3V only"), ")")

  debug(" ")
  debug("--- Voltage Window ---")
  if ocr_voltage_35_36
    debug("[INFO] 3.5-3.6V:             Supported")
  if ocr_voltage_34_35
    debug("[INFO] 3.4-3.5V:             Supported")
  if ocr_voltage_33_34
    debug("[INFO] 3.3-3.4V:             Supported")
  if ocr_voltage_32_33
    debug("[INFO] 3.2-3.3V:             Supported")
  if ocr_voltage_31_32
    debug("[INFO] 3.1-3.2V:             Supported")
  if ocr_voltage_30_31
    debug("[INFO] 3.0-3.1V:             Supported")
  if ocr_voltage_29_30
    debug("[INFO] 2.9-3.0V:             Supported")
  if ocr_voltage_28_29
    debug("[INFO] 2.8-2.9V:             Supported")
  if ocr_voltage_27_28
    debug("[INFO] 2.7-2.8V:             Supported")

' ============================================================
' SCR PARSING AND DISPLAY
' ============================================================

PRI parseSCR()
  '' Parse all SCR register fields
  '' SCR structure (64 bits = 8 bytes)

  ' SCR_STRUCTURE [63:60]
  scr_structure := (scr_buf[0] >> 4) & $0F

  ' SD_SPEC [59:56]
  scr_sd_spec := scr_buf[0] & $0F

  ' DATA_STAT_AFTER_ERASE [55]
  scr_data_stat_after_erase := (scr_buf[1] >> 7) & 1

  ' SD_SECURITY [54:52]
  scr_sd_security := (scr_buf[1] >> 4) & $07

  ' SD_BUS_WIDTHS [51:48]
  scr_sd_bus_widths := scr_buf[1] & $0F

  ' SD_SPEC3 [47]
  scr_sd_spec3 := (scr_buf[2] >> 7) & 1

  ' EX_SECURITY [46:43]
  scr_ex_security := (scr_buf[2] >> 3) & $0F

  ' SD_SPEC4 [42]
  scr_sd_spec4 := (scr_buf[2] >> 2) & 1

  ' SD_SPECX [41:38]
  scr_sd_specx := ((scr_buf[2] & $03) << 2) | ((scr_buf[3] >> 6) & $03)

  ' CMD_SUPPORT [33:32]
  scr_cmd_support := scr_buf[4] & $03

PRI displaySCR() | sd_version
  debug(" ")
  debug("======== SCR REGISTER (SD Configuration) ========")
  debug(" ")

  debug("[INFO] SCR_STRUCTURE:        ", udec_(scr_structure), " (SCR Version ", udec_(scr_structure + 1), ".0)")

  ' Determine SD Physical Layer version
  debug("[USED] SD_SPEC:              ", udec_(scr_sd_spec))
  if scr_sd_spec == 0
    debug("       SD Version:           1.0 or 1.01")
  elseif scr_sd_spec == 1
    debug("       SD Version:           1.10")
  elseif scr_sd_spec == 2
    if scr_sd_spec4
      debug("       SD Version:           4.xx")
    elseif scr_sd_spec3
      debug("       SD Version:           3.0x")
    else
      debug("       SD Version:           2.00")
  elseif scr_sd_spec == 3
    debug("       SD Version:           3.0x")

  debug("[INFO] SD_SPEC3:             ", udec_(scr_sd_spec3), " (SD 3.0 support: ", zstr_(scr_sd_spec3 ? @"Yes" : @"No"), ")")
  debug("[INFO] SD_SPEC4:             ", udec_(scr_sd_spec4), " (SD 4.0 support: ", zstr_(scr_sd_spec4 ? @"Yes" : @"No"), ")")
  debug("[INFO] SD_SPECX:             ", udec_(scr_sd_specx), " (SD 5.x/6.x/7.x indicator)")

  debug(" ")
  debug("--- Bus Width Support ---")
  debug("[INFO] SD_BUS_WIDTHS:        $", uhex_byte_(scr_sd_bus_widths))
  if scr_sd_bus_widths & $01
    debug("       1-bit bus:            Supported (SPI mode uses this)")
  if scr_sd_bus_widths & $04
    debug("       4-bit bus:            Supported")

  debug(" ")
  debug("--- Security ---")
  debug("[INFO] SD_SECURITY:          ", udec_(scr_sd_security))
  case scr_sd_security
    0: debug("       Security:             No security")
    1: debug("       Security:             Not used")
    2: debug("       Security:             SDSC Card (security v1.01)")
    3: debug("       Security:             SDHC Card (security v2.00)")
    4: debug("       Security:             SDXC Card (security v3.xx)")
    other: debug("       Security:             Reserved")

  debug("[INFO] EX_SECURITY:          ", udec_(scr_ex_security))

  debug(" ")
  debug("--- Command Support ---")
  debug("[INFO] CMD_SUPPORT:          $", uhex_byte_(scr_cmd_support))
  if scr_cmd_support & $01
    debug("       CMD20 (Speed Class):  Supported")
  if scr_cmd_support & $02
    debug("       CMD23 (Set Block Cnt):Supported")

  debug(" ")
  debug("[INFO] DATA_STAT_AFTER_ERASE:", udec_(scr_data_stat_after_erase))

' ============================================================
' RAW REGISTERS DISPLAY
' ============================================================

PRI displayRawRegisters() | i
  debug(" ")
  debug("======== RAW REGISTER DATA ========")
  debug(" ")

  ' CID (16 bytes)
  debug("CID: ", uhex_byte_(cid_buf[0]), " ", uhex_byte_(cid_buf[1]), " ", uhex_byte_(cid_buf[2]), " ", uhex_byte_(cid_buf[3]), " ", uhex_byte_(cid_buf[4]), " ", uhex_byte_(cid_buf[5]), " ", uhex_byte_(cid_buf[6]), " ", uhex_byte_(cid_buf[7]), " ", uhex_byte_(cid_buf[8]), " ", uhex_byte_(cid_buf[9]), " ", uhex_byte_(cid_buf[10]), " ", uhex_byte_(cid_buf[11]), " ", uhex_byte_(cid_buf[12]), " ", uhex_byte_(cid_buf[13]), " ", uhex_byte_(cid_buf[14]), " ", uhex_byte_(cid_buf[15]))

  ' CSD (16 bytes)
  debug("CSD: ", uhex_byte_(csd_buf[0]), " ", uhex_byte_(csd_buf[1]), " ", uhex_byte_(csd_buf[2]), " ", uhex_byte_(csd_buf[3]), " ", uhex_byte_(csd_buf[4]), " ", uhex_byte_(csd_buf[5]), " ", uhex_byte_(csd_buf[6]), " ", uhex_byte_(csd_buf[7]), " ", uhex_byte_(csd_buf[8]), " ", uhex_byte_(csd_buf[9]), " ", uhex_byte_(csd_buf[10]), " ", uhex_byte_(csd_buf[11]), " ", uhex_byte_(csd_buf[12]), " ", uhex_byte_(csd_buf[13]), " ", uhex_byte_(csd_buf[14]), " ", uhex_byte_(csd_buf[15]))

  ' OCR (4 bytes)
  debug("OCR: $", uhex_long_(ocr_val))

  ' SCR (8 bytes)
  debug("SCR: ", uhex_byte_(scr_buf[0]), " ", uhex_byte_(scr_buf[1]), " ", uhex_byte_(scr_buf[2]), " ", uhex_byte_(scr_buf[3]), " ", uhex_byte_(scr_buf[4]), " ", uhex_byte_(scr_buf[5]), " ", uhex_byte_(scr_buf[6]), " ", uhex_byte_(scr_buf[7]))

' ============================================================
' VBR/FILESYSTEM PARSING AND DISPLAY
' ============================================================

PRI findAndReadVBR() | mbr_buf[128], vbr_sector, type_code

  debug(" ")
  debug("======== FILESYSTEM INFORMATION ========")
  debug(" ")

  ' Read MBR (sector 0)
  sd.readSectorRaw(0, @mbr_buf)

  ' Get partition type code from MBR at offset 0x1C2
  type_code := BYTE[@mbr_buf + $1C2]
  debug("MBR Partition Type:          $", uhex_byte_(type_code))

  if type_code == $0B or type_code == $0C
    debug("                             FAT32 (", zstr_(type_code == $0C ? @"LBA" : @"CHS"), ")")
  elseif type_code == $07
    debug("                             exFAT/NTFS")
  elseif type_code == $06
    debug("                             FAT16")
  else
    debug("                             Unknown type")

  if type_code <> $0B and type_code <> $0C
    debug("NOTE: Not FAT32 - VBR parsing skipped")
    return

  ' Get VBR sector from MBR at offset 0x1C6
  vbr_sector := LONG[@mbr_buf + $1C6]
  debug("VBR at sector:               ", udec_(vbr_sector))

  ' Read VBR
  sd.readSectorRaw(vbr_sector, @vbr_buf)

PRI parseVBR() | i
  '' Parse VBR/BPB fields

  ' OEM Name at offset 0x03 (8 bytes)
  bytemove(@vbr_oem_name, @vbr_buf + $03, 8)
  vbr_oem_name[8] := 0

  ' Bytes per sector at offset 0x0B (16-bit)
  vbr_bytes_per_sec := WORD[@vbr_buf + $0B]

  ' Sectors per cluster at offset 0x0D (8-bit)
  vbr_sec_per_clus := vbr_buf[$0D]

  ' Reserved sectors at offset 0x0E (16-bit)
  vbr_reserved_sec := WORD[@vbr_buf + $0E]

  ' Number of FATs at offset 0x10 (8-bit)
  vbr_num_fats := vbr_buf[$10]

  ' Total sectors (32-bit) at offset 0x20
  vbr_total_sectors := LONG[@vbr_buf + $20]

  ' Sectors per FAT (32-bit) at offset 0x24
  vbr_sec_per_fat := LONG[@vbr_buf + $24]

  ' Root cluster at offset 0x2C (32-bit)
  vbr_root_cluster := LONG[@vbr_buf + $2C]

  ' Volume serial at offset 0x43 (32-bit)
  vbr_volume_serial := LONG[@vbr_buf + $43]

  ' Volume label at offset 0x47 (11 bytes)
  bytemove(@vbr_volume_label, @vbr_buf + $47, 11)
  vbr_volume_label[11] := 0

  ' FS type string at offset 0x52 (8 bytes)
  bytemove(@vbr_fs_type, @vbr_buf + $52, 8)
  vbr_fs_type[8] := 0

PRI displayVBR() | cluster_size, data_region, total_clusters
  if vbr_bytes_per_sec == 0
    return  ' VBR not read

  debug(" ")
  debug("--- FAT32 Filesystem ---")
  debug("OEM Name:                    [", zstr_(@vbr_oem_name), "]")
  debug("Volume Label:                [", zstr_(@vbr_volume_label), "]")
  debug("Volume Serial:               $", uhex_long_(vbr_volume_serial))
  debug("FS Type:                     [", zstr_(@vbr_fs_type), "]")
  debug("Bytes/Sector:                ", udec_(vbr_bytes_per_sec))

  cluster_size := vbr_sec_per_clus * vbr_bytes_per_sec
  if cluster_size >= 1024
    debug("Sectors/Cluster:             ", udec_(vbr_sec_per_clus), " (", udec_(cluster_size / 1024), " KB clusters)")
  else
    debug("Sectors/Cluster:             ", udec_(vbr_sec_per_clus), " (", udec_(cluster_size), " byte clusters)")

  debug("Reserved Sectors:            ", udec_(vbr_reserved_sec))
  debug("Number of FATs:              ", udec_(vbr_num_fats))
  debug("Sectors per FAT:             ", udec_(vbr_sec_per_fat))
  debug("Root Cluster:                ", udec_(vbr_root_cluster))
  debug("Total Sectors:               ", udec_(vbr_total_sectors))

  ' Calculate data region start
  data_region := vbr_reserved_sec + (vbr_num_fats * vbr_sec_per_fat)
  debug("Data Region Start:           Sector ", udec_(data_region))

  ' Calculate total clusters
  if vbr_sec_per_clus > 0
    total_clusters := (vbr_total_sectors - data_region) / vbr_sec_per_clus
    debug("Total Clusters:              ", udec_(total_clusters))

' ============================================================
' UNIQUE CARD ID GENERATION
' ============================================================

PRI generateCardID() | p_dst, p_mfr, i, c

  p_dst := @card_id_str

  ' Manufacturer name (replace spaces with nothing)
  p_mfr := lookupManufacturer(cid_mid)
  repeat while (c := BYTE[p_mfr++]) <> 0
    if c <> " "
      BYTE[p_dst++] := c

  BYTE[p_dst++] := "_"

  ' Product name (trim spaces)
  repeat i from 0 to 4
    c := cid_pnm[i]
    if c <> " " and c <> 0
      BYTE[p_dst++] := c

  BYTE[p_dst++] := "_"

  ' Revision (n.m format)
  BYTE[p_dst++] := cid_prv_major + "0"
  BYTE[p_dst++] := "."
  BYTE[p_dst++] := cid_prv_minor + "0"

  BYTE[p_dst++] := "_"

  ' Serial number (8 hex digits)
  p_dst := hexLong(p_dst, cid_psn)

  BYTE[p_dst++] := "_"

  ' Manufacturing date (YYYYMM)
  p_dst := decWord(p_dst, cid_mdt_year)
  if cid_mdt_month < 10
    BYTE[p_dst++] := "0"
  p_dst := decByte(p_dst, cid_mdt_month)

  ' Null terminate
  BYTE[p_dst] := 0

PRI hexLong(p_dst, val) : p_out | i, nibble
  repeat i from 7 to 0
    nibble := (val >> (i * 4)) & $0F
    if nibble < 10
      BYTE[p_dst++] := nibble + "0"
    else
      BYTE[p_dst++] := nibble - 10 + "A"
  return p_dst

PRI decWord(p_dst, val) : p_out | digits[5], i, started
  repeat i from 0 to 4
    digits[i] := val // 10
    val := val / 10
  started := false
  repeat i from 4 to 0
    if digits[i] <> 0 or started or i == 0
      BYTE[p_dst++] := digits[i] + "0"
      started := true
  return p_dst

PRI decByte(p_dst, val) : p_out | digits[3], i, started
  repeat i from 0 to 2
    digits[i] := val // 10
    val := val / 10
  started := false
  repeat i from 2 to 0
    if digits[i] <> 0 or started or i == 0
      BYTE[p_dst++] := digits[i] + "0"
      started := true
  return p_dst

PRI displayCardID()
  debug(" ")
  debug("##############################################")
  debug("  UNIQUE CARD ID: ", zstr_(@card_id_str))
  debug("##############################################")

' ============================================================
' DRIVER USAGE SUMMARY
' ============================================================

PRI displayDriverUsage()
  debug(" ")
  debug("======== V3 DRIVER USAGE SUMMARY ========")
  debug(" ")
  debug("Fields marked [USED] are actively used by the driver:")
  debug(" ")
  debug("CID Register:")
  debug("  - MID: Determines PNY cards (20MHz limit) vs others (25MHz)")
  debug(" ")
  debug("CSD Register:")
  debug("  - CSD_STRUCTURE: Determines SDSC vs SDHC/SDXC formulas")
  debug("  - TRAN_SPEED: Calculates maximum SPI clock frequency")
  debug("  - TAAC/NSAC/R2W_FACTOR: Calculates timeouts (SDSC only)")
  debug("  - C_SIZE + multipliers: Calculates card capacity")
  debug(" ")
  debug("SCR Register:")
  debug("  - SD_SPEC: Determines CMD6 (High Speed) support")
  debug(" ")
  debug("OCR Register:")
  debug("  - CCS bit: CRITICAL - determines addressing mode")
  debug("    CCS=0: SDSC byte addressing (sector << 9)")
  debug("    CCS=1: SDHC/SDXC block addressing (sector)")

CON {{
┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                                   TERMS OF USE: MIT License                                                  │
├──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation    │
│files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,    │
│modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software│
│is furnished to do so, subject to the following conditions:                                                                   │
│                                                                                                                              │
│The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.│
│                                                                                                                              │
│THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE          │
│WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR         │
│COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,   │
│ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                         │
└──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
}}
