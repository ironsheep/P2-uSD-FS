'' =================================================================================================
''
''   File....... SD_format_utility_v2.spin2
''   Purpose.... FAT32 format utility for SD cards using the SD_card_driver_v2
''   Author..... Stephen M Moraco
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... JAN 2026
''   Updated.... 16 JAN 2026
''
'' =================================================================================================
''
''  This utility formats an SD card with a FAT32 filesystem.
''
''  USAGE:
''    fmt.format(cs, mosi, miso, sck)                    ' Format with default label "P2-XFER"
''    fmt.formatWithLabel(cs, mosi, miso, sck, @"MYCARD")  ' Format with custom label (max 11 chars)
''
''  WARNING: This will ERASE ALL DATA on the card!
''
'' =================================================================================================

CON

    DEBUG_DISABLE = 1   ' Disable debug in this file to reduce debug record count

    ' FAT32 constants
    BYTES_PER_SECTOR    = 512
    RESERVED_SECTORS    = 32        ' Standard for FAT32
    NUM_FATS            = 2         ' Always 2 for FAT32 compliance
    ROOT_CLUSTER        = 2         ' Root directory starts at cluster 2

    ' MBR constants
    MBR_SIGNATURE       = $AA55
    PARTITION_TYPE_FAT32_LBA = $0C  ' FAT32 with LBA

    ' FAT32 special values
    FAT32_EOC           = $0FFFFFFF ' End of chain marker
    FAT32_MEDIA_TYPE    = $0FFFFFF8 ' Media descriptor in FAT[0]

    ' FSInfo signatures
    FSINFO_SIG1         = $41615252 ' "RRaA"
    FSINFO_SIG2         = $61417272 ' "rrAa"
    FSINFO_SIG3         = $AA550000

    ' Volume label (11 chars, space padded) - "P2-XFER    "
    DEFAULT_LABEL_0     = $58_2D_32_50  ' "P2-X" (little endian: P, 2, -, X)
    DEFAULT_LABEL_1     = $20_52_45_46  ' "FER " (little endian: F, E, R, space)
    DEFAULT_LABEL_2     = $00_20_20_20  ' "   " + null (spaces to pad to 11)

OBJ

    sd : "SD_card_driver_v2"                ' Use V2 driver with smart pins for formatting

VAR

    ' Pin configuration
    LONG    pinCS, pinMOSI, pinMISO, pinSCK

    ' Sector buffer
    BYTE    buf[BYTES_PER_SECTOR]

    ' Card geometry
    LONG    totalSectors
    LONG    sectorsPerCluster
    LONG    sectorsPerFat
    LONG    dataSectors
    LONG    totalClusters
    LONG    partitionStart      ' LBA of partition start (VBR)
    LONG    fat1Start           ' LBA of first FAT
    LONG    fat2Start           ' LBA of second FAT
    LONG    dataStart           ' LBA of data area

    ' Volume label (12 bytes: 11 chars + null)
    BYTE    volumeLabel[12]

PUB format(cs, mosi, miso, sck) : result
'' Format the SD card with default volume label "P2-XFER"
''
'' @param cs   - Chip Select pin number
'' @param mosi - Master Out Slave In pin number
'' @param miso - Master In Slave Out pin number
'' @param sck  - Serial Clock pin number
'' @returns TRUE if successful, FALSE if failed

    pinCS := cs
    pinMOSI := mosi
    pinMISO := miso
    pinSCK := sck
    setDefaultLabel()
    result := doFormat()

PUB formatWithLabel(cs, mosi, miso, sck, pLabel) : result | i, ch
'' Format the SD card with a custom volume label
''
'' @param cs     - Chip Select pin number
'' @param mosi   - Master Out Slave In pin number
'' @param miso   - Master In Slave Out pin number
'' @param sck    - Serial Clock pin number
'' @param pLabel - pointer to null-terminated string (max 11 chars)
'' @returns TRUE if successful, FALSE if failed

    pinCS := cs
    pinMOSI := mosi
    pinMISO := miso
    pinSCK := sck

    ' Copy and pad label to 11 characters
    bytefill(@volumeLabel, " ", 11)
    volumeLabel[11] := 0

    i := 0
    repeat while i < 11
        ch := BYTE[pLabel][i]
        if ch == 0
            quit
        ' Convert to uppercase for FAT compatibility
        if ch >= "a" and ch <= "z"
            ch -= 32
        volumeLabel[i] := ch
        i++

    result := doFormat()

PRI setDefaultLabel()
    ' Set default label "P2-XFER    " (11 chars, space padded)
    LONG[@volumeLabel][0] := DEFAULT_LABEL_0
    LONG[@volumeLabel][1] := DEFAULT_LABEL_1
    BYTE[@volumeLabel][8] := " "
    BYTE[@volumeLabel][9] := " "
    BYTE[@volumeLabel][10] := " "
    volumeLabel[11] := 0

PRI doFormat() : result | i
    debug("==============================================")
    debug("  SD Card FAT32 Formatter")
    debug("  Volume Label: [", zstr_(@volumeLabel), "]")
    debug("==============================================")
    debug(" ")

    ' Initialize card (low-level, no filesystem mount)
    debug("* Initializing SD card...")
    result := sd.initCardOnly(pinCS, pinMOSI, pinMISO, pinSCK)
    if result == false
        debug("ERROR: Could not initialize SD card!")
        return false

    ' Get card size
    debug("* Reading card size...")
    totalSectors := sd.cardSizeSectors()
    if totalSectors == 0
        debug("ERROR: Could not read card size!")
        return false

    debug("  Total sectors: ", udec_(totalSectors))
    debug("  Card size: ", udec_(totalSectors / 2048), " MB")

    ' Calculate filesystem parameters
    debug("* Calculating filesystem parameters...")
    if not calculateParameters()
        debug("ERROR: Card too small for FAT32!")
        return false

    debug("  Sectors/cluster: ", udec_(sectorsPerCluster))
    debug("  Sectors/FAT: ", udec_(sectorsPerFat))
    debug("  Total clusters: ", udec_(totalClusters))
    debug("  Partition start: ", udec_(partitionStart))
    debug("  FAT1 start: ", udec_(fat1Start))
    debug("  FAT2 start: ", udec_(fat2Start))
    debug("  Data start: ", udec_(dataStart))

    ' Write MBR
    debug(" ")
    debug("* Writing MBR...")
    if not writeMBR()
        debug("ERROR: Failed to write MBR!")
        return false

    ' Write VBR (Volume Boot Record)
    debug("* Writing VBR...")
    if not writeVBR()
        debug("ERROR: Failed to write VBR!")
        return false

    ' Write FSInfo sector
    debug("* Writing FSInfo...")
    if not writeFSInfo()
        debug("ERROR: Failed to write FSInfo!")
        return false

    ' Write backup boot sector (sector 6 of partition)
    debug("* Writing backup boot sector...")
    if not writeBackupBoot()
        debug("ERROR: Failed to write backup boot!")
        return false

    ' Initialize FAT tables
    debug("* Initializing FAT1...")
    if not initFAT(fat1Start)
        debug("ERROR: Failed to initialize FAT1!")
        return false

    debug("* Initializing FAT2...")
    if not initFAT(fat2Start)
        debug("ERROR: Failed to initialize FAT2!")
        return false

    ' Initialize root directory
    debug("* Initializing root directory...")
    if not initRootDirectory()
        debug("ERROR: Failed to initialize root directory!")
        return false

    debug(" ")
    debug("==============================================")
    debug("  FORMAT COMPLETE")
    debug("  Volume: [", zstr_(@volumeLabel), "]")
    debug("  Size: ", udec_(totalSectors / 2048), " MB")
    debug("  Clusters: ", udec_(totalClusters))
    debug("==============================================")

    return true

PRI calculateParameters() : success | clusterSize
    ' Partition starts at sector 8192 (4MB aligned for modern cards)
    partitionStart := 8192

    ' Calculate data sectors available
    dataSectors := totalSectors - partitionStart

    ' Determine sectors per cluster based on volume size
    ' Microsoft recommends:
    '   <= 8GB:   8 sectors (4KB clusters)
    '   <= 16GB: 16 sectors (8KB clusters)
    '   <= 32GB: 32 sectors (16KB clusters)
    '   > 32GB:  64 sectors (32KB clusters)

    if dataSectors <= 16_777_216        ' <= 8GB
        sectorsPerCluster := 8
    elseif dataSectors <= 33_554_432    ' <= 16GB
        sectorsPerCluster := 16
    elseif dataSectors <= 67_108_864    ' <= 32GB
        sectorsPerCluster := 32
    else
        sectorsPerCluster := 64

    ' Calculate sectors per FAT
    ' Formula: sectorsPerFat = (dataSectors - RESERVED) / (clusterSize * 2 / 4 + NUM_FATS)
    ' Simplified approximation that works well:
    totalClusters := (dataSectors - RESERVED_SECTORS) / sectorsPerCluster
    sectorsPerFat := (totalClusters * 4 + BYTES_PER_SECTOR - 1) / BYTES_PER_SECTOR

    ' Recalculate actual data area
    fat1Start := partitionStart + RESERVED_SECTORS
    fat2Start := fat1Start + sectorsPerFat
    dataStart := fat2Start + sectorsPerFat

    ' Recalculate total clusters with actual layout
    dataSectors := totalSectors - dataStart
    totalClusters := dataSectors / sectorsPerCluster

    ' FAT32 requires at least 65525 clusters
    if totalClusters < 65525
        return false

    return true

PRI writeMBR() : success | partitionSectors
    ' Clear buffer
    bytefill(@buf, 0, BYTES_PER_SECTOR)

    ' Partition table entry at offset $1BE (446)
    partitionSectors := totalSectors - partitionStart

    buf[$1BE] := $00                    ' Boot indicator (not bootable)
    buf[$1BF] := $00                    ' Starting head (CHS - ignored for LBA)
    buf[$1C0] := $00                    ' Starting sector (CHS)
    buf[$1C1] := $00                    ' Starting cylinder (CHS)
    buf[$1C2] := PARTITION_TYPE_FAT32_LBA  ' Partition type
    buf[$1C3] := $FE                    ' Ending head (CHS)
    buf[$1C4] := $FF                    ' Ending sector (CHS)
    buf[$1C5] := $FF                    ' Ending cylinder (CHS)

    ' Partition start LBA (little endian)
    LONG[@buf + $1C6] := partitionStart

    ' Partition size in sectors (little endian)
    LONG[@buf + $1CA] := partitionSectors

    ' MBR signature
    WORD[@buf + $1FE] := MBR_SIGNATURE

    ' Write MBR to sector 0
    success := sd.writeSectorRaw(0, @buf)

PRI writeVBR() : success | i
    ' Clear buffer
    bytefill(@buf, 0, BYTES_PER_SECTOR)

    ' Jump instruction
    buf[$00] := $EB
    buf[$01] := $58
    buf[$02] := $90

    ' OEM name (8 bytes)
    bytemove(@buf + $03, @"P2FMTER ", 8)

    ' BPB (BIOS Parameter Block)
    WORD[@buf + $0B] := BYTES_PER_SECTOR    ' Bytes per sector
    buf[$0D] := sectorsPerCluster           ' Sectors per cluster
    WORD[@buf + $0E] := RESERVED_SECTORS    ' Reserved sectors
    buf[$10] := NUM_FATS                    ' Number of FATs
    WORD[@buf + $11] := 0                   ' Root entries (0 for FAT32)
    WORD[@buf + $13] := 0                   ' Total sectors 16-bit (0 for FAT32)
    buf[$15] := $F8                         ' Media type (fixed disk)
    WORD[@buf + $16] := 0                   ' Sectors per FAT (16-bit, 0 for FAT32)
    WORD[@buf + $18] := 63                  ' Sectors per track (legacy)
    WORD[@buf + $1A] := 255                 ' Number of heads (legacy)
    LONG[@buf + $1C] := partitionStart      ' Hidden sectors (partition start)
    LONG[@buf + $20] := totalSectors - partitionStart  ' Total sectors 32-bit

    ' FAT32 extended BPB
    LONG[@buf + $24] := sectorsPerFat       ' Sectors per FAT (32-bit)
    WORD[@buf + $28] := 0                   ' Flags
    WORD[@buf + $2A] := 0                   ' Version
    LONG[@buf + $2C] := ROOT_CLUSTER        ' Root cluster
    WORD[@buf + $30] := 1                   ' FSInfo sector
    WORD[@buf + $32] := 6                   ' Backup boot sector
    ' Bytes $34-$3F reserved (already 0)

    buf[$40] := $80                         ' Drive number
    buf[$41] := 0                           ' Reserved
    buf[$42] := $29                         ' Extended boot signature
    LONG[@buf + $43] := getct()             ' Volume serial number (random)

    ' Volume label (11 bytes)
    bytemove(@buf + $47, @volumeLabel, 11)

    ' File system type (8 bytes)
    bytemove(@buf + $52, @"FAT32   ", 8)

    ' Boot signature
    WORD[@buf + $1FE] := MBR_SIGNATURE

    ' Write VBR to partition start
    success := sd.writeSectorRaw(partitionStart, @buf)

PRI writeFSInfo() : success
    ' Clear buffer
    bytefill(@buf, 0, BYTES_PER_SECTOR)

    ' FSInfo signatures
    LONG[@buf + $000] := FSINFO_SIG1        ' Lead signature
    LONG[@buf + $1E4] := FSINFO_SIG2        ' Structure signature
    LONG[@buf + $1E8] := totalClusters - 1  ' Free cluster count
    LONG[@buf + $1EC] := 3                  ' Next free cluster hint
    LONG[@buf + $1FC] := FSINFO_SIG3        ' Trail signature (includes $AA55)

    ' Write FSInfo to sector 1 of partition
    success := sd.writeSectorRaw(partitionStart + 1, @buf)

PRI writeBackupBoot() : success
    ' Re-create VBR in buffer
    writeVBR()

    ' Write to sector 6 of partition (backup VBR location)
    if not sd.writeSectorRaw(partitionStart + 6, @buf)
        return false

    ' Write backup FSInfo to sector 7
    writeFSInfo()
    success := sd.writeSectorRaw(partitionStart + 7, @buf)

PRI initFAT(fatStart) : success | sector, i
    ' Clear buffer
    bytefill(@buf, 0, BYTES_PER_SECTOR)

    ' First sector of FAT has special entries
    LONG[@buf + 0] := FAT32_MEDIA_TYPE      ' FAT[0] - media type
    LONG[@buf + 4] := FAT32_EOC             ' FAT[1] - end of chain marker
    LONG[@buf + 8] := FAT32_EOC             ' FAT[2] - root directory (end of chain)

    ' Write first FAT sector
    if not sd.writeSectorRaw(fatStart, @buf)
        return false

    ' Clear buffer for remaining sectors
    bytefill(@buf, 0, BYTES_PER_SECTOR)

    ' Write remaining FAT sectors (all zeros = free clusters)
    repeat sector from 1 to sectorsPerFat - 1
        if not sd.writeSectorRaw(fatStart + sector, @buf)
            return false
        ' Progress indicator every 256 sectors
        if (sector & $FF) == 0
            debug("  Progress: ", udec_(sector), "/", udec_(sectorsPerFat))

    return true

PRI initRootDirectory() : success | i
    ' Clear buffer
    bytefill(@buf, 0, BYTES_PER_SECTOR)

    ' Create volume label directory entry at offset 0
    ' Filename (11 bytes) = volume label
    bytemove(@buf, @volumeLabel, 11)

    ' Attributes = $08 (volume label)
    buf[$0B] := $08

    ' Creation time/date (use some default)
    WORD[@buf + $0E] := $0000   ' Creation time
    WORD[@buf + $10] := $0021   ' Creation date (1980-01-01)
    WORD[@buf + $12] := $0021   ' Access date
    WORD[@buf + $14] := $0000   ' High word of cluster (0)
    WORD[@buf + $16] := $0000   ' Modification time
    WORD[@buf + $18] := $0021   ' Modification date
    WORD[@buf + $1A] := $0000   ' Low word of cluster (0)
    LONG[@buf + $1C] := 0       ' File size (0 for volume label)

    ' Write first sector of root directory
    if not sd.writeSectorRaw(dataStart, @buf)
        return false

    ' Clear remaining sectors of root cluster
    bytefill(@buf, 0, BYTES_PER_SECTOR)
    repeat i from 1 to sectorsPerCluster - 1
        if not sd.writeSectorRaw(dataStart + i, @buf)
            return false

    return true

CON { license }

{{
  =================================================================================================

  Terms of Use: MIT License

  Copyright (c) 2026 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  =================================================================================================
}}
