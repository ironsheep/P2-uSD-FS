{{┌──────────────────────────────────────────┐
  │ SD card driver                           │  Verified with Panasonic 512MB SD
  │ Author: Chris Gadd                       │                PNY 8GB SDHC
  │ Copyright (c) 2023 Chris Gadd            │                SanDisk Extreme 32GB SDHC                                       3V3
  │ See end of file for terms of use.        │                GSKILL 32GB Micro SDHC                                              ┌─────┐
  └──────────────────────────────────────────┘  cards must be formatted as FAT32                                               │   ┤ Read / write        ├─────┐
                                                                                                                             ─┼───┤ CS                  │     │
  sd.mount(CS,MOSI,MISO,SCK)                            ' mount SD card                                                      ─┼───┤ MOSI                │     │
  sd.newDirectory(string("folder1"))                    ' create a new directory                                               │ ┌─┤ Gnd                 │     │
  sd.changeDirectory(string("folder1"))                 ' switch to newly created directory                                    └─┼─┤ Vcc                 │     │
  sd.newFile(string("fileA.txt"))                       ' create a new file, leaves file open for writing                    ───┼─┤ SCK                 │     │
  sd.writeString(string("this is file A"))              ' write to newly created file                                            ┣─┤ Gnd                 │     │
  sd.closeFile()                                        ' close file, update filesize information                            ───┼─┤ MISO                │     │
                                                                                                                                 │ ┤ IRQ                 │     │
  sd.openFile(string("fileA.txt"))                      ' open file in current directory                                         │ ┤ Card detect         │     │
  -or-                                                  ' -or-                                                                   │ ┤ Write protect       ├─────┘
  sd.openFile(string("/folder1/fileA.txt"))             ' open file from path (1st "/" resets directory to root)                 │ └─┳───────────────────┘
  sd.read(@buffer,sd.fileSize())                        ' read opened file into buffer                                              
  debug(zstr(@buffer))
}}
CON  '' flags
  F_OPEN    = decod 0
  F_NEWDIR  = decod 1
  F_NEWDATA = decod 2
  F_MOUNTED = decod 3

CON '' command codes for worker cog
  CMD_NONE      = 0         ' Idle / command complete
  CMD_MOUNT     = 1         ' Mount filesystem
  CMD_UNMOUNT   = 2         ' Unmount filesystem
  CMD_OPEN      = 3         ' Open file: param0=filename ptr
  CMD_CLOSE     = 4         ' Close file
  CMD_READ      = 5         ' Read: param0=buffer ptr, param1=count
  CMD_WRITE     = 6         ' Write: param0=buffer ptr, param1=count
  CMD_SEEK      = 7         ' Seek: param0=position
  CMD_NEWFILE   = 8         ' Create new file: param0=filename ptr
  CMD_NEWDIR    = 9         ' Create new directory: param0=dirname ptr
  CMD_DELETE    = 10        ' Delete file: param0=filename ptr
  CMD_RENAME    = 11        ' Rename: param0=oldname, param1=newname
  CMD_CHDIR     = 12        ' Change directory: param0=dirname ptr
  CMD_READDIR   = 13        ' Read directory entry: param0=index
  CMD_FILESIZE  = 14        ' Get file size
  CMD_FREESPACE = 15        ' Get free space
  CMD_SYNC      = 16        ' Flush buffers
  CMD_MOVEFILE  = 17        ' Move file: param0=name, param1=dest folder

CON '' error codes
  SUCCESS           = 0
  E_TIMEOUT         = -1        ' Card didn't respond in time
  E_NO_RESPONSE     = -2        ' Card not responding
  E_BAD_RESPONSE    = -3        ' Unexpected response from card
  E_CRC_ERROR       = -4        ' Data CRC mismatch
  E_WRITE_REJECTED  = -5        ' Card rejected write operation
  E_CARD_BUSY       = -6        ' Card busy
  E_NOT_MOUNTED     = -20       ' Filesystem not mounted
  E_INIT_FAILED     = -21       ' Card initialization failed
  E_NOT_FAT32       = -22       ' Card not formatted as FAT32
  E_BAD_SECTOR_SIZE = -23       ' Sector size not 512 bytes
  E_FILE_NOT_FOUND  = -40       ' File doesn't exist
  E_FILE_EXISTS     = -41       ' File already exists
  E_NOT_A_FILE      = -42       ' Expected file, found directory
  E_NOT_A_DIR       = -43       ' Expected directory, found file
  E_FILE_NOT_OPEN   = -45       ' File not open
  E_END_OF_FILE     = -46       ' Read past end of file
  E_DISK_FULL       = -60       ' No free clusters
  E_NO_LOCK         = -64       ' Couldn't allocate hardware lock

CON '' worker cog stack size
  STACK_SIZE = 128              ' 128 longs = 512 bytes

DAT '' singleton control - SHARED across all object instances
  ' ═══════════════════════════════════════════════════════════════════════
  ' SINGLETON CONTROL - Must be initialized to "not started" state
  ' ═══════════════════════════════════════════════════════════════════════
  cog_id        LONG    -1              ' Worker cog ID (-1 = not started)
  api_lock      LONG    -1              ' Hardware lock ID (-1 = not allocated)

  ' ═══════════════════════════════════════════════════════════════════════
  ' PARAMETER BLOCK - Communication between API and worker cog
  ' ═══════════════════════════════════════════════════════════════════════
  pb_cmd        LONG    0               ' Command (0 = idle/done)
  pb_status     LONG    0               ' Result status code
  pb_caller     LONG    0               ' Caller's cog ID (for COGATN signal)
  pb_param0     LONG    0               ' Parameter 0 (varies by command)
  pb_param1     LONG    0               ' Parameter 1
  pb_param2     LONG    0               ' Parameter 2
  pb_param3     LONG    0               ' Parameter 3
  pb_data0      LONG    0               ' Result data 0 (handle, count, etc.)
  pb_data1      LONG    0               ' Result data 1

  ' ═══════════════════════════════════════════════════════════════════════
  ' WORKER COG STACK
  ' ═══════════════════════════════════════════════════════════════════════
  cog_stack     LONG    0[STACK_SIZE]   ' Worker cog stack

  ' ═══════════════════════════════════════════════════════════════════════
  ' SPI PIN CONFIGURATION (set once at start)
  ' ═══════════════════════════════════════════════════════════════════════
  cs            LONG    0               ' Chip select pin
  mosi          LONG    0               ' Master out, slave in pin
  miso          LONG    0               ' Master in, slave out pin
  sck           LONG    0               ' Serial clock pin

  ' ═══════════════════════════════════════════════════════════════════════
  ' FILESYSTEM STATE (moved from VAR)
  ' ═══════════════════════════════════════════════════════════════════════
  fat_sec       LONG    0               ' Starting sector of FAT
  fat2_sec      LONG    0               ' Starting sector of FAT2 (mirror)
  sec_per_fat   LONG    0               ' Sectors per FAT
  sec_per_clus  LONG    0               ' Sectors per cluster
  root_sec      LONG    0               ' Starting sector of root directory
  cluster_offset LONG   0               ' Cluster offset calculation
  dir_sec       LONG    0               ' Current directory sector
  entry_address LONG    0               ' Current entry byte address
  date_stamp    LONG    0               ' Timestamp for new files
  n_sec         LONG    0               ' Current sector number
  file_idx      LONG    0               ' Position within file
  flags         LONG    0               ' Open/new file flags
  sec_in_buf    LONG    0               ' Sector currently in buffer
  bit_delay     LONG    0               ' SPI bit delay
  hcs           LONG    0               ' High capacity support flag
  fsinfo_sec    LONG    0               ' FSInfo sector number
  fsi_free_count LONG   0               ' Cached free cluster count
  fsi_nxt_free  LONG    0               ' Cached next free cluster hint
  vbr_sec       LONG    0               ' Volume Boot Record sector
  ocr_value     LONG    0               ' Cached OCR register (from CMD58)

  ' ═══════════════════════════════════════════════════════════════════════
  ' PER-COG ERROR STORAGE (for thread-safe error reporting)
  ' ═══════════════════════════════════════════════════════════════════════
  last_error    LONG    0[8]            ' One slot per possible cog

  ' ═══════════════════════════════════════════════════════════════════════
  ' BUFFERS (must be in DAT for worker cog access)
  ' ═══════════════════════════════════════════════════════════════════════
  buf           BYTE    0[512]          ' Main sector buffer
  entry_buffer  BYTE    0[32]           ' Directory entry buffer
  vol_label     BYTE    0[12]           ' Volume label (11 chars + null)

PUB null()                                                                      '' not a top-level object

CON '' ═══════════════════════════════════════════════════════════════════════════
    '' MULTI-COG LIFECYCLE METHODS
    '' ═══════════════════════════════════════════════════════════════════════════

PUB start(_cs, _mosi, _miso, _sck) : result                                     '' Start worker cog (singleton)
  '' Initialize SD card driver and launch dedicated worker cog.
  '' This method is idempotent - calling multiple times is safe.
  '' Returns cog ID (0-7) on success, -1 on failure.
  ''
  '' @param _cs   - Chip select pin number
  '' @param _mosi - Master Out Slave In pin number
  '' @param _miso - Master In Slave Out pin number
  '' @param _sck  - Serial clock pin number

  ' Check if already started (singleton pattern)
  if cog_id <> -1
    debug("  [start] Already started (cog ", udec_(cog_id), ")")
    return cog_id

  ' Store pin configuration
  longmove(@cs, @_cs, 4)

  ' Allocate hardware lock for API serialization
  api_lock := locknew()
  if api_lock == -1
    debug("  [start] FAIL: Could not allocate lock")
    return set_error(E_NO_LOCK)

  ' Initialize parameter block
  pb_cmd := CMD_NONE
  pb_status := SUCCESS
  sec_in_buf := -1                                                              ' Invalidate buffer

  ' Launch worker cog
  cog_id := cogspin(NEWCOG, fs_worker(), @cog_stack)
  if cog_id == -1
    lockret(api_lock)
    api_lock := -1
    debug("  [start] FAIL: Could not start worker cog")
    return set_error(E_NO_LOCK)

  debug("  [start] Worker cog ", udec_(cog_id), " started, lock ", udec_(api_lock))
  return cog_id

PUB stop()                                                                      '' Stop worker cog
  '' Cleanly shut down the worker cog and release resources.
  '' Safe to call even if not started.

  if cog_id <> -1
    ' Send unmount command if mounted
    if flags & F_MOUNTED
      send_command(CMD_UNMOUNT, 0, 0, 0, 0)

    ' Stop the worker cog
    cogstop(cog_id)
    debug("  [stop] Worker cog ", udec_(cog_id), " stopped")
    cog_id := -1

  ' Release hardware lock
  if api_lock <> -1
    lockret(api_lock)
    api_lock := -1

  ' Clear state
  flags := 0
  sec_in_buf := -1

PUB error() : status                                                            '' Get last error for this cog
  '' Returns the error code from the most recent operation on this cog.
  '' Thread-safe: each cog has its own error slot.
  return LONG[@last_error][COGID()]

PRI set_error(code) : code_out                                                  '' Set error code for this cog
  '' Store error code in per-cog slot and return the code (for chained returns).
  LONG[@last_error][COGID()] := code
  return code

PRI fs_worker() | cur_cmd                                                       '' Worker cog main loop
  '' This method runs in the dedicated worker cog.
  '' It owns the SPI pins and handles all filesystem operations.

  debug("  [fs_worker] Starting on cog ", udec_(COGID()))

  ' Initialize SPI pins (this cog owns them)
  pinh(cs)                                                                      ' CS HIGH = deselected
  pinh(mosi)                                                                    ' MOSI HIGH idle
  pinl(sck)                                                                     ' SCK LOW (SPI mode 0)

  debug("  [fs_worker] Pins initialized: CS=P", udec_(cs), " MOSI=P", udec_(mosi), " MISO=P", udec_(miso), " SCK=P", udec_(sck))

  ' Main command loop
  repeat
    ' Wait for command (polling - will optimize to WAITATN later)
    repeat until (cur_cmd := pb_cmd) <> CMD_NONE

    debug("  [fs_worker] Received command ", udec_(cur_cmd))

    ' Dispatch command
    case cur_cmd
      CMD_MOUNT:
        pb_status := do_mount()

      CMD_UNMOUNT:
        pb_status := do_unmount()

      CMD_OPEN:
        pb_status := do_open(pb_param0)

      CMD_CLOSE:
        do_close()
        pb_status := SUCCESS

      CMD_READ:
        pb_data0 := do_read(pb_param0, pb_param1)
        pb_status := SUCCESS

      CMD_WRITE:
        do_write(pb_param0, pb_param1)
        pb_status := SUCCESS

      CMD_SEEK:
        pb_status := do_seek(pb_param0)

      CMD_NEWFILE:
        pb_status := do_newfile(pb_param0)

      CMD_NEWDIR:
        pb_status := do_newdir(pb_param0)

      CMD_DELETE:
        pb_status := do_delete(pb_param0)

      CMD_CHDIR:
        pb_status := do_chdir(pb_param0)

      CMD_FILESIZE:
        pb_data0 := fileSize()
        pb_status := SUCCESS

      CMD_FREESPACE:
        pb_data0 := do_freespace()
        pb_status := SUCCESS

      CMD_SYNC:
        do_sync()
        pb_status := SUCCESS

      CMD_RENAME:
        pb_status := do_rename(pb_param0, pb_param1)

      CMD_MOVEFILE:
        pb_status := do_movefile(pb_param0, pb_param1)

      CMD_READDIR:
        pb_status := do_readdir(pb_param0)

      other:
        debug("  [fs_worker] Unknown command: ", udec_(cur_cmd))
        pb_status := E_BAD_RESPONSE

    ' Signal completion
    pb_cmd := CMD_NONE
    COGATN(1 << pb_caller)                                                      ' Wake the caller

PRI send_command(op_cmd, p0, p1, p2, p3) : status                               '' Send command to worker and wait
  '' Acquire lock, send command to worker cog, wait for completion.
  '' Returns status code from worker.

  ' Verify worker cog is running
  if cog_id == -1
    debug("  [send_command] ERROR: Worker not running")
    return E_NOT_MOUNTED

  ' Acquire API lock (serialize multi-cog access)
  repeat until locktry(api_lock)

  ' Store caller ID and parameters
  pb_caller := COGID()
  pb_param0 := p0
  pb_param1 := p1
  pb_param2 := p2
  pb_param3 := p3

  ' Issue command (triggers worker)
  pb_cmd := op_cmd

  ' Wait for completion using WAITATN (efficient sleep)
  WAITATN()

  ' Get result
  status := pb_status

  ' Release lock
  lockrel(api_lock)

  return status

CON '' ═══════════════════════════════════════════════════════════════════════════
    '' INTERNAL WORKER OPERATIONS (called by fs_worker, not directly by API)
    '' ═══════════════════════════════════════════════════════════════════════════

PRI do_mount() : result | reserved                                              '' Internal mount operation
  sec_in_buf := -1
  debug("  [do_mount] Calling initCard()...")
  if initCard()
    debug("  [do_mount] initCard OK, reading MBR sector 0...")
    readSector(0)                                                               '  read master boot record
    debug("  [do_mount] MBR type code at $1C2: ", uhex_(buf[$1C2]))
    if buf[$1C2] == $0B or buf[$1C2] == $0C                                     '  offset $1C2 contains type code, $0B and $0C specify FAT32
      vbr_sec := long[@buf + $1C6]                                              '  offset $1C6 contains volume boot record sector number
      debug("  [do_mount] FAT32 detected, VBR at sector ", udec(vbr_sec))
      readSector(vbr_sec)                                                       '  read volume boot record
    else
      debug("  [do_mount] FAIL: Not FAT32 (type=", uhex_(buf[$1C2]), ")")
      return E_NOT_FAT32
    debug("  [do_mount] Bytes/sector: ", udec(word[@buf + $0B]))
    if word[@buf + $0B] <> 512
      debug("  [do_mount] FAIL: Bytes/sector not 512")
      return E_BAD_SECTOR_SIZE
    sec_per_clus := buf[$0D]
    debug("  [do_mount] Sectors/cluster: ", udec(sec_per_clus))
    if (sec_per_clus & (sec_per_clus - 1))
      debug("  [do_mount] FAIL: sec_per_clus not power of 2")
      return E_NOT_FAT32
    reserved := word[@buf + $0E]
    debug("  [do_mount] Reserved sectors: ", udec(reserved))
    debug("  [do_mount] Number of FATs: ", udec(buf[$10]))
    if buf[$10] <> 2
      debug("  [do_mount] FAIL: FAT count not 2")
      return E_NOT_FAT32
    sec_per_fat := long[@buf + $24]
    fsinfo_sec := word[@buf + $30]
    fat_sec := vbr_sec + reserved
    fat2_sec := fat_sec + sec_per_fat
    root_sec := (fat_sec + 2 * sec_per_fat)
    dir_sec := root_sec
    cluster_offset := root_sec // sec_per_clus
    bytemove(@vol_label, @buf + $47, 11)
    vol_label[11] := 0
    debug("  [do_mount] Volume label: ", zstr(@vol_label))

    ' Read FSInfo sector for free cluster count and next-free hint
    if fsinfo_sec > 0 and fsinfo_sec < reserved
      readSector(vbr_sec + fsinfo_sec)
      if long[@buf + 0] == $4161_5252 and long[@buf + 484] == $6141_7272
        fsi_free_count := long[@buf + 488]
        fsi_nxt_free := long[@buf + 492]
        debug("  [do_mount] FSInfo: free_count=", udec(fsi_free_count), " nxt_free=", udec(fsi_nxt_free))
      else
        fsi_free_count := $FFFF_FFFF
        fsi_nxt_free := $FFFF_FFFF
        debug("  [do_mount] FSInfo: invalid signatures, ignoring")
    else
      fsi_free_count := $FFFF_FFFF
      fsi_nxt_free := $FFFF_FFFF
      debug("  [do_mount] FSInfo: sector not present")

    debug("  [do_mount] SUCCESS")
    if date_stamp == 0
      setdate(2009,01,27,07,00,00)
    flags |= F_MOUNTED
    return SUCCESS
  else
    debug("  [do_mount] FAIL: initCard() returned false")
    return E_INIT_FAILED

PRI do_unmount() : result                                                       '' Internal unmount operation
  do_close()
  result := updateFSInfo()
  flags := flags & !F_MOUNTED
  debug("  [do_unmount] Card unmounted cleanly")
  return SUCCESS

PRI do_open(name_ptr) : result                                                  '' Internal open file operation
  do_close()
  if searchDirectory(name_ptr)
    if attributes() & %0001_1110 == 0
      flags |= F_OPEN
      return SUCCESS
  return E_FILE_NOT_FOUND

PRI do_close()                                                                  '' Internal close file operation
  '' Close the file and write changed data to the card
  if flags & F_NEWDATA
    writeSector(n_sec)
  if flags & (F_NEWDIR | F_NEWDATA)
    readSector(entry_address >> 9)
    bytemove(@buf + entry_address & 511, @entry_buffer, 32)
    writeSector(entry_address >> 9)
  bytefill(@entry_buffer, 0, 32)
  flags := flags & !F_NEWDATA & !F_NEWDIR & !F_OPEN
  file_idx := 0

PRI do_read(p_buffer, count) : bytes_read | delta                               '' Internal read operation
  if (flags & F_OPEN) and not (attributes() & %0001_1110)
    count <#= (fileSize() - file_idx)
    readSector(n_sec)
    repeat while count > 0
      delta := (512 - (file_idx & 511)) <# count
      bytemove(p_buffer, @buf + (file_idx & 511), delta)
      file_idx += delta
      bytes_read += delta
      p_buffer += delta
      count -= delta
      if file_idx & 511 == 0
        readNextSector()

PRI do_write(p_buffer, count) | delta, temp                                     '' Internal write operation
  if (flags & F_OPEN) and (count > 0) and not (attributes() & %0001_1111)
    if fileSize() & (sec_per_clus << 9 - 1) == 0
      temp := firstCluster()
      repeat (fileSize()-1) / (sec_per_clus << 9)
        temp := long[readFat(temp)]
      temp := allocateCluster(temp)
      if fileSize() == 0
        word[@entry_buffer + $14] := temp >> 16
        word[@entry_buffer + $1A] := temp & $FFFF
      n_sec := clus2sec(temp)
      bytefill(@buf,0,512)
    else
      do_seek(fileSize())                                                       ' Use internal seek to avoid deadlock
    repeat while count > 0
      delta := (512 - (file_idx & 511)) <# count
      bytemove(@buf + file_idx & 511, p_buffer, delta)
      sec_in_buf := n_sec
      file_idx += delta
      p_buffer += delta
      long[@entry_buffer + $1C] += delta
      count -= delta
      if count > 0 and file_idx & 511 == 0
        writeSector(n_sec++)
        bytefill(@buf,0,512)
        if ((n_sec - cluster_offset) & (sec_per_clus - 1)) == 0
          temp := allocateCluster(sec2clus(n_sec-1))
          n_sec := clus2sec(temp)
    flags |= F_NEWDATA

PRI do_seek(pos) : result | cluster                                             '' Internal seek operation
  if pos > fileSize()
    return E_END_OF_FILE
  cluster := firstCluster()
  repeat (pos / (sec_per_clus << 9))
    cluster := long[readFat(cluster)]
  n_sec := clus2sec(cluster)
  n_sec += (pos / 512) // sec_per_clus
  readSector(n_sec)
  file_idx := pos
  return SUCCESS

PRI do_newfile(name_ptr) : result | temp                                        '' Internal new file operation
  do_close()
  if searchDirectory(name_ptr)
    return E_FILE_EXISTS

  temp := (entry_address + cluster_offset << 9) & (sec_per_clus << 9 - 1)
  if temp == (sec_per_clus << 9 - 32)
    if buf[480] == $00
      temp := allocateCluster(byte2clus(entry_address))
      clearCluster(temp)

  byte[@entry_buffer + 11] := $20
  long[@entry_buffer + 14] := date_stamp
  word[@entry_buffer + 20] := $0000
  long[@entry_buffer + 22] := date_stamp
  word[@entry_buffer + 26] := $0000
  long[@entry_buffer + 28] := 0
  flags |= F_OPEN | F_NEWDIR
  return SUCCESS

PRI do_newdir(name_ptr) : result | temp                                         '' Internal new directory operation
  do_close()
  if searchDirectory(name_ptr)
    return E_FILE_EXISTS

  temp := (entry_address + cluster_offset << 9) & (sec_per_clus << 9 - 1)
  if temp == sec_per_clus << 9 - 32
    if buf[480] == $00
      temp := allocateCluster(byte2clus(entry_address))
      clearCluster(temp)

  temp := allocateCluster(0)
  byte[@entry_buffer + 11] := $10
  long[@entry_buffer + 14] := date_stamp
  word[@entry_buffer + 20] := temp >> 16
  long[@entry_buffer + 22] := date_stamp
  word[@entry_buffer + 26] := temp & $FFFF
  long[@entry_buffer + 28] := 0

  readSector(entry_address >> 9)
  bytemove(@buf + entry_address & 511, @entry_buffer, 32)
  writeSector(entry_address >> 9)

  bytefill(@buf, 0, 512)
  bytemove(@buf[0], string(".          "), 11)
  byte[@buf + 11] := $10
  long[@buf + 14] := date_stamp
  word[@buf + 20] := temp >> 16
  long[@buf + 22] := date_stamp
  word[@buf + 26] := temp & $FFFF

  temp := byte2clus(entry_address)
  if temp == 2
    temp := 0
  bytemove(@buf[32], string("..         "), 11)
  byte[@buf + 32 + 11] := $10
  long[@buf + 32 + 14] := date_stamp
  word[@buf + 32 + 20] := temp >> 16
  long[@buf + 32 + 22] := date_stamp
  word[@buf + 32 + 26] := temp & $FFFF

  n_sec := clus2sec(firstCluster())
  writeSector(n_sec)
  sec_in_buf := n_sec
  return SUCCESS

PRI do_delete(name_ptr) : result | cluster, p_cluster, fat_sector               '' Internal delete operation
  do_close()
  if searchDirectory(name_ptr) == 0
    return E_FILE_NOT_FOUND
  if attributes() & %0000_1111                                                   ' Check read-only, hidden, system, volume label
    return E_FILE_NOT_FOUND                                                     ' Protected file (but allow directories)

  buf[entry_address & 511] := $E5
  writeSector(entry_address >> 9)

  p_cluster := firstCluster()
  repeat
    cluster := long[readFAT(p_cluster)]
    long[@buf + p_cluster << 2 & 511] := 0
    if cluster >> 7 - p_cluster >> 7 <> 0
      fat_sector := p_cluster >> 7
      writeSector(fat_sector + fat_sec)
      writeSector(fat_sector + fat2_sec)
    p_cluster := cluster
  until cluster >= $0FFF_FFF8
  return SUCCESS

PRI do_chdir(name_ptr) : result                                                 '' Internal change directory operation
  do_close()
  if searchDirectory(name_ptr)
    if (attributes() & %0001_0000) or (dir_sec == root_sec)
      dir_sec := n_sec
      return SUCCESS
  return E_NOT_A_DIR

PRI do_freespace() : result | cluster                                           '' Internal free space calculation
  if not (flags & F_MOUNTED)
    return 0
  n_sec := fat_sec
  repeat sec_per_fat
    readSector(n_sec++)
    repeat cluster from 0 to 127
      if long[@buf + cluster << 2] == 0
        result++
  result := result * sec_per_clus

PRI do_sync()                                                                   '' Internal sync operation
  if flags & F_NEWDATA
    writeSector(n_sec)
    flags := flags & !F_NEWDATA
  if flags & F_NEWDIR
    readSector(entry_address >> 9)
    bytemove(@buf + entry_address & 511, @entry_buffer, 32)
    writeSector(entry_address >> 9)
    flags := flags & !F_NEWDIR

PRI do_rename(old_name, new_name) : result | bookmark, temp_sec, i              '' Internal rename operation
  if searchDirectory(old_name)
    bookmark := entry_address
    temp_sec := dir_sec
    dir_sec := entry_address >> 9
    i := 0
    repeat until byte[new_name + i] == $00
      if byte[new_name + i] == "/"
        new_name += i+1
        i := 1
      i++
    if searchDirectory(new_name) == 0
      readSector(bookmark >> 9)
      bytemove(@buf + bookmark & 511, @entry_buffer, 11)
      writeSector(bookmark >> 9)
      dir_sec := temp_sec
      return SUCCESS
  return E_FILE_NOT_FOUND

PRI do_movefile(name_ptr, dest_folder) : result | bookmark, p_temp, temp_sec    '' Internal move file operation
  p_temp := @"FILENAME.TXT"
  if do_open(name_ptr) == SUCCESS
    bookmark := entry_address
    bytemove(p_temp, filename(), 12)
    temp_sec := dir_sec
    if do_chdir(dest_folder) == SUCCESS
      if bookmark >> 9 == n_sec
        return E_FILE_EXISTS                                                    ' Same directory
      if do_newfile(p_temp) == SUCCESS
        readSector(bookmark >> 9)
        bytemove(@entry_buffer, @buf + bookmark & 511, 32)
        byte[@buf + bookmark & 511] := $E5
        writeSector(bookmark >> 9)
        do_close()
        dir_sec := temp_sec
        return SUCCESS
    dir_sec := temp_sec
  return E_FILE_NOT_FOUND

PRI do_readdir(entry_num) : result | idx, char, attrib                          '' Internal read directory operation
  idx := 0
  n_sec := dir_sec
  readSector(n_sec)

  repeat until entry_num == -1
    char := byte[@buf + idx & 511]
    attrib := byte[@buf + idx & 511 + 11]

    if char == $00
      return E_FILE_NOT_FOUND
    elseif char <> $E5
      if attrib & %0000_1110 == 0
        entry_num--
        if entry_num == -1
          bytemove(@entry_buffer, @buf + idx & 511, 32)
          return SUCCESS
    idx += 32
    if idx & 511 == 0
      readNextSector()
  return E_FILE_NOT_FOUND

CON '' ═══════════════════════════════════════════════════════════════════════════
    '' PUBLIC API - Multi-cog safe via worker cog
    '' All operations are serialized through send_command()
    '' ═══════════════════════════════════════════════════════════════════════════

CON     '' management methods
PUB mount(_cs, _mosi, _miso, _sck) : result                                     '' mount SD card (multi-cog safe)
  '' Starts worker cog (if needed) and mounts the SD card filesystem.
  '' Returns true on success, false on failure.
  '' @param _cs   - Chip select pin number
  '' @param _mosi - Master Out Slave In pin number
  '' @param _miso - Master In Slave Out pin number
  '' @param _sck  - Serial clock pin number

  ' Start worker cog if not already running
  if cog_id == -1
    if start(_cs, _mosi, _miso, _sck) == -1
      debug("  [mount] Failed to start worker cog")
      return false

  ' Send mount command to worker
  result := send_command(CMD_MOUNT, 0, 0, 0, 0)
  if result == SUCCESS
    debug("  [mount] Mount successful")
    return true
  else
    debug("  [mount] Mount failed with error ", sdec_(result))
    set_error(result)
    return false

PUB initCardOnly(_cs, _mosi, _miso, _sck) : result                              '' initialize SD card without mounting filesystem
'' Use this for low-level operations like formatting. Does NOT read filesystem.
'' Returns true if card initialized successfully, false otherwise.
  longmove(@cs, @_cs, 4)
  pinh(cs)                                                                      '  CS HIGH = deselected
  pinh(mosi)
  pinh(sck)

  debug("  [initCardOnly] Pins: CS=P", udec_(cs), " MOSI=P", udec_(mosi), " MISO=P", udec_(miso), " SCK=P", udec_(sck))
  closeFile()
  sec_in_buf := -1
  result := initCard()
  if result
    debug("  [initCardOnly] Card initialized successfully")
  else
    debug("  [initCardOnly] Card initialization failed")

PUB cardSizeSectors() : result | csd[4], c_size, read_bl_len, c_size_mult       '' get total sectors on card by reading CSD register
'' Returns total number of 512-byte sectors on the card.
'' Must call initCardOnly() or mount() first.
  ' Read CSD using CMD9
  result := readCSD(@csd)
  if result == 0
    debug("  [cardSizeSectors] Failed to read CSD")
    return 0

  ' CSD structure version is in bits [127:126] (byte 0, bits 7:6)
  if (csd.byte[0] >> 6) == 0
    ' CSD Version 1.0 (SDSC)
    ' C_SIZE is bits [73:62] (12 bits)
    ' READ_BL_LEN is bits [83:80] (4 bits)
    ' C_SIZE_MULT is bits [49:47] (3 bits)
    read_bl_len := csd.byte[5] & $0F
    c_size := (csd.byte[6] & $03) << 10
    c_size |= csd.byte[7] << 2
    c_size |= csd.byte[8] >> 6
    c_size_mult := (csd.byte[9] & $03) << 1
    c_size_mult |= csd.byte[10] >> 7
    ' Capacity = (C_SIZE + 1) * 2^(C_SIZE_MULT + 2) * 2^READ_BL_LEN bytes
    ' Sectors = Capacity / 512
    result := (c_size + 1) << (c_size_mult + 2 + read_bl_len - 9)
    debug("  [cardSizeSectors] CSD v1.0: C_SIZE=", udec(c_size), " MULT=", udec(c_size_mult), " BL_LEN=", udec(read_bl_len))
  else
    ' CSD Version 2.0 (SDHC/SDXC)
    ' C_SIZE is bits [69:48] (22 bits)
    ' Capacity = (C_SIZE + 1) * 512KB
    c_size := (csd.byte[7] & $3F) << 16
    c_size |= csd.byte[8] << 8
    c_size |= csd.byte[9]
    ' Sectors = (C_SIZE + 1) * 1024 (each unit is 512KB = 1024 sectors)
    result := (c_size + 1) * 1024
    debug("  [cardSizeSectors] CSD v2.0: C_SIZE=", udec(c_size))

  debug("  [cardSizeSectors] Total sectors: ", udec(result))

PUB writeSectorRaw(sector, p_buffer) : result                                   '' write a sector at absolute LBA address
'' Low-level sector write for formatting/partitioning. Bypasses filesystem.
'' @param sector - absolute LBA sector number
'' @param p_buffer - pointer to 512 bytes of data to write
  bytemove(@buf, p_buffer, 512)
  result := writeSector(sector)
  if result
    debug("  [writeSectorRaw] Wrote sector ", udec(sector))
  else
    debug("  [writeSectorRaw] FAILED to write sector ", udec(sector))

PUB readSectorRaw(sector, p_buffer) : result                                    '' read a sector at absolute LBA address
'' Low-level sector read for verification. Bypasses filesystem.
'' @param sector - absolute LBA sector number
'' @param p_buffer - pointer to 512-byte buffer to receive data
  sec_in_buf := -1                                                              '  force re-read
  readSector(sector)
  bytemove(p_buffer, @buf, 512)
  result := true
  debug("  [readSectorRaw] Read sector ", udec(sector))

CON '' ═══════════════════════════════════════════════════════════════════════════
    '' CARD IDENTIFICATION METHODS (for diagnostic tools)
    '' These methods provide raw register access for card characterization.
    '' Call initCardOnly() or mount() before using these methods.
    '' ═══════════════════════════════════════════════════════════════════════════

PUB readCIDRaw(p_buf) : result                                                  '' read CID register (16 bytes) into buffer
'' Reads the Card Identification register containing manufacturer, product name,
'' serial number, and manufacturing date.
'' @param p_buf - pointer to 16-byte buffer to receive CID data
'' @return true on success, false on failure
  result := readCID(p_buf)
  if result
    debug("  [readCIDRaw] CID read successfully")
  else
    debug("  [readCIDRaw] CID read FAILED")

PUB readCSDRaw(p_buf) : result                                                  '' read CSD register (16 bytes) into buffer
'' Reads the Card Specific Data register containing capacity, speed, and features.
'' @param p_buf - pointer to 16-byte buffer to receive CSD data
'' @return true on success, false on failure
  result := readCSD(p_buf)
  if result
    debug("  [readCSDRaw] CSD read successfully")
  else
    debug("  [readCSDRaw] CSD read FAILED")

PUB readSCRRaw(p_buf) : result                                                  '' read SCR register (8 bytes) into buffer
'' Reads the SD Configuration Register containing SD spec version and bus widths.
'' @param p_buf - pointer to 8-byte buffer to receive SCR data
'' @return true on success, false on failure
  result := readSCR(p_buf)
  if result
    debug("  [readSCRRaw] SCR read successfully")
  else
    debug("  [readSCRRaw] SCR read FAILED")

PUB getOCR() : ocr                                                              '' get cached OCR register value
'' Returns the Operating Conditions Register cached during card initialization.
'' Contains card capacity status (CCS) and voltage range.
'' @return 32-bit OCR value, or 0 if card not initialized
  ocr := ocr_value
  debug("  [getOCR] OCR = $", uhex_long(ocr))

PUB readVBRRaw(p_buf) : result                                                  '' read Volume Boot Record (512 bytes) into buffer
'' Reads the Volume Boot Record sector containing filesystem parameters.
'' Card must be mounted for this method to work (VBR location determined at mount).
'' @param p_buf - pointer to 512-byte buffer to receive VBR data
'' @return true on success, false if not mounted
  if not (flags & F_MOUNTED)
    debug("  [readVBRRaw] FAILED: Card not mounted")
    return false
  sec_in_buf := -1                                                              '  force re-read
  readSector(vbr_sec)
  bytemove(p_buf, @buf, 512)
  debug("  [readVBRRaw] VBR read from sector ", udec(vbr_sec))
  return true

PRI readCSD(p_csd) : result | t, i                                              '' read CSD register using CMD9
'' Reads the 16-byte CSD register into p_csd buffer
'' Returns true on success, false on failure
  transfer(-1, 8)
  pinl(cs)
  transfer(-1, 8)
  transfer($40 | 9, 8)                                                          '  CMD9 = SEND_CSD
  transfer(0, 32)                                                               '  argument = 0
  transfer($AF, 8)                                                              '  CRC (approximate)

  ' Wait for response
  t := getct() + clkfreq
  repeat
    result := transfer(-1, 8)
    if result <> $FF
      quit
    if getct() - t > 0
      pinh(cs)
      return false

  if result <> $00
    pinh(cs)
    return false

  ' Wait for data token ($FE)
  t := getct() + clkfreq
  repeat
    result := transfer(-1, 8)
    if result == $FE
      quit
    if getct() - t > 0
      pinh(cs)
      return false

  ' Read 16 bytes of CSD data
  repeat i from 0 to 15
    byte[p_csd + i] := transfer(-1, 8)

  ' Read and discard 2-byte CRC
  transfer(-1, 16)

  pinh(cs)
  return true

PRI readCID(p_cid) : result | t, i                                              '' read CID register using CMD10
'' Reads the 16-byte CID (Card Identification) register into p_cid buffer
'' Returns true on success, false on failure
  transfer(-1, 8)
  pinl(cs)
  transfer(-1, 8)
  transfer($40 | 10, 8)                                                         '  CMD10 = SEND_CID
  transfer(0, 32)                                                               '  argument = 0
  transfer($1B, 8)                                                              '  CRC for CMD10

  ' Wait for response
  t := getct() + clkfreq
  repeat
    result := transfer(-1, 8)
    if result <> $FF
      quit
    if getct() - t > 0
      pinh(cs)
      return false

  if result <> $00
    pinh(cs)
    return false

  ' Wait for data token ($FE)
  t := getct() + clkfreq
  repeat
    result := transfer(-1, 8)
    if result == $FE
      quit
    if getct() - t > 0
      pinh(cs)
      return false

  ' Read 16 bytes of CID data
  repeat i from 0 to 15
    byte[p_cid + i] := transfer(-1, 8)

  ' Read and discard 2-byte CRC
  transfer(-1, 16)

  pinh(cs)
  return true

PRI readSCR(p_scr) : result | t, i                                              '' read SCR register using ACMD51
'' Reads the 8-byte SCR (SD Configuration Register) into p_scr buffer
'' Requires CMD55 prefix before ACMD51
'' Returns true on success, false on failure

  ' Send CMD55 (APP_CMD) first
  transfer(-1, 8)
  pinl(cs)
  transfer(-1, 8)
  transfer($40 | 55, 8)                                                         '  CMD55 = APP_CMD
  transfer(0, 32)                                                               '  argument = 0
  transfer($65, 8)                                                              '  CRC for CMD55

  ' Wait for R1 response
  t := getct() + clkfreq
  repeat
    result := transfer(-1, 8)
    if result <> $FF
      quit
    if getct() - t > 0
      pinh(cs)
      return false

  if result > $01                                                               '  Accept $00 or $01 (idle)
    pinh(cs)
    return false

  pinh(cs)                                                                      '  Deselect before ACMD51

  ' Send ACMD51 (SEND_SCR)
  transfer(-1, 8)
  pinl(cs)
  transfer(-1, 8)
  transfer($40 | 51, 8)                                                         '  ACMD51 = SEND_SCR
  transfer(0, 32)                                                               '  argument = 0
  transfer($55, 8)                                                              '  CRC (approximate)

  ' Wait for R1 response
  t := getct() + clkfreq
  repeat
    result := transfer(-1, 8)
    if result <> $FF
      quit
    if getct() - t > 0
      pinh(cs)
      return false

  if result <> $00
    pinh(cs)
    return false

  ' Wait for data token ($FE)
  t := getct() + clkfreq
  repeat
    result := transfer(-1, 8)
    if result == $FE
      quit
    if getct() - t > 0
      pinh(cs)
      return false

  ' Read 8 bytes of SCR data
  repeat i from 0 to 7
    byte[p_scr + i] := transfer(-1, 8)

  ' Read and discard 2-byte CRC
  transfer(-1, 16)

  pinh(cs)
  return true

PUB newFile(name_ptr) : result                                                  '' create and open a new file (multi-cog safe)
  '' Creates a new file in the current directory and opens it for writing.
  '' Returns true on success, false if file exists or error.
  result := send_command(CMD_NEWFILE, name_ptr, 0, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

PUB newDirectory(name_ptr) : result                                             '' create a new directory (multi-cog safe)
  '' Creates a new directory in the current directory.
  '' Returns true on success, false if directory exists or error.
  result := send_command(CMD_NEWDIR, name_ptr, 0, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

PUB openFile(name_ptr) : result                                                 '' open file (multi-cog safe)
  '' Opens an existing file for reading/writing.
  '' Returns true on success, false if not found.
  result := send_command(CMD_OPEN, name_ptr, 0, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

PUB changeDirectory(name_ptr) : result                                          '' change directory (multi-cog safe)
  '' Changes the current directory.
  '' Returns true on success, false if not found.
  result := send_command(CMD_CHDIR, name_ptr, 0, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

PUB closeFile()                                                                 '' close file (multi-cog safe)
  '' Closes the currently open file, flushing any pending writes.
  send_command(CMD_CLOSE, 0, 0, 0, 0)

PUB unmount() : result                                                          '' unmount SD card (multi-cog safe)
  '' Cleanly unmounts the SD card, flushing all data and updating FSInfo.
  '' Returns true on success.
  result := send_command(CMD_UNMOUNT, 0, 0, 0, 0)
  debug("  [unmount] Card unmounted")
  return result == SUCCESS

PUB sync() : result                                                             '' flush buffers (multi-cog safe)
  '' Flushes all pending writes without closing the file.
  '' Use this to checkpoint data during long operations.
  result := send_command(CMD_SYNC, 0, 0, 0, 0)
  debug("  [sync] Buffers flushed")
  return result == SUCCESS

PRI updateFSInfo() : result | free_count                                        '' update FSInfo sector with current free cluster count
'' Scans FAT to count free clusters and writes updated FSInfo sector.
'' Called by unmount() to ensure other OSes see correct free space.
  if fsinfo_sec == 0 or fsi_free_count == $FFFF_FFFF
    debug("  [updateFSInfo] No valid FSInfo to update")
    return false                                                                '  no FSInfo sector to update

  ' Count free clusters by scanning FAT
  free_count := countFreeClusters()

  ' Read FSInfo sector
  readSector(vbr_sec + fsinfo_sec)

  ' Verify signatures before writing
  if long[@buf + 0] <> $4161_5252 or long[@buf + 484] <> $6141_7272
    debug("  [updateFSInfo] Invalid FSInfo signatures")
    return false

  ' Update free count and next-free hint
  long[@buf + 488] := free_count                                                '  FSI_Free_Count
  long[@buf + 492] := fsi_nxt_free                                              '  FSI_Nxt_Free (keep cached value)

  ' Write updated FSInfo sector
  writeSector(vbr_sec + fsinfo_sec)
  fsi_free_count := free_count                                                  '  update cached value
  debug("  [updateFSInfo] Updated: free_count=", udec(free_count))
  return true

PRI countFreeClusters() : count | fat_idx, entry                                '' count free clusters in FAT
'' Scans entire FAT and returns number of free (zero) entries.
'' This is slow on large cards but only called on unmount().
  count := 0
  fat_idx := 8                                                                  '  start at cluster 2 (skip reserved entries 0,1)
  repeat
    if fat_idx & 511 == 0                                                       '  if at sector boundary
      if fat_idx >> 9 >= sec_per_fat                                            '  if past end of FAT
        quit
      readSector(fat_sec + fat_idx >> 9)                                        '  read next FAT sector
    entry := long[@buf + fat_idx & 511]
    if (entry & $0FFF_FFFF) == 0                                                '  check only low 28 bits
      count++
    fat_idx += 4
  sec_in_buf := -1                                                              '  invalidate buffer (FAT sector loaded)

PUB deleteFile(name_ptr) : result                                               '' delete file (multi-cog safe)
  '' Deletes a file from the current directory.
  '' Returns true on success, false if not found or protected.
  result := send_command(CMD_DELETE, name_ptr, 0, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

PUB rename(old_name, new_name) : result                                         '' rename file or directory (multi-cog safe)
  '' Renames a file or directory.
  '' Returns true on success, false if source not found or dest exists.
  result := send_command(CMD_RENAME, old_name, new_name, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

PUB moveFile(name_ptr, dest_folder) : result                                    '' move file to another directory (multi-cog safe)
  '' Moves a file from the current directory to another directory.
  '' Returns true on success, false on error.
  result := send_command(CMD_MOVEFILE, name_ptr, dest_folder, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

PUB freeSpace() : result                                                        '' get free space in sectors (multi-cog safe)
  '' Returns the number of free sectors on the card.
  '' This may take a while on large cards.
  if send_command(CMD_FREESPACE, 0, 0, 0, 0) == SUCCESS
    return pb_data0
  else
    return 0

PUB setDate(year, month, day, hour, minute, second)                             '' set the current date and time for new files/folders
  date_stamp := (year - 1980) << 25 | month << 21 | day << 16 | hour << 11 | minute << 5 | second >> 1

CON     '' read/write methods
PUB read(p_buffer, count) : result                                              '' read bytes from file (multi-cog safe)
  '' Reads up to count bytes from the open file into p_buffer.
  '' Returns the number of bytes actually read.
  if send_command(CMD_READ, p_buffer, count, 0, 0) == SUCCESS
    return pb_data0                                                             ' pb_data0 contains bytes read
  else
    return 0

PUB readByte(address) : result | byte_buf                                       '' read single byte from file (multi-cog safe)
  '' Seeks to address and reads one byte.
  seek(address)
  if read(@byte_buf, 1) == 1
    return byte_buf
  else
    return 0

PUB write(p_buffer, count) : result                                             '' write bytes to file (multi-cog safe)
  '' Writes count bytes from p_buffer to the open file.
  send_command(CMD_WRITE, p_buffer, count, 0, 0)

PUB writeByte(char) : result                                                    '' write single byte to file (multi-cog safe)
  write(@char, 1)

PUB writeString(p_str) : result                                                 '' write string to file (multi-cog safe)
  write(p_str, strsize(p_str))

PUB readDirectory(entry) : result                                               '' read directory entry (multi-cog safe)
  '' Iterates through entries in the current directory.
  '' Returns pointer to entry_buffer on success, 0 if entry doesn't exist.
  if send_command(CMD_READDIR, entry, 0, 0, 0) == SUCCESS
    return @entry_buffer
  else
    return 0

PUB seek(pos) : result                                                          '' seek to position in file (multi-cog safe)
  '' Sets file position to pos bytes from start.
  '' Returns true on success, false if pos is beyond end of file.
  result := send_command(CMD_SEEK, pos, 0, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

CON     '' directory methods
PRI searchDirectory(name_ptr) : result | p_temp, p_entry, i
  p_temp := @"FILENAMETXT"
  if byte[name_ptr] == "/"
    dir_sec := root_sec
    name_ptr++
  n_sec := dir_sec

  repeat until byte[name_ptr] == $00
    bytefill(@entry_buffer,0,32)
    i := 0

    repeat until byte[name_ptr + i] == "/" or byte[name_ptr + i] == $00         '  advance i up to "/" or null
      i++
    bytemove(@entry_buffer,name_ptr,i <# 12)                                    '  copy name into entry_buffer, max 12 characters
    name_ptr += i                                                               '  advance ptr to "/" or null
    if byte[name_ptr] == "/"                                                    '  if "/"
      name_ptr++                                                                '   advance ptr to byte following "/"

    repeat i from 0 to 11                                                       '  convert name to uppercase
      case entry_buffer[i]
        "a".."z" : entry_buffer[i] -= $20

    i := 0                                                                      '  convert 8.3 filename into short filename
    if strcomp(@entry_buffer,string("..")) == 0                                 '  exception if changing directory to ".."
      repeat strsize(@entry_buffer) <# 9                                        '  search name for extension
        if entry_buffer[i++] == "."                                             '  if extension found
          bytemove(@entry_buffer + 8,@entry_buffer + i,3)                       '   move extension to byte 8
          bytefill(@entry_buffer + i-1," ",9-i)                                 '   fill space between name and extension
    bytefill(@entry_buffer + strsize(@entry_buffer)," ",12-strsize(@entry_buffer)) ' fill remaining space (in case extension < 3 characters)
    entry_buffer[11] := $00                                                     '  append null

    i := 0
    readSector(n_sec)                                                           '  read 1st sector of directory
    entry_address := 0
    repeat
      p_entry := @buf + i & 511                                                 '  locate entry in directory
      bytemove(p_temp,p_entry,11)                                               '  copy short filename into p_temp
      if strcomp(@entry_buffer,p_temp)                                          '  if matching entry located
        entry_address := n_sec << 9 | i & 511                                   '   store the byte-level address of the entry
        bytemove(@entry_buffer,p_entry,32)                                      '   copy entire entry into entry_buffer
        if firstCluster() == 0                                                  '  exception if ".." points to root directory
          n_sec := clus2sec(2)                                                  '   root directory located in cluster 2
        else
          n_sec := clus2sec(firstCluster())                                     '   set n_sec to 1st sector of 1st cluster of file
        quit
      elseif byte[name_ptr] == $00                                              '  if end of path reached
        if (entry_address == 0) and (byte[p_temp] == $E5 or byte[p_temp] == $00) '  if entry_address not set, and 1st byte is $E5 or $00
          entry_address := n_sec << 9 | i & 511                                 '    set entry_address to 1st unused entry (for newFile / newDirectory)

      if byte[p_temp] == $00                                                    '  entry not found in directory
        return false
      i += 32                                                                   '  increment to next entry
      if i & 511 == 0                                                           '  read new directory sector/cluster if needed
        readNextSector()
  file_idx := 0
  return true

PUB fileName() : result | p_temp, i                                             '' return the 8.3 filename of the currently opened file
  p_temp := @"filename.txt"
  bytemove(p_temp,@entry_buffer,11)
  i := 0
  repeat until byte[p_temp + i++] == " " or i == 9
  bytemove(p_temp + i,p_temp + 8,3)
  if attributes() & $10
    byte[p_temp + i-1] := $00
  else
    byte[p_temp + i-1] := "."
    byte[p_temp + i+3] := $00
  return p_temp

PUB attributes() : result                                                       '' return the attribute byte of the currently opened file
  return entry_buffer[$0B]

PUB volumeLabel() : result                                                      '' return pointer to volume label string
  return @vol_label

PRI firstCluster() : result                                                     '' return the 1st cluster location of the currently opened file
  return word[@entry_buffer + $14] << 16 | word[@entry_buffer + $1A]

PUB fileSize() : result                                                         '' return the size of the currently opened file in bytes
  return long[@entry_buffer + $1C]

CON     '' FAT and sector methods
PRI readFat(cluster) : result | contents, p_contents                            '' read a FAT location and return a pointer to the location of that entry
  readSector((cluster >> 7 + fat_sec))                                          '  128 entries in each FAT sector
  result := @buf + (cluster << 2) & 511

PRI allocateCluster(cluster) : result | fat_idx, buf_idx, high_bits             '' searches FAT for an empty cluster, allocates cluster, returns cluster number
  fat_idx := 0                                                                  '   if cluster parameter <> 0, writes newly allocated cluster number in parameter cell
  repeat
    if fat_idx & 511 == 0                                                       '  if lower nine bits of index are clear
      readSector(fat_sec + fat_idx >> 9)                                        '   load next sector of FAT
    buf_idx := fat_idx & 511
    result := long[@buf + buf_idx]                                              '  read a cluster cell
    if (result & $0FFF_FFFF) == $0000_0000                                      '  if cluster cell is empty (check only low 28 bits)
      high_bits := result & $F000_0000                                          '  preserve high 4 bits
      long[@buf + buf_idx] := high_bits | $0FFF_FFFF                            '  mark as end-of-chain, preserve high bits
      result := fat_idx >> 2                                                    '  store cluster number in result
      writeSector(fat_sec + result >> 7)                                        '  write FAT1 sector
      writeSector(fat2_sec + result >> 7)                                       '  write FAT2 sector (MIRROR)
      if cluster <> 0                                                           '  if allocateCluster was called with a non-zero cluster parameter
        readSector(fat_sec + cluster >> 7)                                      '   read FAT sector containing cluster cell
        buf_idx := cluster << 2 & 511
        high_bits := long[@buf + buf_idx] & $F000_0000                          '  preserve high 4 bits
        long[@buf + buf_idx] := high_bits | (result & $0FFF_FFFF)               '  link to new cluster, preserve high bits
        writeSector(fat_sec + cluster >> 7)                                     '  write FAT1 sector
        writeSector(fat2_sec + cluster >> 7)                                    '  write FAT2 sector (MIRROR)
      return
    fat_idx += 4                                                                '  advance index to next cluster cell

PRI clearCluster(cluster)                                                       '' initialize entire contents of cluster to 0
  n_sec := clus2sec(cluster)                                                    '  set n_sec to 1st sector of specified cluster
  bytefill(@buf,0,512)                                                          '  clear buffer
  repeat sec_per_clus                                                           '  repeat for all sectors in the cluster
    writeSector(n_sec++)                                                        '   overwrite sector
  sec_in_buf := n_sec - 1

PRI readNextSector() | cluster, address, contents                               '' loads the next sector into buffer
  n_sec++
  if ((n_sec - cluster_offset) & (sec_per_clus - 1)) == 0                       '  if next sector is in a different cluster
    cluster := sec2clus(n_sec-1)                                                '   find current cluster number
    readSector(cluster >> 7 + fat_sec)                                          '   read sector of FAT containing cluster number (128 cluster entries in each FAT sector)
    address := @buf + (cluster << 2) & 511                                      '   find long within sector for current cluster
    contents := long[address]                                                   '   read contents to determine next cluster number
    n_sec := clus2sec(contents)                                                 '   convert next cluster number into sector number
  readSector(n_sec)

CON     '' helper methods
PRI byte2clus(byte_address) : result                                            '' convert byte address to cluster number
  return (sec2clus(byte_address >> 9))

PRI sec2clus(sector) : result                                                   '' convert sector number to cluster number
  return (sector - root_sec) / sec_per_clus + 2

PRI clus2byte(cluster) : result                                                 '' convert cluster number to byte address
  return clus2sec(cluster) << 9

PRI clus2sec(cluster) :result                                                   '' convert cluster number to sector number
  return (cluster - 2) * sec_per_clus + root_sec

CON     '' low-level SPI routines
PRI initCard() : result | t, resp, card_version, acmd41_arg                     '' intialize SD card
  debug("    [initCard] Starting card init...")
  debug("    [initCard] Reference: SPI_SD_Implementation_Reference.md")
  sec_in_buf := -1

  ' ============================================
  ' STEP 1: Power-on delay
  ' Spec: VDD must be stable, then wait 1ms minimum
  ' ============================================
  debug("    [initCard] Step 1: Power-on delay (100ms)...")
  waitms(100)

  ' ============================================
  ' STEP 2: Configure SPI pins and slow clock
  ' Spec: Use 100-400 kHz during initialization
  ' ============================================
  bit_delay := clkfreq / 100_000                                                '  ~50kHz for init (conservative)
  debug("    [initCard] Step 2: SPI config, bit_delay=", udec(bit_delay), " (~50kHz)")

  ' SD card SPI mode 0: CPOL=0, CPHA=0
  ' Data sampled on rising edge, changed on falling edge
  pinh(cs)                                                                      '  CS HIGH = deselected
  pinh(mosi)                                                                    '  MOSI HIGH (card expects high during idle)
  pinl(sck)                                                                     '  SCK LOW (SPI mode 0 idle state)

  debug("    [initCard] Pins: CS=", udec_(pinr(cs)), " MOSI=", udec_(pinr(mosi)), " MISO=", udec_(pinr(miso)), " SCK=", udec_(pinr(sck)))

  ' ============================================
  ' STEP 3: Send 74+ clock pulses with CS HIGH
  ' Spec: Card needs this to complete internal init
  ' ============================================
  debug("    [initCard] Step 3: Sending 80 init clocks (CS high, MOSI high)...")
  repeat 80
    pinh(sck)
    waitus(10)
    pinl(sck)
    waitus(10)

  debug("    [initCard] MISO after init clocks: ", udec_(pinr(miso)), " (should be 1)")

  ' ============================================
  ' STEP 4: CMD0 - GO_IDLE_STATE
  ' Sends: 0x40 0x00 0x00 0x00 0x00 0x95
  ' Expected R1: 0x01 (in idle state)
  ' ============================================
  debug("    [initCard] Step 4: CMD0 (GO_IDLE_STATE)...")
  resp := 0
  repeat 5                                                                      '  try up to 5 times
    resp := cmd(0, 0)
    debug("    [initCard] CMD0 response: $", uhex_(resp))
    if resp == $01
      quit
    waitms(10)

  if resp <> $01
    debug("    [initCard] FAIL: CMD0 expected $01, got $", uhex_(resp))
    if resp == $FF
      debug("    [initCard] ($FF = no response, check wiring)")
    return false

  debug("    [initCard] CMD0 OK - card in idle state")

  ' ============================================
  ' STEP 5: CMD8 - SEND_IF_COND
  ' Sends: 0x48 0x00 0x00 0x01 0xAA 0x87
  ' Argument: VHS=0x01 (2.7-3.6V), check_pattern=0xAA
  ' Expected R7: R1 + 4 bytes echoing VHS and pattern
  ' ============================================
  debug("    [initCard] Step 5: CMD8 (SEND_IF_COND, VHS=1, pattern=$AA)...")
  resp := cmd(8, $000001AA)                                                     '  send CMD8, get 32-bit echo
  debug("    [initCard] CMD8 response (32-bit): $", uhex_long(resp))

  card_version := 1                                                             '  assume v1.x until proven otherwise
  acmd41_arg := $00000000                                                       '  HCS=0 for v1.x cards

  if resp == 0                                                                  '  timeout or no response
    debug("    [initCard] CMD8 no response -> Ver 1.x SD card (SDSC only)")
    card_version := 1
    acmd41_arg := $00000000                                                     '  no HCS for v1.x
  elseif (resp & $FFF) == $1AA                                                  '  check VHS and pattern echo
    debug("    [initCard] CMD8 echo valid ($1AA) -> Ver 2.0+ SD card")
    card_version := 2
    acmd41_arg := $40000000                                                     '  HCS=1 for v2.0+ (support SDHC/SDXC)
  else
    debug("    [initCard] CMD8 echo unexpected: $", uhex_long(resp & $FFF), " expected $1AA")
    debug("    [initCard] Treating as Ver 1.x card")
    card_version := 1
    acmd41_arg := $00000000

  ' ============================================
  ' STEP 6: ACMD41 - SD_SEND_OP_COND (loop until ready)
  ' Requires CMD55 prefix before each ACMD41
  ' CMD55: 0x77 0x00 0x00 0x00 0x00 0x65
  ' ACMD41: 0x69 [arg] CRC
  ' Expected R1: 0x00 when ready, 0x01 while initializing
  ' ============================================
  debug("    [initCard] Step 6: ACMD41 init loop (arg=$", uhex_long(acmd41_arg), ")...")
  t := getct() + clkfreq * 2                                                    '  2 second timeout

  repeat
    resp := cmd(55, 0)                                                          '  APP_CMD prefix
    if resp > $01                                                               '  error other than "in idle"
      debug("    [initCard] CMD55 error: $", uhex_(resp))
      waitms(10)
    else
      resp := cmd(41, acmd41_arg)                                               '  SD_SEND_OP_COND
      if resp == $00                                                            '  card ready (not in idle anymore)
        debug("    [initCard] ACMD41 complete - card ready!")
        quit
      elseif resp == $01                                                        '  still initializing
        ' continue looping
      else
        debug("    [initCard] ACMD41 unexpected response: $", uhex_(resp))

    if getct() - t > 0
      debug("    [initCard] FAIL: ACMD41 timeout after 2 seconds")
      debug("    [initCard] Last response: $", uhex_(resp))
      return false
    waitms(10)

  ' ============================================
  ' STEP 7: CMD58 - READ_OCR
  ' Sends: 0x7A 0x00 0x00 0x00 0x00 0xFD
  ' Expected R3: R1 + 32-bit OCR register
  ' Check bit 31 (busy), bit 30 (CCS)
  ' ============================================
  debug("    [initCard] Step 7: CMD58 (READ_OCR)...")
  resp := cmd(58, 0)
  ocr_value := resp                                                             '  Cache OCR for later retrieval
  debug("    [initCard] OCR: $", uhex_long(resp))
  debug("    [initCard]   Bit 31 (ready): ", udec((resp >> 31) & 1))
  debug("    [initCard]   Bit 30 (CCS):   ", udec((resp >> 30) & 1))

  if (resp >> 30) & 1
    hcs := 0                                                                    '  SDHC/SDXC: block addressing (no shift)
    debug("    [initCard] Card type: SDHC/SDXC (block addressing)")
  else
    hcs := 9                                                                    '  SDSC: byte addressing (shift by 9 = multiply by 512)
    debug("    [initCard] Card type: SDSC (byte addressing)")

  ' ============================================
  ' STEP 8: Increase SPI speed for data transfer
  ' PNY FIX: CS must be HIGH during clock change, then send dummy clocks
  ' ============================================
  pinh(cs)                                                                      '  ensure CS HIGH before speed change
  bit_delay := clkfreq / 40_000_000                                             '  ~20 MHz SPI (conservative for PNY compatibility)
  if bit_delay < 2
    bit_delay := 2                                                              '  minimum safe delay
  debug("    [initCard] Step 8: Switching to ~20MHz SPI, bit_delay=", udec(bit_delay))
  ' Send dummy clocks with CS HIGH to stabilize new clock rate
  repeat 8
    transfer(-1, 8)                                                             '  8 dummy bytes = 64 clocks
  debug("    [initCard] Dummy clocks sent, CS HIGH")
  debug("    [initCard] === INIT SUCCESS ===")
  return true


PRI cmd(op,parm) : result | t                                                   '' send a SPI command
  if op == 0
    debug("      [cmd] CS before assert: ", udec_(pinr(cs)))
  transfer(-1,8)                                                                '  required for certain cards (my 512MB card fails if not present)
  pinl(cs)                                                                      '  CS LOW = selected (standard active-LOW)
  if op == 0
    debug("      [cmd] CS after pinl: ", udec_(pinr(cs)), " MISO=", udec_(pinr(miso)))
  transfer(-1,8)                                                                '  required for certain cards (my 512MB and 32GB cards fail if not present)
  transfer($40 | op,8)
  transfer(parm,32)
  if op == 0
    transfer($95,8)                                                             '  send CRC for cmd(0,0)
    debug("      [cmd] After CMD0 sent, MISO=", udec_(pinr(miso)))
  else
    transfer($87,8)                                                             '  send CRC for cmd(8,$1AA)
  t := getct() + clkfreq
  repeat
    result := transfer(-1,8)                                                    '  read 1st byte of reply
    if result <> $FF
      quit
    if getct() - t > 0                                                          '  check timeout
      pinh(cs)                                                                  '  CS HIGH = deselected (standard active-LOW)
      return false
  if op == 8 or op == 58                                                        '  read 32-bit reply for cmd8 and cmd58
    result := transfer(-1,32)                                                   '  (memory card interface condition and operation conditions register
  if op <> 17 and op <> 24 and op <> 55                                         '  keep cs asserted if readSector, writeSector, or application command
    pinh(cs)                                                                    '  CS HIGH = deselected (standard active-LOW)

PRI readSector(sector) : result | _cs, _mosi, _miso, _sck, data, loop_ctr, ptr, timeout  '' read a sector into buffer
  '' Returns 0 on success, -1 on timeout
  if sector == sec_in_buf
    return
  sec_in_buf := sector
  longmove(@_cs,@cs,4)
  ptr := @buf
  cmd(17,sector << hcs)
  timeout := getct() + clkfreq                                                  '  1 second timeout

  org
                drvl      _sck
                wrfast    ##$8000_0000,ptr
                mov       loop_ctr,#512/4
                addct1    timeout, #0                                           '  Arm CT1 with timeout value
.startloop
                drvh      _sck
                nop
                drvl      _sck
                testp     _miso                         wc                      '  C set if MISO high
                pollct1   wz                                                    '  Z set if timeout elapsed
  if_z          jmp       #.timeout_exit                                        '  Exit on timeout
  if_c          jmp       #.startloop                                           '  Loop if MISO still high (no start token)
                jmp       #.start_ok                                            '  Got start token
.timeout_exit
                neg       result, #1                                            '  result := -1 (timeout error)
                jmp       #.done
.start_ok
                outh      _sck
.read_loop
                rep       @.end_rep,#32
                 drvl     _sck
                 rcl      data,#1
                 drvh     _sck
                 testp    _miso                         wc
.end_rep
                rcl       data,#1
                movbyts   data,#%%0123
                wflong    data
                djnz      loop_ctr,#.read_loop
                rep       @.rend15,#16
                 drvl     _sck
                 nop
                 drvh     _sck
                 nop
.rend15
                mov       result, #0                                            '  result := 0 (success)
.done
  end
  pinh(cs)
  if result < 0
    debug("  [readSector] TIMEOUT waiting for start token")
    sec_in_buf := -1                                                            '  Invalidate buffer on error

PRI writeSector(sector) : result | _cs, _mosi, _miso, _sck, data, loop_ctr, ptr, t, resp '' write buffer into a sector
  '' PNY COMPATIBILITY: This implementation follows strict SPI write protocol:
  '' 1. CMD24 with sector address
  '' 2. Data start token (0xFE)
  '' 3. 512 bytes of data
  '' 4. 2 CRC bytes (dummy 0xFF since CRC disabled in SPI mode)
  '' 5. Wait for data-response token (0x05 = accepted)
  '' 6. Wait for MISO to go HIGH (0xFF = programming complete)
  '' CRITICAL: CS must stay LOW and clocking must continue during entire busy period!

  longmove(@_cs,@cs,4)
  ptr := @buf
  cmd(24,sector << hcs)
  transfer($FE,8)                                                               '  Data start token

  ' Send 512 bytes using fast PASM bit-banging
  org
                drvl      _sck
                rdfast    ##8000_0000,ptr
                mov       loop_ctr,#512/4
.write_loop
                rflong    data
                movbyts   data,#%%0123
                rep       @.end_rep,#32
                 rol      data,#1                       wc
                 drvl     _sck
                 drvc     _mosi
                 drvh     _sck
.end_rep
                drvh      _mosi
                djnz      loop_ctr,#.write_loop
  end

  ' Send 2 CRC bytes (dummy values - CRC not checked in SPI mode but bytes required)
  transfer($FF, 8)                                                              '  CRC byte 1
  transfer($FF, 8)                                                              '  CRC byte 2

  ' Wait for data-response token (should be immediate, within a few bytes)
  t := getct() + clkfreq / 10                                                   '  100ms timeout for response
  repeat
    resp := transfer(-1, 8)
    if resp <> $FF
      quit
    if getct() - t > 0
      debug("  [writeSector] TIMEOUT waiting for data-response")
      pinh(cs)
      return false

  ' Verify data-response token: bits [4:0] should be xxx00101 = $05 (data accepted)
  if (resp & $1F) <> $05
    debug("  [writeSector] Data rejected: response=$", uhex_(resp))
    pinh(cs)
    return false

  ' Wait for card to finish programming (busy period)
  ' Card holds MISO LOW during internal flash write, releases to HIGH (0xFF) when done
  ' CRITICAL for PNY: Keep CS LOW and keep clocking until we see stable 0xFF!
  t := getct() + clkfreq / 2                                                    '  500ms timeout per block (generous)
  repeat
    resp := transfer(-1, 8)                                                     '  Clock 8 bits while reading MISO
    if resp == $FF                                                              '  Card released MISO = programming complete
      quit
    if getct() - t > 0
      debug("  [writeSector] TIMEOUT waiting for programming complete")
      pinh(cs)
      return false

  pinh(cs)
  return true

PRI transfer(data,bits) : result | _cs, _mosi, _miso, _sck, delay               '' transfer data to/from SD card
  longmove(@_cs,@cs,4)
  delay := bit_delay
  result := data << (32-bits)                                                   '  move data to MSB
  org
                rep       @.end_rep,bits
                 rcl      result,#1                     wc                      '  send from msb of result, receive into lsb of result
                 drvl     _sck
                 drvc     _mosi
                 waitx    delay
                 drvh     _sck
                 waitx    delay
                 testp    _miso                         wc
.end_rep
                drvh      _mosi
                rcl       result,#1
  end
  if bits < 32                                                                   '  mask to requested bit count
    result &= (1 << bits) - 1                                                   '  (skip for 32 bits - mask would wrap)

CON     '' debug methods
  _CLKFREQ = 80_000_000
PUB displaySector() | address, char, ascii_ptr, i                               '' display sector in buffer
  ascii_ptr := string("0123456789ABCDEF")
  repeat address from 0 to 495 step 16
    repeat i from 0 to 15
      case char := (buf[address + i])
        $20..$7E: byte[ascii_ptr + i] := char
        other:
          if char == 0
            byte[ascii_ptr + i] := "."
          else
            byte[ascii_ptr + i] := char // 26 + "a"
    debug(uhex_word_(address),uhex_byte_array_(@buf + address,8),"-",uhex_byte_array_(@buf + address + 8,8)," | ",lstr_(ascii_ptr,16))

PUB displayEntry() | address, char, ascii_ptr, i
  ascii_ptr := string("0123456789ABCDEF")
  repeat address from 0 to 31 step 16
    repeat i from 0 to 15
      case char := (entry_buffer[address + i])
        $20..$7E: byte[ascii_ptr + i] := char
        other:
          if char == 0
            byte[ascii_ptr + i] := "."
          else
            byte[ascii_ptr + i] := char // 26 + "a"
    debug(uhex_word_(address),uhex_byte_array_(@entry_buffer + address,8),"-",uhex_byte_array_(@entry_buffer + address + 8,8)," | ",lstr_(ascii_ptr,16))

PUB displayFAT(cluster)                                                         '' display FAT sector containing cluster number
  n_sec := fat_sec + cluster >> 7
  readSector(n_sec)
  displaySector()

CON {{     FAT32 file system
  ┌─────────────────────────┐     The master boot record contains 446 bytes of boot code
  │ Master Boot Record      │      followed by four 16-byte partition entries
  │                         │      terminated with $55 $AA in the final 2 bytes
  │ Partitions      $55 $AA │     The 16-byte partition
  ├─────────────────────────┤     ┌──────┬───────┬──────┬─────┬───────┬───────────┐
  │ Reserved                │     │ Boot │ CHS   │ Type │ CHS │ LBA   │ Number of │  Type code located at byte address $1C2
  ├─────────────────────────┤     │ Flag │ Begin │ Code │ End │ Begin │ Sectors   │   Type code = $0B or $0C for FAT32
  │ Volume Boot Record 1    │     ├──────┼───────┼──────┼─────┼───────┼───────────┤  LBA Begin contains address of volume boot record (VBR)
  ├─────────────────────────┤     │      │       │  5   │     │ 9-12  │           │   VBR address located at byte address $1C6
  │ Reserved                │     └──────┴───────┴──────┴─────┴───────┴───────────┘
  ├─────────────────────────┤     Volume boot record contains
  │ Volume Boot Record 2    │     ┌─────────────────────────────────┬────────┬──────┬────────────────────┐
  ├─────────────────────────┤     │          Field                  │ Offset │ Size │ Value              │
  │ Reserved                │     ├─────────────────────────────────┼────────┼──────┼────────────────────┤
  ├─────────────────────────┤     │ Bytes per Sector                │  $0B   │ 16b  │       512          │
  │ File allocation table 1 │     │ Sectors per Cluster             │  $0D   │  8b  │1/2/4/8/16/32/64/128│
  ├─────────────────────────┤     │ Number of Reserved Sectors      │  $0E   │ 16b  │                    │
  │ File allocation table 2 │     │ Number of FATs                  │  $10   │  8b  │        2           │
  ├─────────────────────────┤     │ Sectors per FAT                 │  $24   │ 32b  │                    │
  │ Root directory and      │     │ Root Directory of First Cluster │  $2C   │ 32b  │        2           │
  │  Data region            │     │ Signature                       │ $1FE   │ 16b  │      $AA55         │
  │                         │     └─────────────────────────────────┴────────┴──────┴────────────────────┘
  │                         │      The address of the 1st FAT is VBR address + number of reserved sectors
  │                         │      The address of the root directory is FAT address + number of FATs x sectors per fat
  └─────────────────────────┘
                                  The file system directory contains 32-byte entries for each file in the root directory
                                  ┌─────────────────────────────────┬────────┬──────┐
                                  │          Field                  │ Offset │ Size │  The first byte of the short filename indicates the type of entry
                                  ├─────────────────────────────────┼────────┼──────┤   Normal entry     - as expected   "FILENAMETXT"
                                  │ Short Filename                  │  $00   │ 11B  │   Unused/deleted   - 1st byte $E5  "åILENAMETXT"
                                  │ Attrib Byte                     │  $0B   │  1B  │   End of directory - 1st byte $00
                                  │ Date of creation                │  $0E   │  4B  │
                                  │ First Cluster High              │  $14   │  2B  │
                                  │ Date of modification            │  $16   │  4B  │
                                  │ First Cluster Low               │  $1A   │  2B  │
                                  │ File Size                       │  $1C   │  4B  │
                                  └─────────────────────────────────┴────────┴──────┘
                                  Attrib byte contains bitfields
                                  ┌───┬───────────┬─────┬────────────────────────────────────┐
                                  │bit│ Function  │ LFN │ Comment                            │
                                  ├───┼───────────┼─────┼────────────────────────────────────┤
                                  │ 7 │ Unused    │  0  │ Should be zero                     │
                                  │ 6 │ Unused    │  0  │ Should be zero                     │
                                  │ 5 │ Archive   │  x  │ Has been changed since last backup │
                                  │ 4 │ Directory │  x  │ Is a subdirectory                  │
                                  │ 3 │ Volume ID │  1  │ Filename is Volume ID              │
                                  │ 2 │ System    │  1  │ File is operating system           │
                                  │ 1 │ Hidden    │  1  │ Should not show in dir listing     │
                                  │ 0 │ Read Only │  1  │ Should not allow writing           │
                                  └───┴───────────┴─────┴────────────────────────────────────┘
                                  Each entry in the file allocation table is 32 bits, entry 0 is associated with cluster 0, entry 1/cluster 1, and so on
                                   The 32-bit value contains 0 if the associated cluster is available
                                   contains $0FFF_FFFF if the data in the associated cluster ends in that cluster
                                   contains the address of the next cluster in the file if the file occupies multiple clusters
                                  ┌───────────┬───────────┬───────────┬───────────┐
              clusters $00 - $03  │ 0FFF_FFFF │ 0FFF_FFFF │ 0FFF_FFFF │ 0FFF_FFFF │  1st four clusters occupied by self-contained files
                       $04 - $07  │ 0000_0005 │ 0000_0006 │ 0000_0007 │ 0FFF_FFFF │  next four clusters occupied by a file in sequential clusters
                       $08 - $0B  │ 0000_000A │ 0FFF_FFFF │ 0000_000C │ 0FFF_FFFF │  a fragmented file starts in cluster 8, and occupies clusters 10, 12, and ends in 14
                       $0C - $0F  │ 0000_000E │ 0000_0000 │ 0FFF_FFFF │ 0000_0000 │  clusters 13 and 15 are unused
}}
CON
{{
┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                                   TERMS OF USE: MIT License                                                  │
├──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation    │
│files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,    │
│modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software│
│is furnished to do so, subject to the following conditions:                                                                   │
│                                                                                                                              │
│The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.│
│                                                                                                                              │
│THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE          │
│WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR         │
│COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,   │
│ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                         │
└──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
}}