{{┌──────────────────────────────────────────┐
  │ SD card driver V3 (Multi-File Handles)   │  Verified with Panasonic 512MB SD
  │ Original: Chris Gadd, V3: S.M. Moraco    │                PNY 8GB SDHC
  │ Copyright (c) 2023 Chris Gadd            │                SanDisk Extreme 32GB SDHC                                       3V3
  │ See end of file for terms of use.        │                GSKILL 32GB Micro SDHC                                              ┌─────┐
  └──────────────────────────────────────────┘  cards must be formatted as FAT32                                               │   ┤ Read / write        ├─────┐
                                                                                                                             ─┼───┤ CS                  │     │
  sd.mount(CS,MOSI,MISO,SCK)                            ' mount SD card                                                      ─┼───┤ MOSI                │     │
  sd.newDirectory(string("folder1"))                    ' create a new directory                                               │ ┌─┤ Gnd                 │     │
  sd.changeDirectory(string("folder1"))                 ' switch to newly created directory                                    └─┼─┤ Vcc                 │     │
  sd.newFile(string("fileA.txt"))                       ' create a new file, leaves file open for writing                    ───┼─┤ SCK                 │     │
  sd.writeString(string("this is file A"))              ' write to newly created file                                            ┣─┤ Gnd                 │     │
  sd.closeFile()                                        ' close file, update filesize information                            ───┼─┤ MISO                │     │
                                                                                                                                 │ ┤ IRQ                 │     │
  sd.openFile(string("fileA.txt"))                      ' open file in current directory                                         │ ┤ Card detect         │     │
  -or-                                                  ' -or-                                                                   │ ┤ Write protect       ├─────┘
  sd.openFile(string("/folder1/fileA.txt"))             ' open file from path (1st "/" resets directory to root)                 │ └─┳───────────────────┘
  sd.read(@buffer,sd.fileSize())                        ' read opened file into buffer                                              
  debug(zstr(@buffer))
}}

'' ═══════════════════════════════════════════════════════════════════════════════
'' CONDITIONAL COMPILATION - Optional Feature Modules
'' ═══════════════════════════════════════════════════════════════════════════════
'' Default: MINIMAL driver (core file operations only)
'' To enable optional features, use #PRAGMA EXPORTDEF in your top-level file:
''
''   #PRAGMA EXPORTDEF SD_INCLUDE_RAW        ' Raw sector access
''   #PRAGMA EXPORTDEF SD_INCLUDE_REGISTERS  ' Card register access (CID/CSD/SCR)
''   #PRAGMA EXPORTDEF SD_INCLUDE_SPEED      ' High-speed mode control
''
''   OBJ
''       sd : "SD_card_driver"
''
'' Or define SD_INCLUDE_ALL to include everything:
''   #PRAGMA EXPORTDEF SD_INCLUDE_ALL
'' ═══════════════════════════════════════════════════════════════════════════════

#IFDEF SD_INCLUDE_ALL
  #IFNDEF SD_INCLUDE_RAW
    #DEFINE SD_INCLUDE_RAW
  #ENDIF
  #IFNDEF SD_INCLUDE_REGISTERS
    #DEFINE SD_INCLUDE_REGISTERS
  #ENDIF
  #IFNDEF SD_INCLUDE_SPEED
    #DEFINE SD_INCLUDE_SPEED
  #ENDIF
#ENDIF

CON  '' flags
  ' NOTE: V3 driver exceeds 255 debug record limit when debug is fully enabled
  ' pnut-ts error: "DEBUG data is too long: too many records: max 255"
  ' Set to 1 to disable debug in driver and avoid compilation errors
  DEBUG_DISABLE = 1

  F_OPEN    = decod 0
  F_NEWDIR  = decod 1
  F_NEWDATA = decod 2
  F_MOUNTED = decod 3

CON '' driver mode (enforces valid command sequences)
  MODE_NONE       = 0       ' Not initialized - only mount() or initCardOnly() allowed
  MODE_RAW        = 1       ' Raw sector access only - initCardOnly() was called
  MODE_FILESYSTEM = 2       ' Full filesystem access - mount() was called

CON '' command codes for worker cog
  CMD_NONE      = 0         ' Idle / command complete
  CMD_MOUNT     = 1         ' Mount filesystem
  CMD_UNMOUNT   = 2         ' Unmount filesystem
  CMD_OPEN      = 3         ' Open file: param0=filename ptr
  CMD_CLOSE     = 4         ' Close file
  CMD_READ      = 5         ' Read: param0=buffer ptr, param1=count
  CMD_WRITE     = 6         ' Write: param0=buffer ptr, param1=count
  CMD_SEEK      = 7         ' Seek: param0=position
  CMD_NEWFILE   = 8         ' Create new file: param0=filename ptr
  CMD_NEWDIR    = 9         ' Create new directory: param0=dirname ptr
  CMD_DELETE    = 10        ' Delete file: param0=filename ptr
  CMD_RENAME    = 11        ' Rename: param0=oldname, param1=newname
  CMD_CHDIR     = 12        ' Change directory: param0=dirname ptr
  CMD_READDIR   = 13        ' Read directory entry: param0=index
  CMD_FILESIZE  = 14        ' Get file size
  CMD_FREESPACE = 15        ' Get free space
  CMD_SYNC      = 16        ' Flush buffers
  CMD_MOVEFILE  = 17        ' Move file: param0=name, param1=dest folder
  CMD_DEBUG_SLOW_READ  = 25 ' DEBUG: Byte-by-byte sector read (no streamer)
  CMD_DEBUG_CLEAR_ROOT = 26 ' DEBUG: Clear root directory (fixes corruption)

#IFDEF SD_INCLUDE_RAW
  CMD_INIT_CARD_ONLY = 22   ' Initialize card without filesystem (raw mode)
  CMD_GET_CARD_SIZE  = 23   ' Get card size in sectors: returns in data0
  CMD_READ_SECTORS  = 18    ' Raw multi-block read: param0=start_sector, param1=count, param2=buffer ptr
  CMD_WRITE_SECTORS = 19    ' Raw multi-block write: param0=start_sector, param1=count, param2=buffer ptr
  CMD_READ_SECTOR_RAW  = 20 ' Raw single sector read: param0=sector, param1=buffer ptr
  CMD_WRITE_SECTOR_RAW = 21 ' Raw single sector write: param0=sector, param1=buffer ptr
#ENDIF

#IFDEF SD_INCLUDE_REGISTERS
  CMD_READ_SCR       = 24   ' Read SCR register: param0=buffer ptr
  CMD_READ_CID         = 27 ' Read CID register: param0=buffer ptr
  CMD_READ_CSD         = 28 ' Read CSD register: param0=buffer ptr
#ENDIF

  ' ═══════════════════════════════════════════════════════════════════════════
  ' V3 Handle-Based File Commands (multi-file support)
  ' ═══════════════════════════════════════════════════════════════════════════
  CMD_OPEN_READ   = 30      ' Open file for reading: param0=path ptr, returns data0=handle
  CMD_OPEN_WRITE  = 31      ' Open file for writing (append): param0=path ptr, returns data0=handle
  CMD_CREATE      = 32      ' Create new file for writing: param0=path ptr, returns data0=handle
  CMD_CLOSE_H     = 33      ' Close file handle: param0=handle
  CMD_READ_H      = 34      ' Read from handle: param0=handle, param1=buffer ptr, param2=count, returns data0=bytes_read
  CMD_WRITE_H     = 35      ' Write to handle: param0=handle, param1=buffer ptr, param2=count, returns data0=bytes_written
  CMD_SEEK_H      = 36      ' Seek in handle: param0=handle, param1=position
  CMD_TELL_H      = 37      ' Get position: param0=handle, returns data0=position
  CMD_FILESIZE_H  = 38      ' Get file size: param0=handle, returns data0=size
  CMD_SYNC_H      = 39      ' Sync handle buffer to disk: param0=handle
  CMD_SYNC_ALL    = 40      ' Sync all open file handles
  CMD_EOF_H       = 41      ' Check end of file: param0=handle, returns data0=true/false
  CMD_OPEN_DIR    = 43      ' Open directory: param0=path ptr, returns data0=handle
  CMD_READ_DIR_H  = 44      ' Read next dir entry: param0=handle, returns data0=ptr
  CMD_CLOSE_DIR_H = 45      ' Close directory handle: param0=handle

CON '' buffer types for sector read/write (diagnostic: separate buffers to isolate conflicts)
  BUF_DIR  = 0      ' Directory sector buffer
  BUF_FAT  = 1      ' FAT sector buffer
  BUF_DATA = 2      ' Data sector buffer

CON '' error codes
  SUCCESS           = 0
  E_TIMEOUT         = -1        ' Card didn't respond in time
  E_NO_RESPONSE     = -2        ' Card not responding
  E_BAD_RESPONSE    = -3        ' Unexpected response from card
  E_CRC_ERROR       = -4        ' Data CRC mismatch
  E_WRITE_REJECTED  = -5        ' Card rejected write operation
  E_CARD_BUSY       = -6        ' Card busy
  E_IO_ERROR        = -7        ' General I/O error during read/write
  E_NOT_MOUNTED     = -20       ' Filesystem not mounted
  E_INIT_FAILED     = -21       ' Card initialization failed
  E_NOT_FAT32       = -22       ' Card not formatted as FAT32
  E_BAD_SECTOR_SIZE = -23       ' Sector size not 512 bytes
  E_FILE_NOT_FOUND  = -40       ' File doesn't exist
  E_FILE_EXISTS     = -41       ' File already exists
  E_NOT_A_FILE      = -42       ' Expected file, found directory
  E_NOT_A_DIR       = -43       ' Expected directory, found file
  E_FILE_NOT_OPEN   = -45       ' File not open
  E_END_OF_FILE     = -46       ' Read past end of file
  E_DISK_FULL       = -60       ' No free clusters
  E_NO_LOCK         = -64       ' Couldn't allocate hardware lock

  ' ═══════════════════════════════════════════════════════════════════════════
  ' V3 Multi-File Handle Error Codes
  ' ═══════════════════════════════════════════════════════════════════════════
  E_TOO_MANY_FILES    = -90     ' All file handles are in use
  E_INVALID_HANDLE    = -91     ' Handle out of range or not open
  E_FILE_ALREADY_OPEN = -92     ' File is already open for writing (single-writer policy)
  E_NOT_A_DIR_HANDLE  = -93     ' Handle is not a directory handle (or vice versa)

CON '' V3 multi-file handle configuration
  ' ═══════════════════════════════════════════════════════════════════════════
  ' FILE HANDLE SYSTEM - V3 supports multiple simultaneously open files
  ' User can override MAX_OPEN_FILES in their top-level CON section before OBJ
  ' Memory cost: 544 bytes per handle (28 bytes state + 512 bytes buffer + 4 bytes tracking)
  ' ═══════════════════════════════════════════════════════════════════════════
  MAX_OPEN_FILES = 4            ' Default number of file handles (user-overridable)

  ' Handle state flags (stored in h_flags array)
  HF_FREE   = 0                 ' Handle slot is available
  HF_READ   = 1                 ' Handle is open for reading
  HF_WRITE  = 2                 ' Handle is open for writing
  HF_DIR    = 4                 ' Handle is a directory enumeration handle
  HF_DIRTY  = $80               ' Handle's buffer has pending writes (OR'd with mode)

CON '' worker cog stack size
  STACK_SIZE = 128              ' 128 longs = 512 bytes

CON '' streamer configuration (compile-time constants for bulk sector transfers)
  ' Reference: flash_loader.spin2 pattern, P2 Silicon Doc streamer section
  ' Using explicit hex values from working flash_loader code:
  ' Mode word: [31:28]=mode [27:24]=options [23:17]=pin [16:0]=count
  ' $C0 = 1-pin input to WFBYTE (RX), $80 = RFBYTE to 1-pin output (TX)
  ' $81 = X_ALT_ON (MSB-first, bit 7) + X_WRITE_ON/X_PINS_ON (bit 0)
  STREAM_RX_BASE = $C081_0000   ' 1-pin input to hub, MSB-first (flash_loader wmode)
  STREAM_TX_BASE = $8081_0000   ' hub to 1-pin output, MSB-first (flash_loader rmode)

CON '' CRC-16-CCITT configuration (using P2 GETCRC instruction)
  ' Replaces 512-byte lookup table with hardware GETCRC + transformation
  ' Formula: crc := ((GETCRC(@data, CRC_POLY, 512) ^ CRC_BASE_512) REV 31) >> 16
  CRC_POLY_REFLECTED = $8408    ' CRC-16-CCITT in LSB-first (reflected) form
  CRC_BASE_512       = $2C68    ' GETCRC of 512 zero bytes with poly $8408

CON '' SD card command codes and tokens for multi-block operations
  ' ═══════════════════════════════════════════════════════════════════════════
  ' SD SPI Commands for multi-block operations (reference: SD Physical Layer Spec)
  ' ═══════════════════════════════════════════════════════════════════════════
  CMD12  = 12                   ' STOP_TRANSMISSION - terminates multi-block read/write
  CMD13  = 13                   ' SEND_STATUS - get card status register (R2 response)
  CMD18  = 18                   ' READ_MULTIPLE_BLOCK - read consecutive sectors
  CMD25  = 25                   ' WRITE_MULTIPLE_BLOCK - write consecutive sectors

  ' ═══════════════════════════════════════════════════════════════════════════
  ' Card Status Register (CSR) bits - returned by CMD13 (R2 response = R1 + status byte)
  ' Reference: SD Physical Layer Spec section 4.10.1
  ' ═══════════════════════════════════════════════════════════════════════════
  ' R2 response is 2 bytes: first byte = R1, second byte = status flags
  ' Status byte bit definitions (directly from SD spec):
  CSR_CARD_IS_LOCKED    = $01  ' Bit 0: Card is locked
  CSR_WP_ERASE_SKIP     = $02  ' Bit 1: Write protect erase skip / lock/unlock cmd failed
  CSR_ERROR             = $04  ' Bit 2: General/unknown error
  CSR_CC_ERROR          = $08  ' Bit 3: Card controller error
  CSR_CARD_ECC_FAILED   = $10  ' Bit 4: Card internal ECC failed
  CSR_WP_VIOLATION      = $20  ' Bit 5: Write protect violation
  CSR_ERASE_PARAM       = $40  ' Bit 6: Invalid erase parameter
  CSR_OUT_OF_RANGE      = $80  ' Bit 7: Out of range / CSD overwrite error

  ' ═══════════════════════════════════════════════════════════════════════════
  ' SD SPI Data Tokens (reference: SD Physical Layer Spec section 7.3.3)
  ' ═══════════════════════════════════════════════════════════════════════════
  TOKEN_START_BLOCK      = $FE ' Start token for single-block read/write and multi-block read
  TOKEN_START_MULTI_WRITE = $FC ' Start token for each block in multi-block WRITE
  TOKEN_STOP_TRAN        = $FD ' Stop token to terminate multi-block WRITE (not CMD12!)

  ' Data Response Token format (after each block write): xxx0sss1
  ' sss = status: 010 = accepted, 101 = CRC error, 110 = write error
  DATA_ACCEPTED          = $05 ' Lower 5 bits = xxx00101 = data accepted
  DATA_CRC_ERROR         = $0B ' Lower 5 bits = xxx01011 = CRC error
  DATA_WRITE_ERROR       = $0D ' Lower 5 bits = xxx01101 = write error

DAT '' singleton control - SHARED across all object instances
  ' ═══════════════════════════════════════════════════════════════════════
  ' SINGLETON CONTROL - Must be initialized to "not started" state
  ' ═══════════════════════════════════════════════════════════════════════
  cog_id        LONG    -1              ' Worker cog ID (-1 = not started)
  api_lock      LONG    -1              ' Hardware lock ID (-1 = not allocated)
  driver_mode   LONG    0               ' Current mode: MODE_NONE, MODE_RAW, or MODE_FILESYSTEM

  ' ═══════════════════════════════════════════════════════════════════════
  ' CMD13 STATUS STAGING - Preserved for diagnostic inspection
  ' ═══════════════════════════════════════════════════════════════════════
  last_cmd13_r1     BYTE    0           ' Last R1 byte from CMD13
  last_cmd13_status BYTE    0           ' Last STATUS byte from CMD13
  last_cmd13_error  WORD    0           ' Last non-zero R2 (preserved until next error)

  ' ═══════════════════════════════════════════════════════════════════════
  ' PARAMETER BLOCK - Communication between API and worker cog
  ' ═══════════════════════════════════════════════════════════════════════
  pb_cmd        LONG    0               ' Command (0 = idle/done)
  pb_status     LONG    0               ' Result status code
  pb_caller     LONG    0               ' Caller's cog ID (for COGATN signal)
  pb_param0     LONG    0               ' Parameter 0 (varies by command)
  pb_param1     LONG    0               ' Parameter 1
  pb_param2     LONG    0               ' Parameter 2
  pb_param3     LONG    0               ' Parameter 3
  pb_data0      LONG    0               ' Result data 0 (handle, count, etc.)
  pb_data1      LONG    0               ' Result data 1

  ' ═══════════════════════════════════════════════════════════════════════
  ' WORKER COG STACK
  ' ═══════════════════════════════════════════════════════════════════════
  cog_stack     LONG    0[STACK_SIZE]   ' Worker cog stack

  ' ═══════════════════════════════════════════════════════════════════════
  ' SPI PIN CONFIGURATION (set once at start)
  ' ═══════════════════════════════════════════════════════════════════════
  cs            LONG    0               ' Chip select pin
  mosi          LONG    0               ' Master out, slave in pin
  miso          LONG    0               ' Master in, slave out pin
  sck           LONG    0               ' Serial clock pin

  ' ═══════════════════════════════════════════════════════════════════════
  ' SMART PIN SPI CONFIGURATION (Phase 1 Performance Sprint)
  ' P_TRANSITION for clock, P_SYNC_TX for transmit, P_SYNC_RX for receive
  ' B-input offset links MOSI/MISO to SCK for synchronized operation
  ' ═══════════════════════════════════════════════════════════════════════
  spi_clk_mode  LONG    0               ' P_PULSE | P_OE for SCK
  spi_tx_mode   LONG    0               ' P_SYNC_TX | P_OE for MOSI
  spi_rx_mode   LONG    0               ' P_SYNC_RX for MISO
  spi_period    LONG    0               ' Current SPI half-period (for sysclk-independent timing)
  spi_freq      LONG    0               ' Actual achieved SPI frequency (Hz)
  spi_event     LONG    0               ' Event config for waitse1 (%01_000000 | sck)
  use_smartpin  LONG    0               ' 0 = bit-bang (fallback), 1 = smart pin mode
  sp_debug_ctr  LONG    0               ' Debug counter for sp_transfer_8

  ' ═══════════════════════════════════════════════════════════════════════
  ' FILESYSTEM STATE (moved from VAR)
  ' ═══════════════════════════════════════════════════════════════════════
  fat_sec       LONG    0               ' Starting sector of FAT
  fat2_sec      LONG    0               ' Starting sector of FAT2 (mirror)
  sec_per_fat   LONG    0               ' Sectors per FAT
  sec_per_clus  LONG    0               ' Sectors per cluster
  root_sec      LONG    0               ' Starting sector of root directory
  cluster_offset LONG   0               ' Cluster offset calculation
  cog_dir_sec   LONG    0[8]            ' Per-cog current directory sector
  entry_address LONG    0               ' Current entry byte address
  date_stamp    LONG    0               ' Timestamp for new files
  n_sec         LONG    0               ' Current sector number
  file_idx      LONG    0               ' Position within file
  flags         LONG    0               ' Open/new file flags
  dir_sec_in_buf LONG   0               ' Directory sector currently in dir_buf
  fat_sec_in_buf LONG   0               ' FAT sector currently in fat_buf
  sec_in_buf    LONG    0               ' Data sector currently in buf
  bit_delay     LONG    0               ' SPI bit delay
  hcs           LONG    0               ' High capacity support flag
  fsinfo_sec    LONG    0               ' FSInfo sector number
  fsi_free_count LONG   0               ' Cached free cluster count
  fsi_nxt_free  LONG    0               ' Cached next free cluster hint
  vbr_sec       LONG    0               ' Volume Boot Record sector
  ocr_value     LONG    0               ' Cached OCR register (from CMD58)

  ' ═══════════════════════════════════════════════════════════════════════
  ' ADAPTIVE TIMING (Phase 2 - Card identification and speed adjustment)
  ' ═══════════════════════════════════════════════════════════════════════
  card_mfr_id   LONG    0               ' Manufacturer ID from CID (byte 0)
  card_max_speed_hz LONG 0              ' Maximum speed from CSD TRAN_SPEED (Hz)
  card_is_slow  LONG    0               ' Flag: 1 = card requires conservative timing (e.g., PNY)
  card_read_timeout_ms  LONG  100       ' Read timeout in ms (from CSD or spec default)
  card_write_timeout_ms LONG  500       ' Write timeout in ms (from CSD or spec default)

  ' ═══════════════════════════════════════════════════════════════════════
  ' PER-COG ERROR STORAGE (for thread-safe error reporting)
  ' ═══════════════════════════════════════════════════════════════════════
  last_error    LONG    0[8]            ' One slot per possible cog

  ' ═══════════════════════════════════════════════════════════════════════
  ' DIAGNOSTIC: Capture data inside readSector for debugging from test cog
  ' ═══════════════════════════════════════════════════════════════════════
  diag_last_sector   LONG    0          ' Last sector read
  diag_last_buftype  LONG    0          ' Last buf_type used
  diag_last_token    LONG    0          ' Last start token received
  diag_buf_byte0     LONG    0          ' First byte of buffer after streamer
  diag_buf_byte1     LONG    0          ' Second byte
  diag_buf_byte2     LONG    0          ' Third byte
  diag_buf_byte3     LONG    0          ' Fourth byte
  diag_p_buf         LONG    0          ' Buffer pointer used
  diag_before_b0     LONG    0          ' Buffer byte 0 BEFORE streamer
  diag_before_b1     LONG    0          ' Buffer byte 1 BEFORE streamer
  diag_before_b2     LONG    0          ' Buffer byte 2 BEFORE streamer
  diag_before_b3     LONG    0          ' Buffer byte 3 BEFORE streamer
  diag_spi_period    LONG    0          ' SPI period at time of read
  diag_recv_crc      WORD    0          ' CRC-16 received from card (high byte first)
  diag_calc_crc      WORD    0          ' CRC-16 calculated from data
  diag_sent_crc      WORD    0          ' CRC-16 sent with write data
  diag_crc_matches   LONG    0          ' Count of CRC matches (reads)
  diag_crc_mismatches LONG   0          ' Count of CRC mismatches (reads)
  diag_crc_enabled   BYTE    1          ' CRC validation enabled (1=on, 0=off)

  ' ═══════════════════════════════════════════════════════════════════════
  ' BUFFERS (must be in DAT for worker cog access)
  ' DIAGNOSTIC: Separate buffers for each sector type to isolate conflicts
  ' ═══════════════════════════════════════════════════════════════════════
  dir_buf       BYTE    0[512]          ' Directory sector buffer
  fat_buf       BYTE    0[512]          ' FAT sector buffer
  buf           BYTE    0[512]          ' Data sector buffer
  entry_buffer  BYTE    0[32]           ' Directory entry buffer
  vol_label     BYTE    0[12]           ' Volume label (11 chars + null)

  ' ═══════════════════════════════════════════════════════════════════════════
  ' V3 FILE HANDLE TABLE - 28 bytes per handle
  ' Each handle tracks an independently open file with its own state
  ' ═══════════════════════════════════════════════════════════════════════════
  h_flags       BYTE    0[MAX_OPEN_FILES]     ' Handle state: HF_FREE, HF_READ, HF_WRITE (| HF_DIRTY)
  h_attr        BYTE    0[MAX_OPEN_FILES]     ' FAT directory entry attributes byte
  h_dir_offset  WORD    0[MAX_OPEN_FILES]     ' Offset of dir entry within sector (0-511)
  h_position    LONG    0[MAX_OPEN_FILES]     ' Current byte position in file
  h_sector      LONG    0[MAX_OPEN_FILES]     ' Current sector number being accessed
  h_start_clus  LONG    0[MAX_OPEN_FILES]     ' First cluster of file (from dir entry)
  h_size        LONG    0[MAX_OPEN_FILES]     ' File size in bytes
  h_dir_sector  LONG    0[MAX_OPEN_FILES]     ' Sector containing directory entry
  h_cluster     LONG    0[MAX_OPEN_FILES]     ' Current cluster in FAT chain

  ' ═══════════════════════════════════════════════════════════════════════════
  ' V3 PER-HANDLE DATA BUFFERS - 512 bytes per handle
  ' Each handle has its own buffer to eliminate thrashing when switching files
  ' Cost: 512 bytes per handle, but provides significant performance benefit
  ' ═══════════════════════════════════════════════════════════════════════════
  h_buf         BYTE    0[512 * MAX_OPEN_FILES]   ' Per-handle sector buffers
  h_buf_sector  LONG    0[MAX_OPEN_FILES]         ' Sector currently in each buffer (-1 = invalid)

PUB null()
'' This is not a top-level object - placeholder to indicate driver must be instantiated as OBJ.

CON '' ═══════════════════════════════════════════════════════════════════════════
    '' MULTI-COG LIFECYCLE METHODS
    '' ═══════════════════════════════════════════════════════════════════════════

PUB start(_cs, _mosi, _miso, _sck) : result
'' Start worker cog (singleton) - initialize SD card driver and launch dedicated worker cog.
'' This method is idempotent - calling multiple times is safe.
''
'' @param _cs - Chip select pin number
'' @param _mosi - Master Out Slave In pin number
'' @param _miso - Master In Slave Out pin number
'' @param _sck - Serial clock pin number
'' @returns result - Cog ID (0-7) on success, -1 on failure

  ' Check if already started (singleton pattern)
  if cog_id <> -1
    debug("  [start] Already started (cog ", udec_(cog_id), ")")
    return cog_id

  ' Store pin configuration
  longmove(@cs, @_cs, 4)

  ' Allocate hardware lock for API serialization
  api_lock := locknew()
  if api_lock == -1
    debug("  [start] FAIL: Could not allocate lock")
    return set_error(E_NO_LOCK)

  ' Initialize parameter block
  pb_cmd := CMD_NONE
  pb_status := SUCCESS
  sec_in_buf := -1                                                              ' Invalidate buffer

  ' Launch worker cog
  cog_id := cogspin(NEWCOG, fs_worker(), @cog_stack)
  if cog_id == -1
    lockret(api_lock)
    api_lock := -1
    debug("  [start] FAIL: Could not start worker cog")
    return set_error(E_NO_LOCK)

  debug("  [start] Worker cog ", udec_(cog_id), " started, lock ", udec_(api_lock))
  return cog_id

PUB stop()
'' Stop worker cog - cleanly shut down the worker cog and release resources.
'' Safe to call even if not started.

  if cog_id <> -1
    ' Send unmount command if mounted
    if flags & F_MOUNTED
      send_command(CMD_UNMOUNT, 0, 0, 0, 0)

    ' Stop the worker cog
    cogstop(cog_id)
    debug("  [stop] Worker cog ", udec_(cog_id), " stopped")
    cog_id := -1

  ' Release hardware lock
  if api_lock <> -1
    lockret(api_lock)
    api_lock := -1

  ' Clear state
  driver_mode := MODE_NONE   ' Reset mode so next init/mount starts fresh
  flags := 0
  sec_in_buf := -1

PUB error() : status
'' Get last error for this cog - returns the error code from the most recent operation.
'' Thread-safe: each cog has its own error slot.
''
'' @returns status - Error code from the most recent operation on this cog

  return LONG[@last_error][COGID()]

PUB getLastCMD13() : r2
'' Get last CMD13 result (R1 in high byte, STATUS in low byte).
'' Value is from most recent CMD13, regardless of success/failure.
''
'' @returns r2 - Combined R2 response word

  return (last_cmd13_r1 << 8) | last_cmd13_status

PUB getLastCMD13Error() : r2
'' Get last CMD13 error - returns last non-zero CMD13 result (preserved until next error).
'' Useful for diagnostics - shows most recent error even after recovery.
''
'' @returns r2 - Last non-zero R2 response word

  return last_cmd13_error

PUB getLastReceivedCRC() : crc
'' Get CRC-16 from last sector read - returns the 16-bit CRC received from the SD card
'' after the most recent sector read operation. Use for validating CRC algorithm.
''
'' @returns crc - 16-bit CRC the card calculated and sent

  return diag_recv_crc

PUB getLastCalculatedCRC() : crc
'' Get CRC-16 calculated from data - returns the 16-bit CRC we calculated from received data.
'' Should match getLastReceivedCRC() if data transfer was clean.
''
'' @returns crc - 16-bit CRC calculated from data

  return diag_calc_crc

PUB getLastSentCRC() : crc
'' Get CRC-16 sent with last write - returns the 16-bit CRC we calculated and sent.
''
'' @returns crc - 16-bit CRC sent with the last write operation

  return diag_sent_crc

PUB getCRCMatchCount() : count
'' Get count of CRC matches - returns number of sector reads where CRC matched.
''
'' @returns count - Number of sector reads where calculated CRC matched received CRC

  return diag_crc_matches

PUB getCRCMismatchCount() : count
'' Get count of CRC mismatches - returns number of sector reads where CRC did NOT match.
'' Non-zero indicates data corruption occurred during transfer.
''
'' @returns count - Number of sector reads where CRC did not match

  return diag_crc_mismatches

PUB setCRCValidation(enabled)
'' Enable/disable CRC validation for sector reads.
'' When enabled, each sector read validates CRC and updates match/mismatch counts.
''
'' @param enabled - TRUE (non-zero) enables CRC checking, FALSE (0) disables

  diag_crc_enabled := (enabled <> 0) ? 1 : 0

PRI set_error(code) : code_out
' Set error code for this cog - store error code in per-cog slot and return the code.
'
' @param code - Error code to store
' @returns code_out - The same error code (for chained returns)

  LONG[@last_error][COGID()] := code
  return code

PRI fs_worker() | cur_cmd
' Worker cog main loop - runs in the dedicated worker cog.
' Owns the SPI pins and handles all filesystem operations.
'
' @local cur_cmd - Current command being processed

  debug("  [fs_worker] Starting on cog ", udec_(COGID()))

  ' Initialize SPI pins (this cog owns them)
  pinh(cs)                                                                      ' CS HIGH = deselected
  pinh(mosi)                                                                    ' MOSI HIGH idle
  pinl(sck)                                                                     ' SCK LOW (SPI mode 0)

  debug("  [fs_worker] Pins initialized: CS=P", udec_(cs), " MOSI=P", udec_(mosi), " MISO=P", udec_(miso), " SCK=P", udec_(sck))

  ' Main command loop
  repeat
    ' Wait for command (polling - will optimize to WAITATN later)
    repeat until (cur_cmd := pb_cmd) <> CMD_NONE

    debug("  [fs_worker] Received command ", udec_(cur_cmd))

    ' ═══════════════════════════════════════════════════════════════════════
    ' MODE ENFORCEMENT: Reject commands invalid for current mode
    ' ═══════════════════════════════════════════════════════════════════════
    ' File system commands require MODE_FILESYSTEM
    ' Raw sector commands are allowed in both MODE_RAW and MODE_FILESYSTEM
    ' Mode transitions (MOUNT, UNMOUNT, INIT_CARD_ONLY) have their own logic
    ' V3: Include handle-based commands (CMD_OPEN_READ through CMD_CLOSE_DIR_H)
    if (cur_cmd >= CMD_OPEN and cur_cmd <= CMD_MOVEFILE) or (cur_cmd >= CMD_OPEN_READ and cur_cmd <= CMD_CLOSE_DIR_H)
      if driver_mode <> MODE_FILESYSTEM
        debug("  [fs_worker] REJECTED: File operation requires MODE_FILESYSTEM")
        pb_status := E_NOT_MOUNTED
        pb_data0 := E_NOT_MOUNTED
        pb_cmd := CMD_NONE
        COGATN(1 << pb_caller)
        next                                                                    ' Skip to next command

    ' Dispatch command
    case cur_cmd
      CMD_MOUNT:
        pb_status := do_mount()

      CMD_UNMOUNT:
        pb_status := do_unmount()

      CMD_OPEN:
        pb_status := do_open(pb_param0)

      CMD_CLOSE:
        do_close()
        pb_status := SUCCESS

      CMD_READ:
        pb_data0 := do_read(pb_param0, pb_param1)
        pb_status := SUCCESS

      CMD_WRITE:
        do_write(pb_param0, pb_param1)
        pb_status := SUCCESS

      CMD_SEEK:
        pb_status := do_seek(pb_param0)

      CMD_NEWFILE:
        pb_status := do_newfile(pb_param0)

      CMD_NEWDIR:
        pb_status := do_newdir(pb_param0)

      CMD_DELETE:
        pb_status := do_delete(pb_param0)

      CMD_CHDIR:
        pb_status := do_chdir(pb_param0)

      CMD_FILESIZE:
        pb_data0 := fileSize()
        pb_status := SUCCESS

      CMD_FREESPACE:
        pb_data0 := do_freespace()
        pb_status := SUCCESS

      CMD_SYNC:
        do_sync()
        pb_status := SUCCESS

      CMD_RENAME:
        pb_status := do_rename(pb_param0, pb_param1)

      CMD_MOVEFILE:
        pb_status := do_movefile(pb_param0, pb_param1)

      CMD_READDIR:
        pb_status := do_readdir(pb_param0)

      CMD_DEBUG_SLOW_READ:
        ' DEBUG: Read sector byte-by-byte without streamer for comparison
        pb_status := readSectorSlow(pb_param0, pb_param1)

      CMD_DEBUG_CLEAR_ROOT:
        ' DEBUG: Clear root directory by writing zeros
        bytefill(@buf, 0, 512)                                                  ' Zero the buffer
        if writeSector(root_sec, BUF_DATA)                                      ' Write to root directory
          dir_sec_in_buf := -1                                                  ' Invalidate cache
          pb_status := SUCCESS
        else
          pb_status := E_IO_ERROR

#IFDEF SD_INCLUDE_RAW
      CMD_READ_SECTORS:
        pb_data0 := readSectors(pb_param0, pb_param1, pb_param2)
        pb_status := SUCCESS

      CMD_WRITE_SECTORS:
        pb_data0 := writeSectors(pb_param0, pb_param1, pb_param2)
        pb_status := SUCCESS

      CMD_READ_SECTOR_RAW:
        sec_in_buf := -1                                                        ' Force re-read
        if readSector(pb_param0, BUF_DATA) == 0                                 ' readSector returns 0 on success, -1 on error
          bytemove(pb_param1, @buf, 512)
          pb_status := SUCCESS
        else
          pb_status := E_IO_ERROR

      CMD_WRITE_SECTOR_RAW:
        bytemove(@buf, pb_param1, 512)
        if writeSector(pb_param0, BUF_DATA)                                     ' writeSector returns true on success
          pb_status := SUCCESS
        else
          pb_status := E_IO_ERROR

      CMD_INIT_CARD_ONLY:
        pb_status := do_init_card_only()

      CMD_GET_CARD_SIZE:
        pb_data0 := do_get_card_size()
        pb_status := SUCCESS
#ENDIF

#IFDEF SD_INCLUDE_REGISTERS
      CMD_READ_SCR:
        pb_status := do_read_scr(pb_param0)

      CMD_READ_CID:
        pb_status := do_read_cid(pb_param0)

      CMD_READ_CSD:
        pb_status := do_read_csd(pb_param0)
#ENDIF

      ' ═══════════════════════════════════════════════════════════════════════
      ' V3 Handle-Based File Commands
      ' ═══════════════════════════════════════════════════════════════════════
      CMD_OPEN_READ:
        pb_data0 := do_open_read(pb_param0)                                       ' Returns handle or error
        pb_status := pb_data0 < 0 ? pb_data0 : SUCCESS

      CMD_OPEN_WRITE:
        pb_data0 := do_open_write(pb_param0)                                      ' Returns handle or error
        pb_status := pb_data0 < 0 ? pb_data0 : SUCCESS

      CMD_CREATE:
        pb_data0 := do_create(pb_param0)                                          ' Returns handle or error
        pb_status := pb_data0 < 0 ? pb_data0 : SUCCESS

      CMD_CLOSE_H:
        pb_status := do_close_h(pb_param0)                                        ' param0 = handle

      CMD_READ_H:
        pb_data0 := do_read_h(pb_param0, pb_param1, pb_param2)                    ' handle, buffer, count -> bytes_read
        pb_status := pb_data0 < 0 ? pb_data0 : SUCCESS

      CMD_WRITE_H:
        pb_data0 := do_write_h(pb_param0, pb_param1, pb_param2)                   ' handle, buffer, count -> bytes_written
        pb_status := pb_data0 < 0 ? pb_data0 : SUCCESS

      CMD_SEEK_H:
        pb_status := do_seek_h(pb_param0, pb_param1)                              ' handle, position

      CMD_TELL_H:
        if validateHandle(pb_param0)
          if h_flags[pb_param0] & HF_DIR
            pb_status := E_NOT_A_DIR_HANDLE
          else
            pb_data0 := h_position[pb_param0]
            pb_status := SUCCESS
        else
          pb_status := E_INVALID_HANDLE

      CMD_FILESIZE_H:
        if validateHandle(pb_param0)
          if h_flags[pb_param0] & HF_DIR
            pb_status := E_NOT_A_DIR_HANDLE
          else
            pb_data0 := h_size[pb_param0]
            pb_status := SUCCESS
        else
          pb_status := E_INVALID_HANDLE

      CMD_SYNC_H:
        pb_status := do_sync_h(pb_param0)                                         ' handle

      CMD_SYNC_ALL:
        pb_status := do_sync_all()

      CMD_EOF_H:
        if validateHandle(pb_param0)
          if h_flags[pb_param0] & HF_DIR
            pb_status := E_NOT_A_DIR_HANDLE
          else
            pb_data0 := h_position[pb_param0] >= h_size[pb_param0] ? 1 : 0
            pb_status := SUCCESS
        else
          pb_status := E_INVALID_HANDLE

      ' ═══════════════════════════════════════════════════════════════════════
      ' V3 Directory Handle Commands
      ' ═══════════════════════════════════════════════════════════════════════
      CMD_OPEN_DIR:
        pb_data0 := do_open_dir(pb_param0)                                           ' Returns handle or error
        pb_status := pb_data0 < 0 ? pb_data0 : SUCCESS

      CMD_READ_DIR_H:
        pb_status := do_read_dir_h(pb_param0)
        if pb_status == SUCCESS
          pb_data0 := @entry_buffer

      CMD_CLOSE_DIR_H:
        pb_status := do_close_dir_h(pb_param0)

      other:
        debug("  [fs_worker] Unknown command: ", udec_(cur_cmd))
        pb_status := E_BAD_RESPONSE

    ' Signal completion
    pb_cmd := CMD_NONE
    COGATN(1 << pb_caller)                                                      ' Wake the caller

PRI send_command(op_cmd, p0, p1, p2, p3) : status
' Send command to worker and wait - acquire lock, send command, wait for completion.
'
' @param op_cmd - Command opcode to send
' @param p0 - Parameter 0
' @param p1 - Parameter 1
' @param p2 - Parameter 2
' @param p3 - Parameter 3
' @returns status - Status code from worker

  ' Verify worker cog is running
  if cog_id == -1
    debug("  [send_command] ERROR: Worker not running")
    pb_data0 := E_NOT_MOUNTED
    return E_NOT_MOUNTED

  ' Acquire API lock (serialize multi-cog access)
  repeat until locktry(api_lock)

  ' Store caller ID and parameters
  pb_caller := COGID()
  pb_param0 := p0
  pb_param1 := p1
  pb_param2 := p2
  pb_param3 := p3

  ' Issue command (triggers worker)
  pb_cmd := op_cmd

  ' Wait for completion using WAITATN (efficient sleep)
  WAITATN()

  ' Get result
  status := pb_status

  ' Release lock
  lockrel(api_lock)

  return status

CON '' ═══════════════════════════════════════════════════════════════════════════
    '' V3 FILE HANDLE MANAGEMENT HELPERS
    '' ═══════════════════════════════════════════════════════════════════════════

PRI allocateHandle() : handle
' Find and allocate a free handle slot by searching the handle table.
' NOTE: Does not set h_flags - caller must do that after populating handle state.
'
' @returns handle - Handle index (0 to MAX_OPEN_FILES-1) on success, E_TOO_MANY_FILES if all in use

  repeat handle from 0 to MAX_OPEN_FILES - 1
    if h_flags[handle] == HF_FREE
      return handle                           ' Found a free slot

  return E_TOO_MANY_FILES                     ' No free slots available

PRI freeHandle(handle)
' Release a handle back to the free pool - clears all state and marks slot as available.
' Does NOT validate handle - caller must ensure handle is valid.
' Does NOT flush dirty buffers - caller must do that before calling.
'
' @param handle - Handle index to release

  h_flags[handle] := HF_FREE
  h_attr[handle] := 0
  h_dir_offset[handle] := 0
  h_position[handle] := 0
  h_sector[handle] := 0
  h_start_clus[handle] := 0
  h_size[handle] := 0
  h_dir_sector[handle] := 0
  h_cluster[handle] := 0
  h_buf_sector[handle] := -1                  ' Mark buffer as invalid

PRI validateHandle(handle) : result
' Check if handle is valid and in use - fast guard function for handle operations.
'
' @param handle - Handle index to validate
' @returns result - TRUE if valid and in use, FALSE if invalid or free

  if handle < 0 or handle >= MAX_OPEN_FILES
    return FALSE
  if h_flags[handle] == HF_FREE
    return FALSE
  return TRUE                                 ' Handle is valid and in use

PRI isFileOpenForWrite(dir_sector, dir_offset) : result | handle
' Check if file is already open for write - enforces single-writer policy.
' Multiple read handles allowed, only one write handle per file.
'
' @param dir_sector - Directory sector containing the file entry
' @param dir_offset - Offset within sector of the file entry
' @returns result - TRUE if file is open for write, FALSE otherwise
' @local handle - Loop variable for handle search

  result := FALSE
  repeat handle from 0 to MAX_OPEN_FILES - 1
    if h_flags[handle] & HF_WRITE             ' Check if handle has write access
      if h_dir_sector[handle] == dir_sector and h_dir_offset[handle] == dir_offset
        return TRUE                           ' File is already open for write

PRI getHandleBuffer(handle) : p_buffer
' Get pointer to handle's data buffer - each handle has a dedicated 512-byte buffer.
' Does NOT validate handle - caller must do that first.
'
' @param handle - Handle index
' @returns p_buffer - Address of the 512-byte buffer for this handle

  return @h_buf + (handle << 9)               ' handle * 512

PRI initHandleTable() | i
' Initialize all handles to free state - called during mount() for clean state.
' Releases all handles and invalidates all buffer cache tracking.
'
' @local i - Loop variable

  repeat i from 0 to MAX_OPEN_FILES - 1
    freeHandle(i)

CON '' ═══════════════════════════════════════════════════════════════════════════
    '' INTERNAL WORKER OPERATIONS (called by fs_worker, not directly by API)
    '' ═══════════════════════════════════════════════════════════════════════════

PRI do_mount() : result | reserved
' Internal mount operation - initializes card and reads filesystem structures.
'
' @returns result - SUCCESS on success, error code on failure
' @local reserved - Reserved sector count from VBR

  dir_sec_in_buf := -1
  fat_sec_in_buf := -1
  sec_in_buf := -1

  ' V3: Initialize handle table to clean state
  initHandleTable()

  ' Skip card init if already in RAW mode (card already initialized)
  ' This avoids reinitializing smart pins which would corrupt pin states
  if driver_mode == MODE_RAW
    debug("  [do_mount] Upgrading from RAW mode - skipping initCard()")
  else
    debug("  [do_mount] Calling initCard()...")
    if not initCard()
      debug("  [do_mount] FAIL: initCard() returned false")
      return E_INIT_FAILED

  ' Card is initialized (either fresh or from RAW mode)
  debug("  [do_mount] Reading MBR sector 0...")
  readSector(0, BUF_DATA)                                                       '  read master boot record
  debug("  [do_mount] MBR type code at $1C2: ", uhex_(buf[$1C2]))
  if buf[$1C2] == $0B or buf[$1C2] == $0C                                       '  offset $1C2 contains type code, $0B and $0C specify FAT32
    vbr_sec := long[@buf + $1C6]                                                '  offset $1C6 contains volume boot record sector number
    debug("  [do_mount] FAT32 detected, VBR at sector ", udec(vbr_sec))
    readSector(vbr_sec, BUF_DATA)                                               '  read volume boot record
  else
    debug("  [do_mount] FAIL: Not FAT32 (type=", uhex_(buf[$1C2]), ")")
    return E_NOT_FAT32
  debug("  [do_mount] Bytes/sector: ", udec(word[@buf + $0B]))
  if word[@buf + $0B] <> 512
    debug("  [do_mount] FAIL: Bytes/sector not 512")
    return E_BAD_SECTOR_SIZE
  sec_per_clus := buf[$0D]
  debug("  [do_mount] Sectors/cluster: ", udec(sec_per_clus))
  if (sec_per_clus & (sec_per_clus - 1))
    debug("  [do_mount] FAIL: sec_per_clus not power of 2")
    return E_NOT_FAT32
  reserved := word[@buf + $0E]
  debug("  [do_mount] Reserved sectors: ", udec(reserved))
  debug("  [do_mount] Number of FATs: ", udec(buf[$10]))
  if buf[$10] <> 2
    debug("  [do_mount] FAIL: FAT count not 2")
    return E_NOT_FAT32
  sec_per_fat := long[@buf + $24]
  fsinfo_sec := word[@buf + $30]
  fat_sec := vbr_sec + reserved
  fat2_sec := fat_sec + sec_per_fat
  root_sec := (fat_sec + 2 * sec_per_fat)
  longfill(@cog_dir_sec, root_sec, 8)                                             ' All cogs start at root
  cluster_offset := root_sec // sec_per_clus
  bytemove(@vol_label, @buf + $47, 11)
  vol_label[11] := 0
  debug("  [do_mount] Volume label: ", zstr(@vol_label))

  ' Read FSInfo sector for free cluster count and next-free hint
  if fsinfo_sec > 0 and fsinfo_sec < reserved
    readSector(vbr_sec + fsinfo_sec, BUF_DATA)
    if long[@buf + 0] == $4161_5252 and long[@buf + 484] == $6141_7272
      fsi_free_count := long[@buf + 488]
      fsi_nxt_free := long[@buf + 492]
      debug("  [do_mount] FSInfo: free_count=", udec(fsi_free_count), " nxt_free=", udec(fsi_nxt_free))
    else
      fsi_free_count := $FFFF_FFFF
      fsi_nxt_free := $FFFF_FFFF
      debug("  [do_mount] FSInfo: invalid signatures, ignoring")
  else
    fsi_free_count := $FFFF_FFFF
    fsi_nxt_free := $FFFF_FFFF
    debug("  [do_mount] FSInfo: sector not present")

  debug("  [do_mount] SUCCESS")
  if date_stamp == 0
    setdate(2009,01,27,07,00,00)
  flags |= F_MOUNTED

#IFDEF SD_INCLUDE_RAW
  ' WORKAROUND: Multi-block operations (CMD18/CMD25) require a warmup operation
  ' after mount to initialize internal state. Without this, the first multi-block
  ' write followed by multi-block read can return corrupted data.
  ' A single-sector multi-block read (count=1) exercises the CMD18 path.
  readSectors(0, 1, @buf)
  sec_in_buf := -1                                                              ' Clear cache
#ENDIF

  driver_mode := MODE_FILESYSTEM
  debug("  [do_mount] SUCCESS, mode=FILESYSTEM")
  return SUCCESS

PRI do_unmount() : result
' Internal unmount operation - syncs all handles and updates FSInfo.
'
' @returns result - SUCCESS on success

  ' V3: Sync all open handles before unmount
  do_sync_all()
  do_close()
  result := updateFSInfo()
  flags := flags & !F_MOUNTED
  driver_mode := MODE_NONE
  debug("  [do_unmount] Card unmounted cleanly, mode=NONE")
  return SUCCESS

#IFDEF SD_INCLUDE_RAW
PRI do_init_card_only() : result
' Internal card-only init (raw mode) - initialize card for raw sector access.
' Sets driver_mode to MODE_RAW without filesystem parsing.
'
' @returns result - SUCCESS on success, E_INIT_FAILED on failure

  dir_sec_in_buf := -1
  fat_sec_in_buf := -1
  sec_in_buf := -1
  debug("  [do_init_card_only] Calling initCard()...")
  if initCard()
    debug("  [do_init_card_only] Card initialized successfully")
    ' WORKAROUND: First streamer operation after card init needs warmup
    readSector(0, BUF_DATA)
    sec_in_buf := -1                                                            ' Clear cache for user's first read
    driver_mode := MODE_RAW
    debug("  [do_init_card_only] SUCCESS, mode=RAW")
    return SUCCESS
  else
    debug("  [do_init_card_only] FAIL: initCard() returned false")
    driver_mode := MODE_NONE
    return E_INIT_FAILED

PRI do_get_card_size() : result | csd[4], c_size, read_bl_len, c_size_mult
' Internal get card size operation - returns total number of 512-byte sectors.
' Runs on worker cog where smart pins are configured.
'
' @returns result - Total number of 512-byte sectors on the card
' @local csd - CSD register data (4 longs = 16 bytes)
' @local c_size - Capacity size field from CSD
' @local read_bl_len - Read block length from CSD
' @local c_size_mult - Size multiplier from CSD

  ' Read CSD using CMD9
  if not readCSD(@csd)
    debug("  [do_get_card_size] Failed to read CSD")
    return 0

  ' CSD structure version is in bits [127:126] (byte 0, bits 7:6)
  if (csd.byte[0] >> 6) == 0
    ' CSD Version 1.0 (SDSC)
    read_bl_len := csd.byte[5] & $0F
    c_size := (csd.byte[6] & $03) << 10
    c_size |= csd.byte[7] << 2
    c_size |= csd.byte[8] >> 6
    c_size_mult := (csd.byte[9] & $03) << 1
    c_size_mult |= csd.byte[10] >> 7
    result := (c_size + 1) << (c_size_mult + 2 + read_bl_len - 9)
    debug("  [do_get_card_size] CSD v1.0: ", udec(result), " sectors")
  else
    ' CSD Version 2.0 (SDHC/SDXC)
    c_size := (csd.byte[7] & $3F) << 16
    c_size |= csd.byte[8] << 8
    c_size |= csd.byte[9]
    result := (c_size + 1) << 10                                                ' * 1024 sectors (512KB units)
    debug("  [do_get_card_size] CSD v2.0: ", udec(result), " sectors")
#ENDIF

#IFDEF SD_INCLUDE_REGISTERS
PRI do_read_scr(p_buf) : result
' Internal read SCR operation - reads the 8-byte SCR register into buffer.
' Runs on worker cog where smart pins are configured.
'
' @param p_buf - Pointer to 8-byte buffer to receive SCR data
' @returns result - SUCCESS on success, E_IO_ERROR on failure

  if readSCR(p_buf)
    debug("  [do_read_scr] SCR read successfully")
    return SUCCESS
  else
    debug("  [do_read_scr] SCR read failed")
    return E_IO_ERROR

PRI do_read_cid(p_buf) : result
' Internal read CID operation - reads the 16-byte CID register into buffer.
' Runs on worker cog where smart pins are configured.
'
' @param p_buf - Pointer to 16-byte buffer to receive CID data
' @returns result - SUCCESS on success, E_IO_ERROR on failure

  if readCID(p_buf)
    debug("  [do_read_cid] CID read successfully")
    return SUCCESS
  else
    debug("  [do_read_cid] CID read failed")
    return E_IO_ERROR

PRI do_read_csd(p_buf) : result
' Internal read CSD operation - reads the 16-byte CSD register into buffer.
' Runs on worker cog where smart pins are configured.
'
' @param p_buf - Pointer to 16-byte buffer to receive CSD data
' @returns result - SUCCESS on success, E_IO_ERROR on failure

  if readCSD(p_buf)
    debug("  [do_read_csd] CSD read successfully")
    return SUCCESS
  else
    debug("  [do_read_csd] CSD read failed")
    return E_IO_ERROR
#ENDIF

PRI do_open(name_ptr) : result | search_result
' Internal open file operation - opens an existing file for reading/writing.
'
' @param name_ptr - Pointer to null-terminated filename string
' @returns result - SUCCESS on success, E_FILE_NOT_FOUND on failure
' @local search_result - Result from searchDirectory

  do_close()
  search_result := searchDirectory(name_ptr)
  if search_result
    if attributes() & %0001_1110 == 0
      flags |= F_OPEN
      return SUCCESS
  return E_FILE_NOT_FOUND

PRI do_close()
' Internal close file operation - close the file and write changed data to the card.

  if flags & F_NEWDATA
    debug("  [do_close] Writing data to sector ", udec_(n_sec))
    writeSector(n_sec, BUF_DATA)
  '
  if flags & (F_NEWDIR | F_NEWDATA)
    debug("  [do_close] Syncing dir entry at sector ", udec_(entry_address >> 9), " offset ", udec_(entry_address & 511))
    debug("  [do_close] entry_buffer: [", lstr_(@entry_buffer, 11), "]")
    readSector(entry_address >> 9, BUF_DIR)
    debug("  [do_close] Before copy, dir_buf at offset: [", lstr_(@dir_buf + (entry_address & 511), 11), "]")
    bytemove(@dir_buf + (entry_address & 511), @entry_buffer, 32)
    debug("  [do_close] After copy, dir_buf at offset: [", lstr_(@dir_buf + (entry_address & 511), 11), "]")
    debug("  [do_close] Before write: dir_buf[0]=[", lstr_(@dir_buf, 11), "] dir_buf[32]=[", lstr_(@dir_buf + 32, 11), "]")
    debug("  [do_close] Writing to sector ", udec_(entry_address >> 9), " @dir_buf=", uhex_(@dir_buf))
    if writeSector(entry_address >> 9, BUF_DIR)
      debug("  [do_close] Write succeeded")
    else
      debug("  [do_close] Write FAILED!")
  bytefill(@entry_buffer, 0, 32)
  flags := flags & !F_NEWDATA & !F_NEWDIR & !F_OPEN
  file_idx := 0

' ═══════════════════════════════════════════════════════════════════════════
' V3 HANDLE-BASED FILE OPERATIONS
' These functions use the multi-file handle system for independent file access
' ═══════════════════════════════════════════════════════════════════════════

PRI do_open_read(p_path) : handle | start_cluster
' Open file for reading (V3 handle) - opens existing file and returns handle.
' Multiple files can be open simultaneously for reading.
' Each handle has its own position, enabling interleaved reads.
'
' @param p_path - Pointer to null-terminated path string
' @returns handle - Handle (0 to MAX_OPEN_FILES-1) on success, negative error code on failure
' @local start_cluster - Starting cluster of the file

  ' Allocate a handle slot
  handle := allocateHandle()
  if handle < 0
    debug("  [do_open_read] No free handles")
    return handle                                                               ' E_TOO_MANY_FILES

  ' Search for the file
  if not searchDirectory(p_path)
    debug("  [do_open_read] File not found: ", zstr_(p_path))
    freeHandle(handle)
    return E_FILE_NOT_FOUND

  ' Verify it's a file, not a directory
  if attributes() & %0001_0000                                                  ' Directory bit
    debug("  [do_open_read] Path is a directory, not a file")
    freeHandle(handle)
    return E_NOT_A_FILE

  ' Populate handle state from directory entry
  start_cluster := firstCluster()
  h_start_clus[handle] := start_cluster
  h_size[handle] := fileSize()
  h_attr[handle] := attributes()
  h_dir_sector[handle] := entry_address >> 9
  h_dir_offset[handle] := entry_address & 511
  h_cluster[handle] := start_cluster
  h_sector[handle] := clus2sec(start_cluster)
  h_position[handle] := 0
  h_buf_sector[handle] := -1                                                    ' No sector cached yet
  h_flags[handle] := HF_READ

  debug("  [do_open_read] Success: handle=", udec_(handle), " size=", udec_(h_size[handle]), " cluster=", udec_(start_cluster))
  return handle

PRI do_open_write(p_path) : handle | start_cluster, current_cluster, fat_addr, file_size, cluster_count
' Open file for writing/append (V3 handle) - opens existing file for appending.
' Enforces single-writer policy: only one write handle per file allowed.
' Position is set to end of file for appending.
'
' @param p_path - Pointer to null-terminated path string
' @returns handle - Handle (0 to MAX_OPEN_FILES-1) on success, negative error code on failure
' @local start_cluster - Starting cluster of the file
' @local current_cluster - Current cluster during FAT chain walk
' @local fat_addr - Address of FAT entry
' @local file_size - Size of file in bytes
' @local cluster_count - Number of clusters to walk

  ' Allocate a handle slot
  handle := allocateHandle()
  if handle < 0
    debug("  [do_open_write] No free handles")
    return handle                                                               ' E_TOO_MANY_FILES

  ' Search for the file
  if not searchDirectory(p_path)
    debug("  [do_open_write] File not found: ", zstr_(p_path))
    freeHandle(handle)
    return E_FILE_NOT_FOUND

  ' Verify it's a file, not a directory
  if attributes() & %0001_0000                                                  ' Directory bit
    debug("  [do_open_write] Path is a directory, not a file")
    freeHandle(handle)
    return E_NOT_A_FILE

  ' Check single-writer policy
  if isFileOpenForWrite(entry_address >> 9, entry_address & 511)
    debug("  [do_open_write] File already open for write")
    freeHandle(handle)
    return E_FILE_ALREADY_OPEN

  ' Populate handle state from directory entry
  start_cluster := firstCluster()
  file_size := fileSize()
  h_start_clus[handle] := start_cluster
  h_size[handle] := file_size
  h_attr[handle] := attributes()
  h_dir_sector[handle] := entry_address >> 9
  h_dir_offset[handle] := entry_address & 511

  ' Position at end of file for append mode
  ' Walk FAT chain to find the last cluster
  h_position[handle] := file_size
  if file_size > 0
    ' Calculate which cluster contains the last byte
    cluster_count := (file_size - 1) / (sec_per_clus << 9)
    current_cluster := start_cluster
    repeat cluster_count
      fat_addr := readFat(current_cluster)
      current_cluster := long[fat_addr]
      if current_cluster >= $0FFF_FFF8                                          ' End of chain - shouldn't happen
        quit
    h_cluster[handle] := current_cluster
    h_sector[handle] := clus2sec(current_cluster) + ((file_size - 1) >> 9) & (sec_per_clus - 1)
  else
    ' Empty file - position at start
    h_cluster[handle] := start_cluster
    h_sector[handle] := clus2sec(start_cluster)

  h_buf_sector[handle] := -1                                                    ' No sector cached yet
  h_flags[handle] := HF_WRITE

  debug("  [do_open_write] Success: handle=", udec_(handle), " size=", udec_(file_size), " pos=", udec_(h_position[handle]))
  return handle

PRI do_create(p_path) : handle | temp, first_cluster
' Create new file (V3 handle) - creates empty file and opens for writing.
' If file already exists, returns error.
'
' @param p_path - Pointer to null-terminated path string
' @returns handle - Handle (0 to MAX_OPEN_FILES-1) on success, negative error code on failure
' @local temp - Temporary calculation variable
' @local first_cluster - First cluster allocated for the new file

  ' Allocate a handle slot
  handle := allocateHandle()
  if handle < 0
    debug("  [do_create] No free handles")
    return handle                                                               ' E_TOO_MANY_FILES

  ' Check if file already exists
  if searchDirectory(p_path)
    debug("  [do_create] File already exists: ", zstr_(p_path))
    freeHandle(handle)
    return E_FILE_EXISTS

  ' searchDirectory() sets entry_address to first free directory entry
  ' Check if we need to allocate a new cluster for the directory
  temp := (entry_address + cluster_offset << 9) & (sec_per_clus << 9 - 1)
  if temp == (sec_per_clus << 9 - 32)
    if dir_buf[480] == $00                                                      ' End of directory
      temp := allocateCluster(byte2clus(entry_address))
      if temp < 0
        debug("  [do_create] Failed to allocate dir cluster")
        freeHandle(handle)
        return E_DISK_FULL
      clearCluster(temp)

  ' Allocate first cluster for the new file
  first_cluster := allocateCluster(0)
  if first_cluster < 0
    debug("  [do_create] Failed to allocate file cluster")
    freeHandle(handle)
    return E_DISK_FULL

  ' Set up directory entry in entry_buffer
  byte[@entry_buffer + 11] := $20                                               ' Archive attribute
  long[@entry_buffer + 14] := date_stamp                                        ' Create time
  word[@entry_buffer + 20] := first_cluster >> 16                               ' First cluster high
  long[@entry_buffer + 22] := date_stamp                                        ' Modify time
  word[@entry_buffer + 26] := first_cluster & $FFFF                             ' First cluster low
  long[@entry_buffer + 28] := 0                                                 ' File size = 0

  ' Write directory entry to disk
  readSector(entry_address >> 9, BUF_DIR)
  bytemove(@dir_buf + (entry_address & 511), @entry_buffer, 32)
  writeSector(entry_address >> 9, BUF_DIR)

  ' Populate handle state
  h_start_clus[handle] := first_cluster
  h_size[handle] := 0
  h_attr[handle] := $20
  h_dir_sector[handle] := entry_address >> 9
  h_dir_offset[handle] := entry_address & 511
  h_cluster[handle] := first_cluster
  h_sector[handle] := clus2sec(first_cluster)
  h_position[handle] := 0
  h_buf_sector[handle] := -1                                                    ' No sector cached yet
  h_flags[handle] := HF_WRITE

  debug("  [do_create] Success: handle=", udec_(handle), " cluster=", udec_(first_cluster))
  return handle

PRI do_close_h(handle) : result | p_buf
' Close file handle (V3) - closes handle, flushing writes and updating directory.
' For write handles, the directory entry is updated with the final file size.
'
' @param handle - Handle to close
' @returns result - SUCCESS (0) on success, E_INVALID_HANDLE on failure
' @local p_buf - Pointer to handle's buffer

  ' Validate handle
  if not validateHandle(handle)
    debug("  [do_close_h] Invalid handle: ", sdec_(handle))
    return E_INVALID_HANDLE
  if h_flags[handle] & HF_DIR
    return E_NOT_A_DIR_HANDLE

  debug("  [do_close_h] Closing handle=", udec_(handle), " flags=$", uhex_byte_(h_flags[handle]))

  ' If buffer is dirty, flush it to disk
  if h_flags[handle] & HF_DIRTY
    debug("  [do_close_h] Flushing dirty buffer for sector ", udec_(h_buf_sector[handle]))
    p_buf := getHandleBuffer(handle)
    bytemove(@buf, p_buf, 512)                                                    ' Copy to shared buffer
    writeSector(h_buf_sector[handle], BUF_DATA)                                   ' Write to disk

  ' If opened for write, update directory entry with final size
  if h_flags[handle] & HF_WRITE
    debug("  [do_close_h] Updating directory: size=", udec_(h_size[handle]))
    readSector(h_dir_sector[handle], BUF_DIR)
    long[@dir_buf + h_dir_offset[handle] + 28] := h_size[handle]                  ' Update size field
    writeSector(h_dir_sector[handle], BUF_DIR)

  ' Free the handle
  freeHandle(handle)
  debug("  [do_close_h] Handle closed successfully")

  return SUCCESS

PRI do_read_h(handle, p_buffer, count) : bytes_read | p_hbuf, available, offset, to_read, cluster, fat_addr, next_cluster
' Handle-based read (V3) - reads data from file handle into user buffer.
' Uses per-handle buffer to avoid cache thrashing. Independent position per handle.
'
' @param handle - Valid read handle
' @param p_buffer - Pointer to destination buffer
' @param count - Number of bytes to read
' @returns bytes_read - Number of bytes actually read (0 at EOF), negative on error
' @local p_hbuf - Pointer to handle's buffer
' @local available - Bytes available to read
' @local offset - Offset within current sector
' @local to_read - Bytes to read from current sector
' @local cluster - Current cluster number
' @local fat_addr - Address of FAT entry
' @local next_cluster - Next cluster in chain

  ' Validate handle
  if not validateHandle(handle)
    debug("  [do_read_h] Invalid handle: ", sdec_(handle))
    return E_INVALID_HANDLE
  if h_flags[handle] & HF_DIR
    return E_NOT_A_DIR_HANDLE

  ' Calculate how many bytes we can actually read
  available := h_size[handle] - h_position[handle]
  if available <= 0
    debug("  [do_read_h] EOF reached")
    return 0                                                                      ' EOF

  count := count <# available                                                     ' Cap at available bytes
  debug("  [do_read_h] handle=", udec_(handle), " pos=", udec_(h_position[handle]), " count=", udec_(count))

  ' Get pointer to handle's buffer
  p_hbuf := getHandleBuffer(handle)

  bytes_read := 0
  repeat while count > 0
    ' Ensure current sector is loaded into handle's buffer
    if h_buf_sector[handle] <> h_sector[handle]
      ' Load sector into shared buffer, then copy to handle's buffer
      readSector(h_sector[handle], BUF_DATA)
      bytemove(p_hbuf, @buf, 512)
      h_buf_sector[handle] := h_sector[handle]

    ' Calculate offset within sector and bytes to read from this sector
    offset := h_position[handle] & 511
    to_read := (512 - offset) <# count

    ' Copy data from handle buffer to user buffer
    bytemove(p_buffer, p_hbuf + offset, to_read)

    ' Advance positions
    p_buffer += to_read
    h_position[handle] += to_read
    bytes_read += to_read
    count -= to_read

    ' If we've finished this sector, advance to next
    if (h_position[handle] & 511) == 0 and count > 0
      h_sector[handle]++
      ' Check if we crossed a cluster boundary
      if ((h_sector[handle] - cluster_offset) & (sec_per_clus - 1)) == 0
        ' Follow FAT chain to next cluster
        cluster := h_cluster[handle]
        readSector(cluster >> 7 + fat_sec, BUF_FAT)
        fat_addr := @fat_buf + ((cluster << 2) & 511)
        next_cluster := long[fat_addr]
        if next_cluster >= $0FFF_FFF8
          ' End of chain - shouldn't happen if h_size is correct
          debug("  [do_read_h] Unexpected end of FAT chain")
          quit
        h_cluster[handle] := next_cluster
        h_sector[handle] := clus2sec(next_cluster)

  debug("  [do_read_h] Read ", udec_(bytes_read), " bytes, pos now ", udec_(h_position[handle]))
  return bytes_read

PRI do_write_h(handle, p_buffer, count) : bytes_written | p_hbuf, offset, to_write, new_cluster, fat_addr
' Handle-based write (V3) - writes data from user buffer to file handle.
' Uses per-handle buffer with dirty tracking. File grows as needed.
' Clusters allocated when extending past current allocation.
'
' @param handle - Valid write handle (must have HF_WRITE set)
' @param p_buffer - Pointer to source data buffer
' @param count - Number of bytes to write
' @returns bytes_written - Number of bytes written, negative on error
' @local p_hbuf - Pointer to handle's buffer
' @local offset - Offset within current sector
' @local to_write - Bytes to write to current sector
' @local new_cluster - Newly allocated cluster
' @local fat_addr - Address of FAT entry

  ' Validate handle
  if not validateHandle(handle)
    debug("  [do_write_h] Invalid handle: ", sdec_(handle))
    return E_INVALID_HANDLE
  if h_flags[handle] & HF_DIR
    return E_NOT_A_DIR_HANDLE

  ' Verify handle is open for writing
  if not (h_flags[handle] & HF_WRITE)
    debug("  [do_write_h] Handle not open for write")
    return E_INVALID_HANDLE

  if count <= 0
    return 0

  debug("  [do_write_h] handle=", udec_(handle), " pos=", udec_(h_position[handle]), " count=", udec_(count))

  ' Get pointer to handle's buffer
  p_hbuf := getHandleBuffer(handle)

  bytes_written := 0
  repeat while count > 0
    ' Ensure current sector is in handle's buffer
    if h_buf_sector[handle] <> h_sector[handle]
      ' Flush dirty buffer first if needed
      if h_flags[handle] & HF_DIRTY
        debug("  [do_write_h] Flushing dirty sector ", udec_(h_buf_sector[handle]))
        bytemove(@buf, p_hbuf, 512)
        writeSector(h_buf_sector[handle], BUF_DATA)
        h_flags[handle] &= !HF_DIRTY

      ' Load sector (or zero-fill if writing past end)
      if h_position[handle] < h_size[handle]
        ' Within existing file - load sector
        readSector(h_sector[handle], BUF_DATA)
        bytemove(p_hbuf, @buf, 512)
      else
        ' Past end of file - zero-fill buffer
        bytefill(p_hbuf, 0, 512)
      h_buf_sector[handle] := h_sector[handle]

    ' Calculate offset within sector and bytes to write to this sector
    offset := h_position[handle] & 511
    to_write := (512 - offset) <# count

    ' Copy data from user buffer to handle buffer
    bytemove(p_hbuf + offset, p_buffer, to_write)
    h_flags[handle] |= HF_DIRTY

    ' Advance positions
    p_buffer += to_write
    h_position[handle] += to_write
    bytes_written += to_write
    count -= to_write

    ' Update file size if we've grown past it
    if h_position[handle] > h_size[handle]
      h_size[handle] := h_position[handle]

    ' If we've filled this sector, flush and advance to next
    if (h_position[handle] & 511) == 0 and count > 0
      ' Flush current sector
      debug("  [do_write_h] Sector full, flushing sector ", udec_(h_sector[handle]))
      bytemove(@buf, p_hbuf, 512)
      writeSector(h_sector[handle], BUF_DATA)
      h_flags[handle] &= !HF_DIRTY
      h_buf_sector[handle] := -1

      h_sector[handle]++
      ' Check if we crossed a cluster boundary
      if ((h_sector[handle] - cluster_offset) & (sec_per_clus - 1)) == 0
        ' Need to allocate new cluster or follow chain
        new_cluster := allocateCluster(h_cluster[handle])
        if new_cluster < 0
          debug("  [do_write_h] Failed to allocate cluster")
          return bytes_written                                                    ' Return what we've written so far
        debug("  [do_write_h] Allocated new cluster ", udec_(new_cluster))
        h_cluster[handle] := new_cluster
        h_sector[handle] := clus2sec(new_cluster)

  debug("  [do_write_h] Wrote ", udec_(bytes_written), " bytes, size now ", udec_(h_size[handle]))
  return bytes_written

PRI do_seek_h(handle, position) : result | target_cluster_idx, cluster, i, fat_addr, sector_in_cluster
' Handle-based seek (V3) - seeks to absolute position in file.
' Position must be <= file size (no seeking past EOF).
'
' @param handle - Valid file handle
' @param position - Absolute byte position to seek to
' @returns result - SUCCESS (0) on success, negative error code on failure
' @local target_cluster_idx - Target cluster index from start
' @local cluster - Current cluster during walk
' @local i - Loop counter
' @local fat_addr - Address of FAT entry
' @local sector_in_cluster - Sector offset within cluster

  ' Validate handle
  if not validateHandle(handle)
    debug("  [do_seek_h] Invalid handle: ", sdec_(handle))
    return E_INVALID_HANDLE
  if h_flags[handle] & HF_DIR
    return E_NOT_A_DIR_HANDLE

  ' Validate position is within file
  if position > h_size[handle]
    debug("  [do_seek_h] Position ", udec_(position), " > size ", udec_(h_size[handle]))
    return E_END_OF_FILE

  debug("  [do_seek_h] handle=", udec_(handle), " pos ", udec_(h_position[handle]), " -> ", udec_(position))

  ' Fast path: if position is in the same sector, just update position
  if (position >> 9) == (h_position[handle] >> 9)
    h_position[handle] := position
    debug("  [do_seek_h] Same sector, fast path")
    return SUCCESS

  ' Calculate which cluster the target position is in
  ' target_cluster_idx = how many clusters from the start
  target_cluster_idx := position / (sec_per_clus << 9)

  ' Walk the FAT chain from the file's start cluster
  cluster := h_start_clus[handle]

  ' BUG FIX: Guard against Spin2's count-down behavior
  ' When target_cluster_idx is 0, "repeat i from 0 to -1" would execute twice
  ' (counting down from 0 to -1), incorrectly walking the FAT chain.
  ' Only walk the chain if we need to move to a different cluster.
  if target_cluster_idx > 0
    repeat i from 0 to target_cluster_idx - 1
      ' Read FAT entry for current cluster
      readSector(cluster >> 7 + fat_sec, BUF_FAT)
      fat_addr := @fat_buf + ((cluster << 2) & 511)
      cluster := long[fat_addr]
      if cluster >= $0FFF_FFF8
        ' End of chain reached before target - shouldn't happen
        debug("  [do_seek_h] Unexpected end of FAT chain at index ", udec_(i))
        return E_END_OF_FILE

  ' Calculate sector within cluster
  sector_in_cluster := (position >> 9) & (sec_per_clus - 1)

  ' Update handle state
  h_cluster[handle] := cluster
  h_sector[handle] := clus2sec(cluster) + sector_in_cluster
  h_position[handle] := position
  h_buf_sector[handle] := -1                                                      ' Invalidate buffer cache

  debug("  [do_seek_h] Seek complete: cluster=", udec_(cluster), " sector=", udec_(h_sector[handle]))
  return SUCCESS

PRI do_sync_h(handle) : result | p_buf
' Sync handle buffer to disk (V3) - flushes pending writes and updates directory.
' Does NOT close handle - file remains open for further operations.
'
' @param handle - Valid file handle
' @returns result - SUCCESS (0) on success, E_INVALID_HANDLE on failure
' @local p_buf - Pointer to handle's buffer

  ' Validate handle
  if not validateHandle(handle)
    debug("  [do_sync_h] Invalid handle: ", sdec_(handle))
    return E_INVALID_HANDLE
  if h_flags[handle] & HF_DIR
    return E_NOT_A_DIR_HANDLE

  debug("  [do_sync_h] Syncing handle=", udec_(handle), " flags=$", uhex_byte_(h_flags[handle]))

  ' If buffer is dirty, flush it to disk
  if h_flags[handle] & HF_DIRTY
    debug("  [do_sync_h] Flushing dirty buffer for sector ", udec_(h_buf_sector[handle]))
    p_buf := getHandleBuffer(handle)
    bytemove(@buf, p_buf, 512)
    writeSector(h_buf_sector[handle], BUF_DATA)
    h_flags[handle] &= !HF_DIRTY

  ' If opened for write, update directory entry with current size
  if h_flags[handle] & HF_WRITE
    debug("  [do_sync_h] Updating directory: size=", udec_(h_size[handle]))
    readSector(h_dir_sector[handle], BUF_DIR)
    long[@dir_buf + h_dir_offset[handle] + 28] := h_size[handle]
    writeSector(h_dir_sector[handle], BUF_DIR)

  debug("  [do_sync_h] Sync complete")
  return SUCCESS

PRI do_sync_all() : result | i
' Sync all open write handles (V3) - flushes all write handles to disk.
' Called by unmount() to ensure all data is written before stopping.
'
' @returns result - SUCCESS (0) on success
' @local i - Loop variable

  debug("  [do_sync_all] Syncing all handles")
  repeat i from 0 to MAX_OPEN_FILES - 1
    if h_flags[i] & HF_WRITE
      debug("  [do_sync_all] Syncing write handle ", udec_(i))
      do_sync_h(i)

  debug("  [do_sync_all] All handles synced")
  return SUCCESS

' ═══════════════════════════════════════════════════════════════════════════
' V3 DIRECTORY HANDLE OPERATIONS
' Directory handles share the existing unified handle pool.
' A directory handle reuses per-handle fields with HF_DIR flag.
' ═══════════════════════════════════════════════════════════════════════════

PRI do_open_dir(p_path) : handle | start_cluster
' Open directory for enumeration (V3 handle) - returns handle for iterating entries.
' Directory handles share the existing handle pool with file handles.
'
' @param p_path - Pointer to null-terminated path string ("." or "" for CWD)
' @returns handle - Handle (0 to MAX_OPEN_FILES-1) on success, negative error code on failure
' @local start_cluster - Starting cluster of the directory

  ' Allocate a handle slot
  handle := allocateHandle()
  if handle < 0
    debug("  [do_open_dir] No free handles")
    return handle                                                               ' E_TOO_MANY_FILES

  ' Determine which directory to enumerate
  if byte[p_path] == 0 or (byte[p_path] == "." and byte[p_path + 1] == 0)
    ' Empty string or "." -- enumerate calling cog's CWD
    n_sec := cog_dir_sec[pb_caller]
    start_cluster := sec2clus(n_sec)
  else
    ' Search for the named directory
    if not searchDirectory(p_path)
      debug("  [do_open_dir] Directory not found: ", zstr_(p_path))
      freeHandle(handle)
      return E_FILE_NOT_FOUND
    ' Verify it's a directory
    if not (attributes() & %0001_0000)
      debug("  [do_open_dir] Not a directory: ", zstr_(p_path))
      freeHandle(handle)
      return E_NOT_A_DIR
    start_cluster := firstCluster()
    if start_cluster < 2
      start_cluster := 2                                                        ' Root directory

  ' Populate handle state
  h_flags[handle] := HF_DIR
  h_start_clus[handle] := start_cluster
  h_cluster[handle] := start_cluster
  h_sector[handle] := clus2sec(start_cluster)
  h_position[handle] := 0                                                      ' Entry index
  h_size[handle] := 0                                                          ' Not used for directories
  h_buf_sector[handle] := -1                                                   ' No sector cached yet

  debug("  [do_open_dir] Success: handle=", udec_(handle), " cluster=", udec_(start_cluster))
  return handle

PRI do_read_dir_h(handle) : result | p_hbuf, offset, char, attrib, cluster, fat_addr, next_cluster
' Read next directory entry from handle (V3) - skips deleted and LFN entries.
' Copies valid entry into entry_buffer for caller to inspect via fileName()/attributes().
'
' @param handle - Valid directory handle (must have HF_DIR flag)
' @returns result - SUCCESS on valid entry, E_FILE_NOT_FOUND at end of directory
' @local p_hbuf - Pointer to handle's buffer
' @local offset - Byte offset within current sector
' @local char - First byte of entry
' @local attrib - Entry attribute byte
' @local cluster - Current cluster number
' @local fat_addr - Address of FAT entry
' @local next_cluster - Next cluster in chain

  ' Validate handle
  if not validateHandle(handle)
    return E_INVALID_HANDLE
  if not (h_flags[handle] & HF_DIR)
    return E_INVALID_HANDLE

  p_hbuf := getHandleBuffer(handle)

  repeat
    ' Check if we need to advance to next sector (16 entries per 512-byte sector)
    if h_position[handle] > 0 and (h_position[handle] & 15) == 0
      h_sector[handle]++
      ' Check if we crossed a cluster boundary
      if ((h_sector[handle] - cluster_offset) & (sec_per_clus - 1)) == 0
        ' Follow FAT chain to next cluster
        cluster := h_cluster[handle]
        readSector(cluster >> 7 + fat_sec, BUF_FAT)
        fat_addr := @fat_buf + ((cluster << 2) & 511)
        next_cluster := long[fat_addr]
        if next_cluster >= $0FFF_FFF8
          return E_FILE_NOT_FOUND                                               ' End of directory chain
        h_cluster[handle] := next_cluster
        h_sector[handle] := clus2sec(next_cluster)
      h_buf_sector[handle] := -1                                                ' Force re-read

    ' Load current sector into handle's buffer if not cached
    if h_buf_sector[handle] <> h_sector[handle]
      readSector(h_sector[handle], BUF_DATA)
      bytemove(p_hbuf, @buf, 512)
      h_buf_sector[handle] := h_sector[handle]

    ' Calculate byte offset within sector (each entry is 32 bytes)
    offset := (h_position[handle] & 15) << 5                                   ' (position % 16) * 32

    ' Read first byte and attributes
    char := byte[p_hbuf + offset]
    attrib := byte[p_hbuf + offset + 11]

    ' Advance position for next call
    h_position[handle]++

    ' Check for end of directory
    if char == $00
      return E_FILE_NOT_FOUND

    ' Skip deleted entries and LFN entries
    if char == $E5
      next
    if attrib == $0F                                                            ' LFN entry
      next
    ' Skip entries with hidden/system attributes that aren't normally shown
    if attrib & %0000_1110 <> 0
      next

    ' Valid entry found - copy to entry_buffer
    bytemove(@entry_buffer, p_hbuf + offset, 32)
    return SUCCESS

PRI do_close_dir_h(handle) : result
' Close directory handle (V3) - releases handle back to pool.
'
' @param handle - Valid directory handle
' @returns result - SUCCESS on success, E_INVALID_HANDLE if invalid

  if not validateHandle(handle)
    return E_INVALID_HANDLE
  if not (h_flags[handle] & HF_DIR)
    return E_INVALID_HANDLE

  debug("  [do_close_dir_h] Closing handle=", udec_(handle))
  freeHandle(handle)
  return SUCCESS

PRI do_read(p_buffer, count) : bytes_read | delta, sectors_to_boundary, full_sectors, multi_count, multi_read
' Internal read operation - optimized with multi-sector support for throughput.
' Uses CMD18 (readSectors) when reading 2+ full sequential sectors within a cluster.
'
' @param p_buffer - Pointer to destination buffer
' @param count - Number of bytes to read
' @returns bytes_read - Number of bytes actually read
' @local delta - Bytes to read in partial sector
' @local sectors_to_boundary - Sectors remaining before cluster boundary
' @local full_sectors - Number of full sectors to read
' @local multi_count - Sectors to read in multi-sector operation
' @local multi_read - Sectors actually read in multi-sector operation

  if (flags & F_OPEN) and not (attributes() & %0001_1110)
    count <#= (fileSize() - file_idx)

    ' Handle partial first sector (if not at sector boundary)
    if (file_idx & 511) and count > 0
      readSector(n_sec, BUF_DATA)
      delta := (512 - (file_idx & 511)) <# count
      bytemove(p_buffer, @buf + (file_idx & 511), delta)
      file_idx += delta
      bytes_read += delta
      p_buffer += delta
      count -= delta
      if file_idx & 511 == 0
        readNextSector(BUF_DATA)

    ' Multi-sector optimization: read full sectors directly to user buffer
    repeat while count >= 512
      ' Calculate sectors remaining before cluster boundary
      sectors_to_boundary := sec_per_clus - ((n_sec - cluster_offset) & (sec_per_clus - 1))
      full_sectors := count >> 9                                                ' Number of full sectors needed
      multi_count := sectors_to_boundary <# full_sectors                        ' Limit to cluster boundary

      if multi_count >= 2
        ' Multi-sector read directly to user buffer (more efficient)
        multi_read := readSectors(n_sec, multi_count, p_buffer)
        if multi_read > 0
          file_idx += multi_read << 9
          bytes_read += multi_read << 9
          p_buffer += multi_read << 9
          count -= multi_read << 9
          n_sec += multi_read
          sec_in_buf := -1                                                      ' Invalidate cache (we bypassed buf)
          ' Check if we hit cluster boundary
          if ((n_sec - cluster_offset) & (sec_per_clus - 1)) == 0
            followFatChain()                                                    ' Update n_sec to next cluster
        else
          quit                                                                  ' Error - exit loop
      else
        ' Single-sector read (for partial cluster or small reads)
        readSector(n_sec, BUF_DATA)
        bytemove(p_buffer, @buf, 512)
        file_idx += 512
        bytes_read += 512
        p_buffer += 512
        count -= 512
        readNextSector(BUF_DATA)

    ' Handle partial last sector
    if count > 0
      readSector(n_sec, BUF_DATA)
      bytemove(p_buffer, @buf, count)
      file_idx += count
      bytes_read += count

PRI do_write(p_buffer, count) | delta, temp, sectors_to_boundary, full_sectors, multi_count, multi_written
' Internal write operation - optimized with multi-sector support for throughput.
' Uses CMD25 (writeSectors) when writing 2+ full sequential sectors within a cluster.
'
' @param p_buffer - Pointer to source data buffer
' @param count - Number of bytes to write
' @local delta - Bytes to write in partial sector
' @local temp - Temporary calculation variable
' @local sectors_to_boundary - Sectors remaining before cluster boundary
' @local full_sectors - Number of full sectors to write
' @local multi_count - Sectors to write in multi-sector operation
' @local multi_written - Sectors actually written in multi-sector operation

  if (flags & F_OPEN) and (count > 0) and not (attributes() & %0001_1111)
    if fileSize() & (sec_per_clus << 9 - 1) == 0
      temp := firstCluster()
      repeat (fileSize()-1) / (sec_per_clus << 9)
        temp := long[readFat(temp)]
      temp := allocateCluster(temp)
      if fileSize() == 0
        word[@entry_buffer + $14] := temp >> 16
        word[@entry_buffer + $1A] := temp & $FFFF
      n_sec := clus2sec(temp)
      bytefill(@buf,0,512)
    else
      do_seek(fileSize())                                                       ' Use internal seek to avoid deadlock

    ' Handle partial first sector (if not at sector boundary)
    if (file_idx & 511) and count > 0
      delta := (512 - (file_idx & 511)) <# count
      bytemove(@buf + (file_idx & 511), p_buffer, delta)
      sec_in_buf := n_sec
      file_idx += delta
      p_buffer += delta
      long[@entry_buffer + $1C] += delta
      count -= delta
      if file_idx & 511 == 0
        writeSector(n_sec++, BUF_DATA)
        bytefill(@buf,0,512)
        if ((n_sec - cluster_offset) & (sec_per_clus - 1)) == 0
          temp := allocateCluster(sec2clus(n_sec-1))
          n_sec := clus2sec(temp)

    ' Multi-sector optimization: write full sectors directly from user buffer
    repeat while count >= 512
      ' Calculate sectors remaining before cluster boundary
      sectors_to_boundary := sec_per_clus - ((n_sec - cluster_offset) & (sec_per_clus - 1))
      full_sectors := count >> 9                                                ' Number of full sectors to write
      multi_count := sectors_to_boundary <# full_sectors                        ' Limit to cluster boundary

      if multi_count >= 2
        ' Multi-sector write directly from user buffer (more efficient)
        multi_written := writeSectors(n_sec, multi_count, p_buffer)
        if multi_written > 0
          file_idx += multi_written << 9
          long[@entry_buffer + $1C] += multi_written << 9
          p_buffer += multi_written << 9
          count -= multi_written << 9
          n_sec += multi_written
          sec_in_buf := -1                                                      ' Invalidate cache (we bypassed buf)
          ' Check if we hit cluster boundary and need more writes
          if count > 0 and ((n_sec - cluster_offset) & (sec_per_clus - 1)) == 0
            temp := allocateCluster(sec2clus(n_sec-1))
            n_sec := clus2sec(temp)
        else
          quit                                                                  ' Error - exit loop
      else
        ' Single-sector write (for partial cluster or small writes)
        bytemove(@buf, p_buffer, 512)
        writeSector(n_sec++, BUF_DATA)
        file_idx += 512
        long[@entry_buffer + $1C] += 512
        p_buffer += 512
        count -= 512
        bytefill(@buf,0,512)
        if ((n_sec - cluster_offset) & (sec_per_clus - 1)) == 0
          temp := allocateCluster(sec2clus(n_sec-1))
          n_sec := clus2sec(temp)

    ' Handle partial last sector
    if count > 0
      bytemove(@buf + (file_idx & 511), p_buffer, count)
      sec_in_buf := n_sec
      file_idx += count
      long[@entry_buffer + $1C] += count

    flags |= F_NEWDATA

PRI do_seek(pos) : result | cluster
' Internal seek operation - sets file position to specified byte offset.
'
' @param pos - Byte position to seek to
' @returns result - SUCCESS on success, E_END_OF_FILE if past end
' @local cluster - Current cluster during FAT chain walk

  if pos > fileSize()
    return E_END_OF_FILE
  cluster := firstCluster()
  repeat (pos / (sec_per_clus << 9))
    cluster := long[readFat(cluster)]
  n_sec := clus2sec(cluster)
  n_sec += (pos / 512) // sec_per_clus
  readSector(n_sec, BUF_DATA)
  file_idx := pos
  return SUCCESS

PRI do_newfile(name_ptr) : result | temp
' Internal new file operation - creates a new file in current directory.
'
' @param name_ptr - Pointer to null-terminated filename string
' @returns result - SUCCESS on success, E_FILE_EXISTS if file exists
' @local temp - Temporary calculation variable

  do_close()
  if searchDirectory(name_ptr)
    return E_FILE_EXISTS

  temp := (entry_address + cluster_offset << 9) & (sec_per_clus << 9 - 1)
  if temp == (sec_per_clus << 9 - 32)
    if dir_buf[480] == $00                                                      ' Check dir buffer after searchDirectory
      temp := allocateCluster(byte2clus(entry_address))
      clearCluster(temp)

  byte[@entry_buffer + 11] := $20
  long[@entry_buffer + 14] := date_stamp
  word[@entry_buffer + 20] := $0000
  long[@entry_buffer + 22] := date_stamp
  word[@entry_buffer + 26] := $0000
  long[@entry_buffer + 28] := 0
  flags |= F_OPEN | F_NEWDIR
  return SUCCESS

PRI do_newdir(name_ptr) : result | temp
' Internal new directory operation - creates a new directory in current directory.
'
' @param name_ptr - Pointer to null-terminated directory name string
' @returns result - SUCCESS on success, E_FILE_EXISTS if directory exists
' @local temp - Temporary calculation variable for cluster allocation

  do_close()
  if searchDirectory(name_ptr)
    return E_FILE_EXISTS

  temp := (entry_address + cluster_offset << 9) & (sec_per_clus << 9 - 1)
  if temp == sec_per_clus << 9 - 32
    if dir_buf[480] == $00                                                      ' Check dir buffer after searchDirectory
      temp := allocateCluster(byte2clus(entry_address))
      clearCluster(temp)

  temp := allocateCluster(0)
  byte[@entry_buffer + 11] := $10
  long[@entry_buffer + 14] := date_stamp
  word[@entry_buffer + 20] := temp >> 16
  long[@entry_buffer + 22] := date_stamp
  word[@entry_buffer + 26] := temp & $FFFF
  long[@entry_buffer + 28] := 0

  readSector(entry_address >> 9, BUF_DIR)
  debug("  [do_newdir] Before write: dir_buf[", udec_(entry_address & 511), "]=[", lstr_(@dir_buf + (entry_address & 511), 11), "]")
  bytemove(@dir_buf + (entry_address & 511), @entry_buffer, 32)
  debug("  [do_newdir] After copy: dir_buf[", udec_(entry_address & 511), "]=[", lstr_(@dir_buf + (entry_address & 511), 11), "]")
  debug("  [do_newdir] entry_buffer=[", lstr_(@entry_buffer, 11), "]")
  writeSector(entry_address >> 9, BUF_DIR)
  ' Verify write by reading back
  dir_sec_in_buf := -1                                                          ' Force re-read
  readSector(entry_address >> 9, BUF_DIR)
  debug("  [do_newdir] After verify read: dir_buf[", udec_(entry_address & 511), "]=[", lstr_(@dir_buf + (entry_address & 511), 11), "]")

  bytefill(@dir_buf, 0, 512)
  bytemove(@dir_buf[0], string(".          "), 11)
  byte[@dir_buf + 11] := $10
  long[@dir_buf + 14] := date_stamp
  word[@dir_buf + 20] := temp >> 16
  long[@dir_buf + 22] := date_stamp
  word[@dir_buf + 26] := temp & $FFFF

  temp := byte2clus(entry_address)
  if temp == 2
    temp := 0
  bytemove(@dir_buf[32], string("..         "), 11)
  byte[@dir_buf + 32 + 11] := $10
  long[@dir_buf + 32 + 14] := date_stamp
  word[@dir_buf + 32 + 20] := temp >> 16
  long[@dir_buf + 32 + 22] := date_stamp
  word[@dir_buf + 32 + 26] := temp & $FFFF

  n_sec := clus2sec(firstCluster())
  debug("  [do_newdir] Writing ./.. to sector ", udec_(n_sec), ": dir_buf[0]=[", lstr_(@dir_buf, 11), "] dir_buf[32]=[", lstr_(@dir_buf + 32, 11), "]")
  writeSector(n_sec, BUF_DIR)
  dir_sec_in_buf := n_sec
  ' Verify the ./.. write
  dir_sec_in_buf := -1
  readSector(n_sec, BUF_DIR)
  debug("  [do_newdir] After ./.. verify: dir_buf[0]=[", lstr_(@dir_buf, 11), "] dir_buf[32]=[", lstr_(@dir_buf + 32, 11), "]")
  return SUCCESS

PRI do_delete(name_ptr) : result | cluster, p_cluster, fat_sector, loop_count
' Internal delete operation - deletes a file and frees its clusters.
'
' @param name_ptr - Pointer to null-terminated filename string
' @returns result - SUCCESS on success, E_FILE_NOT_FOUND if not found
' @local cluster - Current cluster being freed
' @local p_cluster - Previous cluster in chain
' @local fat_sector - FAT sector containing current cluster
' @local loop_count - Safety counter to prevent infinite loops

  do_close()
  if searchDirectory(name_ptr) == 0
    return E_FILE_NOT_FOUND
  if attributes() & %0000_1111                                                   ' Check read-only, hidden, system, volume label
    return E_FILE_NOT_FOUND                                                     ' Protected file (but allow directories)

  dir_buf[entry_address & 511] := $E5                                           ' Mark entry as deleted in dir buffer
  writeSector(entry_address >> 9, BUF_DIR)

  ' Only deallocate clusters if file has data (cluster >= 2)
  p_cluster := firstCluster()
  loop_count := 0
  if p_cluster >= 2
    repeat
      cluster := long[readFAT(p_cluster)]
      long[@fat_buf + ((p_cluster << 2) & 511)] := 0                            ' Zero the FAT entry in fat buffer
      if fsi_free_count <> $FFFF_FFFF                                           ' Track free count incrementally
        fsi_free_count++                                                        '  (avoids slow FAT scan on unmount)
      if (cluster >> 7) - (p_cluster >> 7) <> 0                                 ' Different FAT sector? (explicit precedence)
        fat_sector := p_cluster >> 7
        writeSector(fat_sector + fat_sec, BUF_FAT)
        writeSector(fat_sector + fat2_sec, BUF_FAT)
      p_cluster := cluster
      loop_count++
      if loop_count > 100000                                                    ' Safety limit - prevent infinite loop
        return E_IO_ERROR
    until cluster >= $0FFF_FFF8
  return SUCCESS

PRI do_chdir(name_ptr) : result
' Internal change directory operation - changes current directory.
'
' @param name_ptr - Pointer to null-terminated directory name string
' @returns result - SUCCESS on success, E_NOT_A_DIR if not a directory

  do_close()
  if searchDirectory(name_ptr)
    if (attributes() & %0001_0000) or (n_sec == root_sec)
      cog_dir_sec[pb_caller] := n_sec
      return SUCCESS
    else
      debug("  [do_chdir] NOT a directory: attr=", uhex_byte_(attributes()))
  else
    debug("  [do_chdir] searchDirectory FAILED for: ", zstr(name_ptr), " dir_sec=", udec_(cog_dir_sec[pb_caller]))
  return E_NOT_A_DIR

PRI do_freespace() : result | cluster
' Internal free space calculation - returns free sectors on card.
'
' @returns result - Number of free sectors
' @local cluster - Loop variable for FAT scan

  if not (flags & F_MOUNTED)
    return 0
  n_sec := fat_sec
  repeat sec_per_fat
    readSector(n_sec++, BUF_FAT)
    repeat cluster from 0 to 127
      if long[@fat_buf + cluster << 2] == 0
        result++
  result := result * sec_per_clus

PRI do_sync()
' Internal sync operation - flushes pending writes without closing file.

  if flags & F_NEWDATA
    writeSector(n_sec, BUF_DATA)
    flags := flags & !F_NEWDATA
  if flags & F_NEWDIR
    readSector(entry_address >> 9, BUF_DIR)
    bytemove(@dir_buf + (entry_address & 511), @entry_buffer, 32)
    writeSector(entry_address >> 9, BUF_DIR)
    flags := flags & !F_NEWDIR

PRI do_rename(old_name, new_name) : result | bookmark, temp_sec, i, saved_entry[8], p_buf
' Internal rename operation - renames file/directory by updating directory entry.
' Finds old file, saves entry, parses new_name into 8.3 format, writes back.
'
' @param old_name - Pointer to current filename string
' @param new_name - Pointer to new filename string
' @returns result - SUCCESS on success, E_FILE_NOT_FOUND on failure
' @local bookmark - Saved entry address
' @local temp_sec - Saved directory sector
' @local i - Loop counter
' @local saved_entry - Saved directory entry (32 bytes = 8 longs)
' @local p_buf - Pointer to buffer position

  debug("  [do_rename] old=", zstr_(old_name), " new=", zstr_(new_name), " dir_sec=", udec_(cog_dir_sec[pb_caller]))
  if searchDirectory(old_name)
    debug("  [do_rename] Found old file, entry_address=", uhex_(entry_address))
    bookmark := entry_address
    temp_sec := cog_dir_sec[pb_caller]
    bytemove(@saved_entry, @entry_buffer, 32)                                  ' Save complete entry (32 bytes)
    cog_dir_sec[pb_caller] := entry_address >> 9                                ' Search in same directory
    i := 0
    repeat until byte[new_name + i] == $00
      if byte[new_name + i] == "/"
        new_name += i+1
        i := 0
      i++
    debug("  [do_rename] Checking if new name exists...")
    if searchDirectory(new_name) == 0                                           ' Verify new name doesn't exist
      debug("  [do_rename] New name doesn't exist, proceeding")
      bytemove(@entry_buffer, @saved_entry, 32)                                ' Restore complete entry
      readSector(bookmark >> 9, BUF_DIR)
      ' Parse new_name directly into buffer in 8.3 format
      p_buf := @dir_buf + (bookmark & 511)
      i := 0
      repeat until byte[new_name + i] == "/" or byte[new_name + i] == $00
        i++
      bytefill(p_buf, " ", 11)                                                 ' Clear name field
      bytemove(p_buf, new_name, i <# 12)                                       ' Copy name
      ' Convert to uppercase and handle 8.3 extension
      repeat i from 0 to 10
        case byte[p_buf + i]
          "a".."z" : byte[p_buf + i] -= $20
          "." :
            ' Found extension separator - move extension to position 8
            bytemove(p_buf + 8, p_buf + i + 1, 3)
            bytefill(p_buf + i, " ", 8 - i)
            quit
      writeSector(bookmark >> 9, BUF_DIR)
      cog_dir_sec[pb_caller] := temp_sec
      debug("  [do_rename] SUCCESS")
      return SUCCESS
    else
      debug("  [do_rename] New name already exists!")
  else
    debug("  [do_rename] Old file NOT FOUND")
  return E_FILE_NOT_FOUND

PRI do_movefile(name_ptr, dest_folder) : result | bookmark, p_temp, temp_sec
' Internal move file operation - moves file from current directory to destination.
'
' @param name_ptr - Pointer to filename to move
' @param dest_folder - Pointer to destination folder name
' @returns result - SUCCESS on success, E_FILE_NOT_FOUND on failure
' @local bookmark - Saved entry address
' @local p_temp - Pointer to temporary filename buffer
' @local temp_sec - Saved directory sector

  p_temp := @"FILENAME.TXT"
  if do_open(name_ptr) == SUCCESS
    bookmark := entry_address
    bytemove(p_temp, filename(), 12)
    temp_sec := cog_dir_sec[pb_caller]
    if do_chdir(dest_folder) == SUCCESS
      if bookmark >> 9 == n_sec
        return E_FILE_EXISTS                                                    ' Same directory
      if do_newfile(p_temp) == SUCCESS
        debug("  [do_movefile] newfile OK, new entry_address=", uhex_(entry_address))
        debug("  [do_movefile] Reading sector ", udec_(bookmark >> 9), " (dir_sec_in_buf=", sdec_(dir_sec_in_buf), ")")
        readSector(bookmark >> 9, BUF_DIR)
        debug("  [do_movefile] After read: dir_buf[128]=[", lstr_(@dir_buf + 128, 11), "] dir_buf[", udec_(bookmark & 511), "]=[", lstr_(@dir_buf + (bookmark & 511), 11), "]")
        bytemove(@entry_buffer, @dir_buf + (bookmark & 511), 32)
        debug("  [do_movefile] Copied entry: [", lstr_(@entry_buffer, 11), "]")
        byte[@dir_buf + (bookmark & 511)] := $E5
        debug("  [do_movefile] After $E5: dir_buf[128]=[", lstr_(@dir_buf + 128, 11), "]")
        writeSector(bookmark >> 9, BUF_DIR)
        debug("  [do_movefile] Calling do_close, flags=", uhex_(flags))
        do_close()
        cog_dir_sec[pb_caller] := temp_sec
        return SUCCESS
      else
        debug("  [do_movefile] do_newfile FAILED")
    else
      debug("  [do_movefile] do_chdir FAILED for: ", zstr(dest_folder))
    cog_dir_sec[pb_caller] := temp_sec
  return E_FILE_NOT_FOUND

PRI do_readdir(entry_num) : result | idx, char, attrib
' Internal read directory operation - reads directory entry at specified index.
'
' @param entry_num - Entry index to read (0-based)
' @returns result - SUCCESS on success, E_FILE_NOT_FOUND if entry doesn't exist
' @local idx - Current byte offset in directory
' @local char - First character of entry
' @local attrib - Entry attributes

  idx := 0
  n_sec := cog_dir_sec[pb_caller]
  readSector(n_sec, BUF_DIR)

  repeat until entry_num == -1
    char := byte[@dir_buf + (idx & 511)]
    attrib := byte[@dir_buf + (idx & 511) + 11]

    if char == $00
      return E_FILE_NOT_FOUND
    elseif char <> $E5
      if attrib & %0000_1110 == 0
        entry_num--
        if entry_num == -1
          bytemove(@entry_buffer, @dir_buf + (idx & 511), 32)
          return SUCCESS
    idx += 32
    if idx & 511 == 0
      readNextSector(BUF_DIR)
  return E_FILE_NOT_FOUND

CON '' ═══════════════════════════════════════════════════════════════════════════
    '' PUBLIC API - Multi-cog safe via worker cog
    '' All operations are serialized through send_command()
    '' ═══════════════════════════════════════════════════════════════════════════

CON     '' management methods
PUB mount(_cs, _mosi, _miso, _sck) : result
'' Mount SD card (multi-cog safe) - starts worker cog and mounts filesystem.
'' Supports MODE_RAW -> MODE_FILESYSTEM upgrade (card already initialized).
''
'' @param _cs - Chip select pin number
'' @param _mosi - Master Out Slave In pin number
'' @param _miso - Master In Slave Out pin number
'' @param _sck - Serial clock pin number
'' @returns result - TRUE on success, FALSE on failure

  ' Check if already mounted
  if driver_mode == MODE_FILESYSTEM
    debug("  [mount] Already mounted")
    return true

  ' MODE_RAW -> MODE_FILESYSTEM upgrade is allowed
  ' Worker is already running, just send mount command
  if driver_mode == MODE_RAW
    debug("  [mount] Upgrading from RAW to FILESYSTEM mode")

  ' Start worker cog if not already running (MODE_NONE case)
  if cog_id == -1
    if start(_cs, _mosi, _miso, _sck) == -1
      debug("  [mount] Failed to start worker cog")
      return false

  ' Send mount command to worker
  result := send_command(CMD_MOUNT, 0, 0, 0, 0)
  if result == SUCCESS
    debug("  [mount] Mount successful, mode=FILESYSTEM")
    return true
  else
    debug("  [mount] Mount failed with error ", sdec_(result))
    set_error(result)
    return false

#IFDEF SD_INCLUDE_RAW
PUB initCardOnly(_cs, _mosi, _miso, _sck) : result
'' Initialize SD card without mounting filesystem - for raw sector access.
'' Use this for low-level operations like formatting. Does NOT read filesystem.
'' Starts worker cog and initializes card for raw sector access (MODE_RAW).
''
'' @param _cs - Chip select pin number
'' @param _mosi - Master Out Slave In pin number
'' @param _miso - Master In Slave Out pin number
'' @param _sck - Serial clock pin number
'' @returns result - TRUE if card initialized successfully, FALSE otherwise

  debug("  [initCardOnly] Pins: CS=P", udec_(_cs), " MOSI=P", udec_(_mosi), " MISO=P", udec_(_miso), " SCK=P", udec_(_sck))

  ' Check if already in filesystem mode - reject (must unmount first)
  if driver_mode == MODE_FILESYSTEM
    debug("  [initCardOnly] REJECTED: Already mounted as filesystem, unmount first")
    return false

  ' Check if already in raw mode - already initialized
  if driver_mode == MODE_RAW
    debug("  [initCardOnly] Already initialized in raw mode")
    return true

  ' Start worker cog if not already running
  if cog_id == -1
    if start(_cs, _mosi, _miso, _sck) == -1
      debug("  [initCardOnly] FAIL: Could not start worker cog")
      return false

  ' Send init command to worker
  result := send_command(CMD_INIT_CARD_ONLY, 0, 0, 0, 0)
  if result == SUCCESS
    debug("  [initCardOnly] Card initialized successfully via worker")
    return true
  else
    debug("  [initCardOnly] Card initialization failed, error=", sdec_(result))
    return false

PUB cardSizeSectors() : result
'' Get total sectors on card via worker cog.
'' Must call initCardOnly() or mount() first.
''
'' @returns result - Total number of 512-byte sectors on the card

  if cog_id == -1
    debug("  [cardSizeSectors] ERROR: Worker not running")
    return 0
  send_command(CMD_GET_CARD_SIZE, 0, 0, 0, 0)
  result := pb_data0
  debug("  [cardSizeSectors] ", udec(result), " sectors")
#ENDIF

#IFDEF SD_INCLUDE_RAW
PUB testCMD13() : r2_response | r1, status
'' TEST ONLY: Send CMD13 and return raw R2 response.
'' For testing/validation of CMD13 (SEND_STATUS) functionality.
'' NOTE: This is a diagnostic method - not for normal operation.
''
'' @returns r2_response - R2 response word ($0000=OK, $FFFF=timeout, other=error)
'' @local r1 - R1 response byte
'' @local status - Status byte from R2

  ' Send dummy clocks with CS HIGH to ensure card is ready
  pinh(cs)
  sp_transfer_8($FF)
  sp_transfer_8($FF)

  ' CMD13 requires CS to be asserted
  pinl(cs)

  ' Send CMD13 with no argument (RCA = 0x0000 for SPI mode)
  sp_transfer_8($40 | CMD13)                                                    ' Command byte: 0x40 | 13 = 0x4D
  sp_transfer_8($00)                                                            ' Argument bytes (RCA, unused in SPI)
  sp_transfer_8($00)
  sp_transfer_8($00)
  sp_transfer_8($00)
  sp_transfer_8($FF)                                                            ' CRC disabled after init in SPI mode

  ' Get R1 response (first byte of R2)
  r1 := waitR1Response()
  if r1 < 0
    debug("  [testCMD13] TIMEOUT waiting for R1")
    pinh(cs)
    return $FFFF

  ' Get status byte (second byte of R2)
  status := sp_transfer_8($FF)

  pinh(cs)                                                                      ' Deselect card

  ' Combine into R2 response word
  r2_response := (r1 << 8) | status

  ' Log detailed results
  debug("  [testCMD13] R1=$", uhex_byte_(r1), " STATUS=$", uhex_byte_(status), " -> R2=$", uhex_word_(r2_response))
  if r1 <> 0
    debug("    R1 errors:")
    if r1 & $40
      debug("      -> PARAMETER_ERROR")
    if r1 & $20
      debug("      -> ADDRESS_ERROR")
    if r1 & $10
      debug("      -> ERASE_SEQ_ERROR")
    if r1 & $08
      debug("      -> COM_CRC_ERROR")
    if r1 & $04
      debug("      -> ILLEGAL_COMMAND")
    if r1 & $02
      debug("      -> ERASE_RESET")
    if r1 & $01
      debug("      -> IN_IDLE_STATE")
  if status <> 0
    debug("    STATUS errors:")
    if status & CSR_OUT_OF_RANGE
      debug("      -> OUT_OF_RANGE")
    if status & CSR_ERASE_PARAM
      debug("      -> ERASE_PARAM")
    if status & CSR_WP_VIOLATION
      debug("      -> WP_VIOLATION")
    if status & CSR_CARD_ECC_FAILED
      debug("      -> CARD_ECC_FAILED")
    if status & CSR_CC_ERROR
      debug("      -> CC_ERROR")
    if status & CSR_ERROR
      debug("      -> ERROR")
    if status & CSR_WP_ERASE_SKIP
      debug("      -> WP_ERASE_SKIP")
    if status & CSR_CARD_IS_LOCKED
      debug("      -> CARD_IS_LOCKED")
#ENDIF

#IFDEF SD_INCLUDE_RAW
PUB writeSectorRaw(sector, p_buffer) : result
'' Write a sector at absolute LBA address - low-level for formatting/partitioning.
'' Bypasses filesystem. Requires initCardOnly() or mount() first.
''
'' @param sector - Absolute LBA sector number
'' @param p_buffer - Pointer to 512 bytes of data to write
'' @returns result - TRUE on success, FALSE on failure

  ' Require worker cog to be running (no direct access allowed)
  if cog_id == -1
    debug("  [writeSectorRaw] ERROR: Worker not running - call initCardOnly() or mount() first")
    return false
  result := send_command(CMD_WRITE_SECTOR_RAW, sector, p_buffer, 0, 0) == SUCCESS
  if result
    debug("  [writeSectorRaw] Wrote sector ", udec(sector))
  else
    debug("  [writeSectorRaw] FAILED to write sector ", udec(sector))

PUB readSectorRaw(sector, p_buffer) : result
'' Read a sector at absolute LBA address - low-level for verification.
'' Bypasses filesystem. Requires initCardOnly() or mount() first.
''
'' @param sector - Absolute LBA sector number
'' @param p_buffer - Pointer to 512-byte buffer to receive data
'' @returns result - TRUE on success, FALSE on failure

  ' Require worker cog to be running (no direct access allowed)
  if cog_id == -1
    debug("  [readSectorRaw] ERROR: Worker not running - call initCardOnly() or mount() first")
    return false
  result := send_command(CMD_READ_SECTOR_RAW, sector, p_buffer, 0, 0) == SUCCESS
  debug("  [readSectorRaw] Read sector ", udec(sector))

PUB readSectorsRaw(start_sector, count, p_buffer) : result
'' Read multiple consecutive sectors - multi-block read using CMD18.
'' More efficient than calling readSectorRaw() in a loop.
''
'' @param start_sector - First sector to read (absolute LBA)
'' @param count - Number of sectors to read
'' @param p_buffer - Pointer to buffer (must be count * 512 bytes)
'' @returns result - Number of sectors successfully read

  if send_command(CMD_READ_SECTORS, start_sector, count, p_buffer, 0) == SUCCESS
    result := pb_data0
  else
    result := 0

PUB writeSectorsRaw(start_sector, count, p_buffer) : result
'' Write multiple consecutive sectors - multi-block write using CMD25.
'' More efficient than calling writeSectorRaw() in a loop.
''
'' @param start_sector - First sector to write (absolute LBA)
'' @param count - Number of sectors to write
'' @param p_buffer - Pointer to buffer with data (must be count * 512 bytes)
'' @returns result - Number of sectors successfully written

  if send_command(CMD_WRITE_SECTORS, start_sector, count, p_buffer, 0) == SUCCESS
    result := pb_data0
  else
    result := 0
#ENDIF

#IFDEF SD_INCLUDE_REGISTERS
CON '' ═══════════════════════════════════════════════════════════════════════════
    '' CARD IDENTIFICATION METHODS (for diagnostic tools)
    '' These methods provide raw register access for card characterization.
    '' Call initCardOnly() or mount() before using these methods.
    '' ═══════════════════════════════════════════════════════════════════════════

PUB readCIDRaw(p_buf) : result | status
'' Read CID register (16 bytes) into buffer.
'' Contains manufacturer ID, product name, serial number, and manufacturing date.
'' Routes through worker cog which owns the SPI pins.
''
'' @param p_buf - Pointer to 16-byte buffer to receive CID data
'' @returns result - TRUE on success, FALSE on failure
'' @local status - Command status

  status := send_command(CMD_READ_CID, p_buf, 0, 0, 0)
  if status == SUCCESS
    debug("  [readCIDRaw] CID read successfully")
    result := true
  else
    debug("  [readCIDRaw] CID read FAILED")
    result := false

PUB readCSDRaw(p_buf) : result | status
'' Read CSD register (16 bytes) into buffer.
'' Contains card capacity, speed, and features.
'' Routes through worker cog which owns the SPI pins.
''
'' @param p_buf - Pointer to 16-byte buffer to receive CSD data
'' @returns result - TRUE on success, FALSE on failure
'' @local status - Command status

  status := send_command(CMD_READ_CSD, p_buf, 0, 0, 0)
  if status == SUCCESS
    debug("  [readCSDRaw] CSD read successfully")
    result := true
  else
    debug("  [readCSDRaw] CSD read FAILED")
    result := false

PUB readSCRRaw(p_buf) : result | status
'' Read SCR register (8 bytes) into buffer.
'' Contains SD spec version and bus widths.
'' Routes through worker cog which owns the SPI pins.
''
'' @param p_buf - Pointer to 8-byte buffer to receive SCR data
'' @returns result - TRUE on success, FALSE on failure
'' @local status - Command status

  status := send_command(CMD_READ_SCR, p_buf, 0, 0, 0)
  if status == SUCCESS
    debug("  [readSCRRaw] SCR read successfully")
    result := true
  else
    debug("  [readSCRRaw] SCR read FAILED")
    result := false

PUB getOCR() : ocr
'' Get cached OCR register value - Operating Conditions Register from card init.
'' Contains card capacity status (CCS) and voltage range.
''
'' @returns ocr - 32-bit OCR value, or 0 if card not initialized

  ocr := ocr_value
  debug("  [getOCR] OCR = $", uhex_long(ocr))

PUB readVBRRaw(p_buf) : result
'' Read Volume Boot Record (512 bytes) into buffer.
'' Card must be mounted for this method to work (VBR location determined at mount).
''
'' @param p_buf - Pointer to 512-byte buffer to receive VBR data
'' @returns result - TRUE on success, FALSE if not mounted

  if not (flags & F_MOUNTED)
    debug("  [readVBRRaw] FAILED: Card not mounted")
    return false
  sec_in_buf := -1                                                              '  force re-read
  readSector(vbr_sec, BUF_DATA)
  bytemove(p_buf, @buf, 512)
  debug("  [readVBRRaw] VBR read from sector ", udec(vbr_sec))
  return true
#ENDIF

PRI readCSD(p_csd) : result | t, i
' Read CSD register using CMD9 - reads 16-byte CSD register into buffer.
' Uses smart pin operations for compatibility with smart pin SPI mode.
'
' @param p_csd - Pointer to 16-byte buffer to receive CSD data
' @returns result - TRUE on success, FALSE on failure
' @local t - Timeout counter
' @local i - Loop counter

  sp_transfer_8($FF)
  pinl(cs)
  sp_transfer_8($FF)
  sp_transfer_8($40 | 9)                                                        '  CMD9 = SEND_CSD
  sp_transfer(0, 32)                                                            '  argument = 0
  sp_transfer_8($AF)                                                            '  CRC (approximate)

  ' Wait for response
  t := getct() + clkfreq
  repeat
    result := sp_transfer_8($FF)
    if result <> $FF
      quit
    if getct() - t > 0
      pinh(cs)
      return false

  if result <> $00
    pinh(cs)
    return false

  ' Wait for data token ($FE)
  t := getct() + clkfreq
  repeat
    result := sp_transfer_8($FF)
    if result == $FE
      quit
    if getct() - t > 0
      pinh(cs)
      return false

  ' Read 16 bytes of CSD data
  repeat i from 0 to 15
    byte[p_csd + i] := sp_transfer_8($FF)

  ' Read and discard 2-byte CRC
  sp_transfer_8($FF)
  sp_transfer_8($FF)

  pinh(cs)
  return true

PRI readCID(p_cid) : result | t, i
' Read CID register using CMD10 - reads 16-byte Card Identification register.
' Uses smart pin operations for compatibility with smart pin SPI mode.
'
' @param p_cid - Pointer to 16-byte buffer to receive CID data
' @returns result - TRUE on success, FALSE on failure
' @local t - Timeout counter
' @local i - Loop counter

  sp_transfer_8($FF)
  pinl(cs)
  sp_transfer_8($FF)
  sp_transfer_8($40 | 10)                                                       '  CMD10 = SEND_CID
  sp_transfer(0, 32)                                                            '  argument = 0
  sp_transfer_8($1B)                                                            '  CRC for CMD10

  ' Wait for response
  t := getct() + clkfreq
  repeat
    result := sp_transfer_8($FF)
    if result <> $FF
      quit
    if getct() - t > 0
      pinh(cs)
      return false

  if result <> $00
    pinh(cs)
    return false

  ' Wait for data token ($FE)
  t := getct() + clkfreq
  repeat
    result := sp_transfer_8($FF)
    if result == $FE
      quit
    if getct() - t > 0
      pinh(cs)
      return false

  ' Read 16 bytes of CID data
  repeat i from 0 to 15
    byte[p_cid + i] := sp_transfer_8($FF)

  ' Read and discard 2-byte CRC
  sp_transfer_8($FF)
  sp_transfer_8($FF)

  pinh(cs)
  return true

PRI parseTransSpeed(p_csd) : speed_hz | tran_speed, time_val, mult_val
' Parse TRAN_SPEED from CSD register - returns max transfer speed in Hz.
' TRAN_SPEED format: bits [2:0] = rate unit, bits [6:3] = time value.
'
' @param p_csd - Pointer to CSD register data
' @returns speed_hz - Maximum transfer speed in Hz
' @local tran_speed - Raw TRAN_SPEED byte
' @local time_val - Time value multiplier
' @local mult_val - Transfer rate unit multiplier

  tran_speed := byte[p_csd + 3]

  ' Time value multiplier (bits 6:3) - values per spec
  case (tran_speed >> 3) & $0F
    0:  time_val := 0       ' Reserved
    1:  time_val := 10      ' 1.0
    2:  time_val := 12      ' 1.2
    3:  time_val := 13      ' 1.3
    4:  time_val := 15      ' 1.5
    5:  time_val := 20      ' 2.0
    6:  time_val := 25      ' 2.5
    7:  time_val := 30      ' 3.0
    8:  time_val := 35      ' 3.5
    9:  time_val := 40      ' 4.0
    10: time_val := 45      ' 4.5
    11: time_val := 50      ' 5.0
    12: time_val := 55      ' 5.5
    13: time_val := 60      ' 6.0
    14: time_val := 70      ' 7.0
    15: time_val := 80      ' 8.0

  ' Transfer rate unit (bits 2:0) - values per spec
  case tran_speed & $07
    0:  mult_val := 100_000 / 10        ' 100 kbit/s
    1:  mult_val := 1_000_000 / 10      ' 1 Mbit/s
    2:  mult_val := 10_000_000 / 10     ' 10 Mbit/s
    3:  mult_val := 100_000_000 / 10    ' 100 Mbit/s (not used in SPI mode)
    other: mult_val := 0               ' Reserved

  speed_hz := time_val * mult_val
  debug("  [parseTransSpeed] TRAN_SPEED=$", uhex_byte_(tran_speed), " -> ", udec(speed_hz / 1_000_000), " MHz")
  return speed_hz

PRI parseMfrId(p_cid) : mfr_id
' Extract manufacturer ID from CID register byte 0.
' Common IDs: $03=SanDisk, $1D=PNY/AData, $27=Samsung, $28=Lexar, $74=Transcend.
'
' @param p_cid - Pointer to CID register data
' @returns mfr_id - Manufacturer ID byte

  mfr_id := byte[p_cid]
  debug("  [parseMfrId] Manufacturer ID=$", uhex_byte_(mfr_id))
  return mfr_id

PRI parseTimeouts(p_csd) | csd_ver, taac, nsac, r2w_factor, read_timeout_ns, time_val, time_unit
' Extract timeout values from CSD register - sets card_read_timeout_ms and card_write_timeout_ms.
' SDHC/SDXC: Fixed values (100ms read, 250ms write).
' SDSC: Calculated from TAAC, NSAC, and R2W_FACTOR.
'
' @param p_csd - Pointer to CSD register data
' @local csd_ver - CSD structure version
' @local taac - Data read access time-1
' @local nsac - Data read access time-2 in CLK cycles
' @local r2w_factor - Read to write factor
' @local read_timeout_ns - Read timeout in nanoseconds
' @local time_val - Time value multiplier
' @local time_unit - Time unit in nanoseconds

  csd_ver := byte[p_csd] >> 6                                                   ' CSD_STRUCTURE in bits [7:6] of byte 0

  if csd_ver == 1
    ' CSD Version 2.0 (SDHC/SDXC): Use fixed timeouts per SD Physical Layer spec
    card_read_timeout_ms := 100                                                 ' 100ms read timeout
    card_write_timeout_ms := 250                                                ' 250ms write timeout
    debug("  [parseTimeouts] SDHC/SDXC: read=", udec_(card_read_timeout_ms), "ms, write=", udec_(card_write_timeout_ms), "ms (fixed per spec)")
  else
    ' CSD Version 1.0 (SDSC): Calculate from TAAC, NSAC, R2W_FACTOR
    taac := byte[p_csd + 1]                                                     ' Data read access time-1 (TAAC)
    nsac := byte[p_csd + 2]                                                     ' Data read access time-2 (NSAC) in CLK cycles
    r2w_factor := (byte[p_csd + 12] >> 2) & $07                                 ' R2W_FACTOR bits [4:2] of byte 12

    ' Parse TAAC: time value in bits [6:3], time unit in bits [2:0]
    case (taac >> 3) & $0F                                                      ' Time value multiplier
      0:  time_val := 0                                                         ' Reserved
      1:  time_val := 10
      2:  time_val := 12
      3:  time_val := 13
      4:  time_val := 15
      5:  time_val := 20
      6:  time_val := 25
      7:  time_val := 30
      8:  time_val := 35
      9:  time_val := 40
      10: time_val := 45
      11: time_val := 50
      12: time_val := 55
      13: time_val := 60
      14: time_val := 70
      15: time_val := 80

    case taac & $07                                                             ' Time unit (nanoseconds)
      0:  time_unit := 1                                                        ' 1 ns
      1:  time_unit := 10                                                       ' 10 ns
      2:  time_unit := 100                                                      ' 100 ns
      3:  time_unit := 1_000                                                    ' 1 us
      4:  time_unit := 10_000                                                   ' 10 us
      5:  time_unit := 100_000                                                  ' 100 us
      6:  time_unit := 1_000_000                                                ' 1 ms
      7:  time_unit := 10_000_000                                               ' 10 ms

    ' Read timeout = TAAC + NSAC * 100 (NSAC is in clock cycles / 100)
    ' For safety, multiply by 100 to get worst-case timeout
    read_timeout_ns := (time_val * time_unit) * 100                             ' Apply 100x safety factor
    card_read_timeout_ms := (read_timeout_ns / 1_000_000) #> 100                ' Minimum 100ms

    ' Write timeout = read timeout * 2^R2W_FACTOR
    card_write_timeout_ms := (card_read_timeout_ms << r2w_factor) #> 250 <# 1000  ' Min 250ms, max 1000ms

    debug("  [parseTimeouts] SDSC: TAAC=$", uhex_byte_(taac), " NSAC=", udec_(nsac), " R2W=", udec_(r2w_factor))
    debug("  [parseTimeouts] SDSC: read=", udec_(card_read_timeout_ms), "ms, write=", udec_(card_write_timeout_ms), "ms")

PRI identifyCard() | cid[4], csd[4]
' Read card identity and configure adaptive timing.
' Reads CID/CSD, identifies brand, sets optimal SPI speed.
' PNY cards get conservative 20 MHz, others use 25 MHz.
'
' @local cid - CID register data (4 longs = 16 bytes)
' @local csd - CSD register data (4 longs = 16 bytes)

  debug("  [identifyCard] Reading card registers...")

  ' Read CID to identify manufacturer
  if readCID(@cid)
    card_mfr_id := parseMfrId(@cid)
    case card_mfr_id
      $1D:                                                                      ' AData/PNY
        card_is_slow := true
        debug("  [identifyCard] Detected PNY/AData card - using conservative timing")
      $03:                                                                      ' SanDisk
        card_is_slow := false
        debug("  [identifyCard] Detected SanDisk card - using standard timing")
      $27:                                                                      ' Samsung
        card_is_slow := false
        debug("  [identifyCard] Detected Samsung card - using standard timing")
      other:
        card_is_slow := false
        debug("  [identifyCard] Unknown manufacturer - using standard timing")
  else
    debug("  [identifyCard] WARNING: Could not read CID")
    card_mfr_id := 0
    card_is_slow := false

  ' Read CSD to get maximum speed and timeouts
  if readCSD(@csd)
    card_max_speed_hz := parseTransSpeed(@csd)
    parseTimeouts(@csd)
  else
    debug("  [identifyCard] WARNING: Could not read CSD")
    card_max_speed_hz := 25_000_000                                             ' Default to 25 MHz
    card_read_timeout_ms := 100                                                 ' Safe defaults
    card_write_timeout_ms := 500

PRI setOptimalSpeed()
' Set SPI speed based on card identification.
' Called after identifyCard() to configure optimal SPI clock.
' PNY cards limited to 20 MHz, others use max speed (up to 25 MHz).

  if card_is_slow
    setSPISpeed(20_000_000)                                                     ' 20 MHz for PNY cards
    debug("  [setOptimalSpeed] Limited to 20 MHz for slow card")
  else
    ' Use card's reported max speed, capped at 25 MHz for SPI mode
    if card_max_speed_hz > 25_000_000
      setSPISpeed(25_000_000)
    else
      setSPISpeed(card_max_speed_hz)
    debug("  [setOptimalSpeed] Set to card's max speed (up to 25 MHz)")

#IFDEF SD_INCLUDE_SPEED
CON '' High-Speed Mode Support (50 MHz via CMD6)

PRI sendCMD6(arg, p_status) : result | t, i
' Send CMD6 (SWITCH_FUNC) and receive 64-byte status structure.
' arg format: [31]=mode (0=check, 1=switch), [3:0]=function group 1 selection.
'
' @param arg - CMD6 argument word
' @param p_status - Pointer to 64-byte buffer to receive status
' @returns result - TRUE on success, FALSE on failure/timeout
' @local t - Timeout counter
' @local i - Loop counter

  sp_transfer_8($FF)
  pinl(cs)
  sp_transfer_8($FF)
  sp_transfer_8($40 | 6)                                                        '  CMD6 = SWITCH_FUNC
  sp_transfer(arg, 32)                                                          '  argument
  sp_transfer_8($FF)                                                            '  CRC (not checked in SPI mode)

  ' Wait for R1 response
  t := getct() + clkfreq
  repeat
    result := sp_transfer_8($FF)
    if result <> $FF
      quit
    if getct() - t > 0
      debug("  [sendCMD6] Timeout waiting for R1")
      pinh(cs)
      return false

  if result <> $00
    debug("  [sendCMD6] R1 error: $", uhex_byte_(result))
    pinh(cs)
    return false

  ' Wait for data token ($FE)
  t := getct() + clkfreq
  repeat
    result := sp_transfer_8($FF)
    if result == $FE
      quit
    if getct() - t > 0
      debug("  [sendCMD6] Timeout waiting for data token")
      pinh(cs)
      return false

  ' Read 64 bytes of status data
  repeat i from 0 to 63
    byte[p_status + i] := sp_transfer_8($FF)

  ' Read and discard 2-byte CRC
  sp_transfer_8($FF)
  sp_transfer_8($FF)

  pinh(cs)
  return true

PRI queryHighSpeedSupport() : result | scr[2], status[16], sd_spec
' Check if card supports high-speed mode - queries SCR and function group 1.
'
' @returns result - TRUE if high-speed (50 MHz) is supported
' @local scr - SCR register data (2 longs = 8 bytes)
' @local status - CMD6 status structure (16 longs = 64 bytes)
' @local sd_spec - SD spec version from SCR

  debug("  [queryHighSpeedSupport] Checking card capabilities...")

  ' First check SCR for CMD6 support (SD 2.0+ cards support CMD6)
  if not readSCR(@scr)
    debug("  [queryHighSpeedSupport] Failed to read SCR")
    return false

  sd_spec := scr.byte[0] & $0F                                                  '  SD_SPEC in bits [3:0]
  debug("  [queryHighSpeedSupport] SD_SPEC=", udec_(sd_spec))
  if sd_spec < 2
    debug("  [queryHighSpeedSupport] Card is SD 1.x - CMD6 not supported")
    return false
  debug("  [queryHighSpeedSupport] Card is SD 2.0+ - CMD6 supported")

  ' Query function group 1 using CMD6 mode 0 (check)
  ' Argument: 0x00FFFFF1 = check mode, access function group 1, query high-speed
  if not sendCMD6($00FFFFF1, @status)
    debug("  [queryHighSpeedSupport] CMD6 query failed")
    return false

  ' Status bytes 12-13 contain function group 1 support bits
  ' Bit 1 of byte 13 indicates high-speed support
  if (status.byte[13] & $02) == 0
    debug("  [queryHighSpeedSupport] High-speed function not supported")
    return false

  debug("  [queryHighSpeedSupport] High-speed (50 MHz) IS SUPPORTED")
  return true

PRI switchToHighSpeed() : result | status[16]
' Switch card to high-speed mode - sends CMD6 to switch function group 1.
'
' @returns result - TRUE if switch succeeded
' @local status - CMD6 status structure (16 longs = 64 bytes)

  debug("  [switchToHighSpeed] Sending CMD6 switch command...")

  ' Switch to high-speed using CMD6 mode 1 (switch)
  ' Argument: 0x80FFFFF1 = switch mode, access function group 1, select high-speed
  if not sendCMD6($80FFFFF1, @status)
    debug("  [switchToHighSpeed] CMD6 switch failed")
    return false

  ' Verify switch succeeded - check function group 1 selection in status
  ' Byte 16, bits 3:0 should be 1 (high-speed selected)
  if (status.byte[16] & $0F) <> 1
    debug("  [switchToHighSpeed] Switch not accepted, status=$", uhex_byte_(status.byte[16]))
    return false

  debug("  [switchToHighSpeed] Successfully switched to high-speed mode")
  return true

PUB attemptHighSpeed() : hs_ok | test_buf[128], verify_buf[128], i, mismatch
'' Attempt to enable 50 MHz high-speed mode with verification.
'' Queries capability, switches mode, verifies with sector read/write.
'' Safe to call - will not break operation on failure.
''
'' @returns hs_ok - TRUE if 50 MHz active, FALSE if fell back to 25 MHz
'' @local test_buf - Test data buffer (128 longs = 512 bytes)
'' @local verify_buf - Verification buffer (128 longs = 512 bytes)
'' @local i - Loop counter
'' @local mismatch - Count of mismatched longs

  debug("  [attemptHighSpeed] Attempting high-speed mode...")

  ' Skip if card is known to be slow (e.g., PNY)
  if card_is_slow
    debug("  [attemptHighSpeed] Skipped - card flagged as slow")
    return false

  ' Check if card supports high-speed
  if not queryHighSpeedSupport()
    debug("  [attemptHighSpeed] Card does not support high-speed")
    return false

  ' Switch to high-speed mode
  if not switchToHighSpeed()
    debug("  [attemptHighSpeed] Failed to switch to high-speed")
    return false

  ' Set 50 MHz SPI clock
  setSPISpeed(50_000_000)
  debug("  [attemptHighSpeed] SPI set to 50 MHz, verifying...")

  ' Verify by reading a sector, writing it back, reading again
  ' Use root directory sector as test (always valid after mount)
  readSector(root_sec, BUF_DATA)
  longmove(@test_buf, @buf, 128)                                                ' Copy 512 bytes

  writeSector(root_sec, BUF_DATA)                                               ' Write same data back
  bytefill(@buf, $AA, 512)                                                      ' Clear buffer with pattern

  readSector(root_sec, BUF_DATA)                                                ' Read again
  longmove(@verify_buf, @buf, 128)

  ' Compare
  mismatch := 0
  repeat i from 0 to 127
    if test_buf[i] <> verify_buf[i]
      mismatch++

  if mismatch > 0
    debug("  [attemptHighSpeed] VERIFICATION FAILED - ", udec_(mismatch), " long mismatches")
    debug("  [attemptHighSpeed] Falling back to 25 MHz")
    setSPISpeed(25_000_000)
    return false

  debug("  [attemptHighSpeed] VERIFIED - 50 MHz high-speed mode ACTIVE")
  return true
#ENDIF

PUB getSPIFrequency() : hz
'' Get current SPI clock frequency in Hz.
''
'' @returns hz - Current SPI clock frequency in Hz

  return spi_freq

PUB getCardMaxSpeed() : hz
'' Get card's reported maximum speed from CSD TRAN_SPEED field.
''
'' @returns hz - Card's maximum speed in Hz

  return card_max_speed_hz

PUB getManufacturerID() : mid
'' Get card manufacturer ID (MID) from CID register.
'' Common IDs: $03=SanDisk, $1D=PNY/AData, $27=Samsung.
''
'' @returns mid - Manufacturer ID byte

  return card_mfr_id

PUB getReadTimeout() : ms
'' Get read timeout from CSD register in milliseconds.
'' SDHC/SDXC: Fixed 100ms per spec. SDSC: Calculated from TAAC/NSAC.
''
'' @returns ms - Read timeout in milliseconds

  return card_read_timeout_ms

PUB getWriteTimeout() : ms
'' Get write timeout from CSD register in milliseconds.
'' SDHC/SDXC: Fixed 250ms per spec. SDSC: Read timeout * R2W_FACTOR.
''
'' @returns ms - Write timeout in milliseconds

  return card_write_timeout_ms

PUB isHighSpeedActive() : active
'' Check if high-speed mode is active (running at 50 MHz).
''
'' @returns active - TRUE if running at 50 MHz or higher

  return spi_freq >= 50_000_000

#IFDEF SD_INCLUDE_SPEED
PUB checkCMD6Support() : supported | scr[2], sd_spec
'' Check if card supports CMD6 command - reads SCR for SD spec version.
'' CMD6 supported by SD 2.0 and later cards (SD_SPEC >= 2).
''
'' @returns supported - TRUE if CMD6 is available
'' @local scr - SCR register data (2 longs = 8 bytes)
'' @local sd_spec - SD spec version from SCR

  if not readSCRRaw(@scr)
    debug("  [checkCMD6Support] Failed to read SCR")
    return false
  sd_spec := scr.byte[0] & $0F                                                  '  SD_SPEC in bits [3:0]
  debug("  [checkCMD6Support] SCR: $", uhex_byte_(scr.byte[0]), " $", uhex_byte_(scr.byte[1]), " SD_SPEC=", udec_(sd_spec))
  return sd_spec >= 2                                                           '  CMD6 supported in SD 2.0+

PUB checkHighSpeedCapability() : capable | status[16]
'' Check if card reports high-speed capability - queries function group 1.
'' Uses CMD6 mode 0 (check without switch).
'' Requires CMD6 support - call checkCMD6Support() first.
''
'' @returns capable - TRUE if high-speed function is supported
'' @local status - CMD6 status structure (16 longs = 64 bytes)

  if not sendCMD6($00FFFFF1, @status)
    return false
  return (status.byte[13] & $02) <> 0
#ENDIF

PRI readSCR(p_scr) : result | t, i
' Read SCR register using ACMD51 - reads 8-byte SD Configuration Register.
' Requires CMD55 prefix before ACMD51.
' Uses smart pin operations for compatibility.
'
' @param p_scr - Pointer to 8-byte buffer to receive SCR data
' @returns result - TRUE on success, FALSE on failure
' @local t - Timeout counter
' @local i - Loop counter

  debug("  [readSCR] Starting SCR read sequence")

  ' Send CMD55 (APP_CMD) first
  sp_transfer_8($FF)
  pinl(cs)
  sp_transfer_8($FF)
  sp_transfer_8($40 | 55)                                                       '  CMD55 = APP_CMD
  sp_transfer(0, 32)                                                            '  argument = 0
  sp_transfer_8($65)                                                            '  CRC for CMD55

  ' Wait for R1 response
  t := getct() + clkfreq
  repeat
    result := sp_transfer_8($FF)
    if result <> $FF
      quit
    if getct() - t > 0
      debug("  [readSCR] CMD55 timeout - no response")
      pinh(cs)
      return false

  debug("  [readSCR] CMD55 response: $", uhex_byte_(result))
  if result > $01                                                               '  Accept $00 or $01 (idle)
    debug("  [readSCR] CMD55 error response")
    pinh(cs)
    return false

  pinh(cs)                                                                      '  Deselect before ACMD51

  ' Send ACMD51 (SEND_SCR)
  sp_transfer_8($FF)
  pinl(cs)
  sp_transfer_8($FF)
  sp_transfer_8($40 | 51)                                                       '  ACMD51 = SEND_SCR
  sp_transfer(0, 32)                                                            '  argument = 0
  sp_transfer_8($55)                                                            '  CRC (approximate)

  ' Wait for R1 response
  t := getct() + clkfreq
  repeat
    result := sp_transfer_8($FF)
    if result <> $FF
      quit
    if getct() - t > 0
      debug("  [readSCR] ACMD51 timeout - no response")
      pinh(cs)
      return false

  debug("  [readSCR] ACMD51 response: $", uhex_byte_(result))
  if result <> $00
    debug("  [readSCR] ACMD51 error - expected $00")
    pinh(cs)
    return false

  ' Wait for data token ($FE)
  t := getct() + clkfreq
  repeat
    result := sp_transfer_8($FF)
    if result == $FE
      quit
    if getct() - t > 0
      debug("  [readSCR] Timeout waiting for data token $FE")
      pinh(cs)
      return false

  debug("  [readSCR] Got data token, reading 8 bytes")

  ' Read 8 bytes of SCR data
  repeat i from 0 to 7
    byte[p_scr + i] := sp_transfer_8($FF)

  ' Read and discard 2-byte CRC
  sp_transfer_8($FF)
  sp_transfer_8($FF)

  pinh(cs)
  debug("  [readSCR] Success")
  return true

PUB newFile(name_ptr) : result
'' Create and open a new file (multi-cog safe) in current directory.
''
'' @param name_ptr - Pointer to null-terminated filename string
'' @returns result - TRUE on success, FALSE if file exists or error

  result := send_command(CMD_NEWFILE, name_ptr, 0, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

PUB newDirectory(name_ptr) : result
'' Create a new directory (multi-cog safe) in current directory.
''
'' @param name_ptr - Pointer to null-terminated directory name string
'' @returns result - TRUE on success, FALSE if directory exists or error

  result := send_command(CMD_NEWDIR, name_ptr, 0, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

PUB openFile(name_ptr) : result
'' Open file (multi-cog safe) - opens existing file for reading/writing.
''
'' @param name_ptr - Pointer to null-terminated filename string
'' @returns result - TRUE on success, FALSE if not found

  result := send_command(CMD_OPEN, name_ptr, 0, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

PUB changeDirectory(name_ptr) : result
'' Change directory (multi-cog safe) - changes current directory.
''
'' @param name_ptr - Pointer to null-terminated directory name string
'' @returns result - TRUE on success, FALSE if not found

  result := send_command(CMD_CHDIR, name_ptr, 0, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

PUB closeFile()
'' Close file (multi-cog safe) - closes currently open file, flushing pending writes.

  send_command(CMD_CLOSE, 0, 0, 0, 0)

PUB unmount() : result
'' Unmount SD card (multi-cog safe) - cleanly unmounts, flushing data and updating FSInfo.
''
'' @returns result - TRUE on success

  result := send_command(CMD_UNMOUNT, 0, 0, 0, 0)
  debug("  [unmount] Card unmounted")
  return result == SUCCESS

PUB sync() : result
'' Flush buffers (multi-cog safe) - flushes pending writes without closing file.
'' Use to checkpoint data during long operations.
''
'' @returns result - TRUE on success

  result := send_command(CMD_SYNC, 0, 0, 0, 0)
  debug("  [sync] Buffers flushed")
  return result == SUCCESS

' ═══════════════════════════════════════════════════════════════════════════
' V3 HANDLE-BASED PUBLIC API
' Multi-file support with independent file handles
' ═══════════════════════════════════════════════════════════════════════════

PUB openFileRead(p_path) : handle
'' Open file for reading (V3 multi-file) - opens existing file and returns handle.
'' Multiple files can be open simultaneously with independent positions.
'' Use closeFileHandle() when done.
''
'' @param p_path - Pointer to null-terminated path string
'' @returns handle - File handle (0 to MAX_OPEN_FILES-1) on success, negative error code on failure

  send_command(CMD_OPEN_READ, p_path, 0, 0, 0)
  handle := pb_data0
  if handle >= 0
    debug("  [openFileRead] Opened handle ", udec_(handle))
  else
    debug("  [openFileRead] Failed: ", sdec_(handle))
    set_error(handle)
  return handle

PUB openFileWrite(p_path) : handle
'' Open file for writing/append (V3 multi-file) - opens for appending.
'' Position is set to end of file. Only one write handle per file allowed.
'' Use closeFileHandle() when done to flush data.
''
'' @param p_path - Pointer to null-terminated path string
'' @returns handle - File handle (0 to MAX_OPEN_FILES-1) on success, negative error code on failure

  send_command(CMD_OPEN_WRITE, p_path, 0, 0, 0)
  handle := pb_data0
  if handle >= 0
    debug("  [openFileWrite] Opened handle ", udec_(handle))
  else
    debug("  [openFileWrite] Failed: ", sdec_(handle))
    set_error(handle)
  return handle

PUB createFileNew(p_path) : handle
'' Create new file for writing (V3 multi-file) - creates and opens for writing.
'' Returns error if file exists.
'' Use closeFileHandle() when done to flush data and finalize size.
''
'' @param p_path - Pointer to null-terminated path string
'' @returns handle - File handle (0 to MAX_OPEN_FILES-1) on success, negative error code on failure

  send_command(CMD_CREATE, p_path, 0, 0, 0)
  handle := pb_data0
  if handle >= 0
    debug("  [createFileNew] Created handle ", udec_(handle))
  else
    debug("  [createFileNew] Failed: ", sdec_(handle))
    set_error(handle)
  return handle

PUB closeFileHandle(handle) : result
'' Close file handle (V3 multi-file) - closes handle, flushing pending writes.
'' For write handles, updates directory with final file size.
'' After close, handle is invalid and slot is available for reuse.
''
'' @param handle - File handle to close
'' @returns result - SUCCESS (0) on success, negative error code on failure

  result := send_command(CMD_CLOSE_H, handle, 0, 0, 0)
  if result == SUCCESS
    debug("  [closeFileHandle] Closed handle ", udec_(handle))
  else
    debug("  [closeFileHandle] Failed: ", sdec_(result))
    set_error(result)
  return result

PUB readHandle(handle, p_buffer, count) : bytes_read
'' Read from file handle (V3 multi-file) - reads up to count bytes into buffer.
'' Returns actual bytes read (may be less at EOF). Returns 0 at EOF.
'' Position advances by the number of bytes read.
''
'' @param handle - Valid read handle
'' @param p_buffer - Pointer to destination buffer
'' @param count - Maximum bytes to read
'' @returns bytes_read - Bytes actually read (0 at EOF), negative on error

  send_command(CMD_READ_H, handle, p_buffer, count, 0)
  bytes_read := pb_data0
  if bytes_read < 0
    debug("  [readHandle] Failed: ", sdec_(bytes_read))
    set_error(bytes_read)
  return bytes_read

PUB writeHandle(handle, p_buffer, count) : bytes_written
'' Write to file handle (V3 multi-file) - writes count bytes from buffer.
'' File grows as needed with automatic cluster allocation.
'' Position advances by the number of bytes written.
''
'' @param handle - Valid write handle
'' @param p_buffer - Pointer to source data
'' @param count - Bytes to write
'' @returns bytes_written - Bytes actually written, negative on error

  send_command(CMD_WRITE_H, handle, p_buffer, count, 0)
  bytes_written := pb_data0
  if bytes_written < 0
    debug("  [writeHandle] Failed: ", sdec_(bytes_written))
    set_error(bytes_written)
  return bytes_written

PUB seekHandle(handle, position) : result
'' Seek to position in file (V3 multi-file) - seeks to absolute byte position.
'' Position must be <= file size (cannot seek past EOF).
''
'' @param handle - Valid file handle
'' @param position - Absolute byte position to seek to
'' @returns result - SUCCESS (0) on success, negative error code on failure

  result := send_command(CMD_SEEK_H, handle, position, 0, 0)
  if result <> SUCCESS
    debug("  [seekHandle] Failed: ", sdec_(result))
    set_error(result)
  return result

PUB tellHandle(handle) : position
'' Get current position (V3 multi-file) - returns current byte position in file.
''
'' @param handle - Valid file handle
'' @returns position - Current position (0-based), negative on error

  send_command(CMD_TELL_H, handle, 0, 0, 0)
  if pb_status == SUCCESS
    position := pb_data0
  else
    position := pb_status
    set_error(position)
  return position

PUB eofHandle(handle) : is_eof
'' Check if at end of file (V3 multi-file) - returns TRUE if at or past EOF.
''
'' @param handle - Valid file handle
'' @returns is_eof - TRUE if at EOF, FALSE if not, negative on error

  send_command(CMD_EOF_H, handle, 0, 0, 0)
  if pb_status == SUCCESS
    is_eof := pb_data0 <> 0
  else
    is_eof := pb_status
    set_error(is_eof)
  return is_eof

PUB fileSizeHandle(handle) : size
'' Get file size (V3 multi-file) - returns total size in bytes.
'' For write handles, reflects current size including pending writes.
''
'' @param handle - Valid file handle
'' @returns size - File size in bytes, negative on error

  send_command(CMD_FILESIZE_H, handle, 0, 0, 0)
  if pb_status == SUCCESS
    size := pb_data0
  else
    size := pb_status
    set_error(size)
  return size

PUB syncHandle(handle) : result
'' Flush handle to disk (V3 multi-file) - flushes pending writes and updates directory.
'' File remains open for further operations.
''
'' @param handle - Valid file handle
'' @returns result - SUCCESS (0) on success, negative error code on failure

  result := send_command(CMD_SYNC_H, handle, 0, 0, 0)
  if result <> SUCCESS
    debug("  [syncHandle] Failed: ", sdec_(result))
    set_error(result)
  return result

PUB syncAllHandles() : result
'' Flush all handles to disk (V3 multi-file) - flushes all open write handles.
'' Useful before risky operations or for periodic safety.
''
'' @returns result - SUCCESS (0) on success

  result := send_command(CMD_SYNC_ALL, 0, 0, 0, 0)
  if result <> SUCCESS
    debug("  [syncAllHandles] Failed: ", sdec_(result))
    set_error(result)
  return result

PRI updateFSInfo() : result
' Update FSInfo sector with current free cluster count.
' Uses cached fsi_free_count (tracked incrementally during alloc/delete).
' Called by unmount() to ensure other OSes see correct free space.
'
' @returns result - TRUE on success, FALSE if no valid FSInfo

  if fsinfo_sec == 0 or fsi_free_count == $FFFF_FFFF
    debug("  [updateFSInfo] No valid FSInfo to update")
    return false                                                                '  no FSInfo sector to update

  ' Use cached free count (tracked incrementally, no FAT scan needed)

  ' Read FSInfo sector
  readSector(vbr_sec + fsinfo_sec, BUF_DATA)

  ' Verify signatures before writing
  if long[@buf + 0] <> $4161_5252 or long[@buf + 484] <> $6141_7272
    debug("  [updateFSInfo] Invalid FSInfo signatures")
    return false

  ' Update free count and next-free hint
  long[@buf + 488] := fsi_free_count                                            '  FSI_Free_Count (cached value)
  long[@buf + 492] := fsi_nxt_free                                              '  FSI_Nxt_Free (keep cached value)

  ' Write updated FSInfo sector (primary at sector 1, backup at sector 7)
  writeSector(vbr_sec + fsinfo_sec, BUF_DATA)
  writeSector(vbr_sec + 7, BUF_DATA)                                            '  backup FSInfo at sector 7
  debug("  [updateFSInfo] Updated primary+backup: free_count=", udec(fsi_free_count))
  return true

PRI countFreeClusters() : count | fat_idx, entry
' Count free clusters in FAT - scans entire FAT for zero entries.
' This is slow on large cards but only called on unmount().
'
' @returns count - Number of free clusters
' @local fat_idx - Current FAT byte index
' @local entry - Current FAT entry value

  count := 0
  fat_idx := 8                                                                  '  start at cluster 2 (skip reserved entries 0,1)
  repeat
    if fat_idx & 511 == 0                                                       '  if at sector boundary
      if fat_idx >> 9 >= sec_per_fat                                            '  if past end of FAT
        quit
      readSector(fat_sec + fat_idx >> 9, BUF_FAT)                               '  read next FAT sector
    entry := long[@fat_buf + (fat_idx & 511)]
    if (entry & $0FFF_FFFF) == 0                                                '  check only low 28 bits
      count++
    fat_idx += 4
  fat_sec_in_buf := -1                                                          '  invalidate FAT buffer

PUB deleteFile(name_ptr) : result
'' Delete file (multi-cog safe) - deletes file from current directory.
''
'' @param name_ptr - Pointer to null-terminated filename string
'' @returns result - TRUE on success, FALSE if not found or protected

  result := send_command(CMD_DELETE, name_ptr, 0, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

PUB rename(old_name, new_name) : result
'' Rename file or directory (multi-cog safe).
''
'' @param old_name - Pointer to current name string
'' @param new_name - Pointer to new name string
'' @returns result - TRUE on success, FALSE if source not found or dest exists

  result := send_command(CMD_RENAME, old_name, new_name, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

PUB moveFile(name_ptr, dest_folder) : result
'' Move file to another directory (multi-cog safe).
''
'' @param name_ptr - Pointer to filename to move
'' @param dest_folder - Pointer to destination folder name
'' @returns result - TRUE on success, FALSE on error

  result := send_command(CMD_MOVEFILE, name_ptr, dest_folder, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

PUB freeSpace() : result
'' Get free space in sectors (multi-cog safe).
'' This may take a while on large cards.
''
'' @returns result - Number of free sectors on the card

  if send_command(CMD_FREESPACE, 0, 0, 0, 0) == SUCCESS
    return pb_data0
  else
    return 0

PUB setDate(year, month, day, hour, minute, second)
'' Set the current date and time for new files/folders.
''
'' @param year - Year (e.g., 2024)
'' @param month - Month (1-12)
'' @param day - Day (1-31)
'' @param hour - Hour (0-23)
'' @param minute - Minute (0-59)
'' @param second - Second (0-59)

  date_stamp := (year - 1980) << 25 | month << 21 | day << 16 | hour << 11 | minute << 5 | second >> 1

CON     '' read/write methods
PUB read(p_buffer, count) : result
'' Read bytes from file (multi-cog safe) - reads up to count bytes.
''
'' @param p_buffer - Pointer to destination buffer
'' @param count - Maximum bytes to read
'' @returns result - Number of bytes actually read

  if send_command(CMD_READ, p_buffer, count, 0, 0) == SUCCESS
    return pb_data0                                                             ' pb_data0 contains bytes read
  else
    return 0

PUB readByte(address) : result | byte_buf
'' Read single byte from file (multi-cog safe) - seeks to address and reads one byte.
''
'' @param address - Byte offset to read from
'' @returns result - Byte value read, or 0 on error
'' @local byte_buf - Buffer for single byte read

  seek(address)
  if read(@byte_buf, 1) == 1
    return byte_buf
  else
    return 0

PUB write(p_buffer, count) : result
'' Write bytes to file (multi-cog safe) - writes count bytes to open file.
''
'' @param p_buffer - Pointer to source data
'' @param count - Number of bytes to write
'' @returns result - Command result status

  send_command(CMD_WRITE, p_buffer, count, 0, 0)

PUB writeByte(char) : result
'' Write single byte to file (multi-cog safe).
''
'' @param char - Byte value to write
'' @returns result - Command result status

  write(@char, 1)

PUB writeString(p_str) : result
'' Write string to file (multi-cog safe) - writes null-terminated string.
''
'' @param p_str - Pointer to null-terminated string
'' @returns result - Command result status

  write(p_str, strsize(p_str))

PUB readDirectory(entry) : result
'' Read directory entry (multi-cog safe) - iterates through directory entries.
''
'' @param entry - Entry index to read (0-based)
'' @returns result - Pointer to entry_buffer on success, 0 if entry doesn't exist

  if send_command(CMD_READDIR, entry, 0, 0, 0) == SUCCESS
    return @entry_buffer
  else
    return 0

PUB openDirectory(p_path) : handle
'' Open directory for enumeration (multi-cog safe) - returns handle for iterating entries.
'' Use readDirectoryHandle() to get entries, closeDirectoryHandle() when done.
'' Pass "" or "." to enumerate calling cog's current working directory.
'' Handles share the existing file handle pool (MAX_OPEN_FILES total).
''
'' @param p_path - Pointer to null-terminated path string
'' @returns handle - Handle on success, negative error code on failure

  send_command(CMD_OPEN_DIR, p_path, 0, 0, 0)
  handle := pb_data0
  return handle

PUB readDirectoryHandle(handle) : p_entry
'' Read next entry from directory handle (multi-cog safe) - returns pointer to entry data.
'' Skips deleted, LFN, and hidden/system entries automatically.
'' After each call, use fileName() and attributes() to inspect the returned entry.
''
'' @param handle - Directory handle from openDirectory()
'' @returns p_entry - Pointer to entry_buffer on success, 0 at end of directory

  if send_command(CMD_READ_DIR_H, handle, 0, 0, 0) == SUCCESS
    return @entry_buffer
  return 0

PUB closeDirectoryHandle(handle)
'' Close directory handle (multi-cog safe) - releases handle back to pool.
''
'' @param handle - Directory handle from openDirectory()

  send_command(CMD_CLOSE_DIR_H, handle, 0, 0, 0)

PUB seek(pos) : result
'' Seek to position in file (multi-cog safe) - sets file position.
''
'' @param pos - Byte position from start of file
'' @returns result - TRUE on success, FALSE if pos is beyond end of file

  result := send_command(CMD_SEEK, pos, 0, 0, 0)
  if result == SUCCESS
    return true
  else
    set_error(result)
    return false

CON     '' directory methods
PRI searchDirectory(name_ptr) : result | p_temp, p_entry, i, search_sec
' Search directory for a file/directory by name.
'
' @param name_ptr - Pointer to null-terminated path string
' @returns result - TRUE if found, FALSE otherwise
' @local p_temp - Pointer to temporary filename buffer
' @local p_entry - Pointer to current directory entry
' @local i - Loop counter
' @local search_sec - Local directory sector for path resolution

  p_temp := @"FILENAMETXT"
  search_sec := cog_dir_sec[pb_caller]
  if byte[name_ptr] == "/"
    search_sec := root_sec
    name_ptr++
  n_sec := search_sec

  repeat until byte[name_ptr] == $00
    bytefill(@entry_buffer,0,32)
    i := 0

    repeat until byte[name_ptr + i] == "/" or byte[name_ptr + i] == $00         '  advance i up to "/" or null
      i++
    bytemove(@entry_buffer,name_ptr,i <# 12)                                    '  copy name into entry_buffer, max 12 characters
    name_ptr += i                                                               '  advance ptr to "/" or null
    if byte[name_ptr] == "/"                                                    '  if "/"
      name_ptr++                                                                '   advance ptr to byte following "/"

    repeat i from 0 to 11                                                       '  convert name to uppercase
      case entry_buffer[i]
        "a".."z" : entry_buffer[i] -= $20

    i := 0                                                                      '  convert 8.3 filename into short filename
    if strcomp(@entry_buffer,string("..")) == 0                                 '  exception if changing directory to ".."
      repeat strsize(@entry_buffer) <# 9                                        '  search name for extension
        if entry_buffer[i++] == "."                                             '  if extension found
          bytemove(@entry_buffer + 8,@entry_buffer + i,3)                       '   move extension to byte 8
          bytefill(@entry_buffer + i-1," ",9-i)                                 '   fill space between name and extension
    bytefill(@entry_buffer + strsize(@entry_buffer)," ",12-strsize(@entry_buffer)) ' fill remaining space (in case extension < 3 characters)
    entry_buffer[11] := $00                                                     '  append null

    i := 0
    debug("  [searchDir] Starting search at n_sec=", udec_(n_sec), " for [", lstr_(@entry_buffer, 11), "]")
    readSector(n_sec, BUF_DIR)                                                  '  read 1st sector of directory
    debug("  [searchDir] After read: dir_buf[0]=[", lstr_(@dir_buf, 11), "] dir_buf[32]=[", lstr_(@dir_buf + 32, 11), "]")
    entry_address := 0
    repeat
      p_entry := @dir_buf + (i & 511)                                           '  locate entry in directory (FIXED precedence)
      bytemove(p_temp,p_entry,11)                                               '  copy short filename into p_temp
      byte[p_temp + 11] := 0                                                    '  null terminate for comparison
      if strcomp(@entry_buffer,p_temp)                                          '  if matching entry located
        entry_address := (n_sec << 9) | (i & 511)                               '   store the byte-level address of the entry
        bytemove(@entry_buffer,p_entry,32)                                      '   copy entire entry into entry_buffer
        debug("  [searchDir] FOUND at i=", udec_(i), " firstCluster=", udec_(firstCluster()), " n_sec will be ", udec_(clus2sec(firstCluster())))
        if firstCluster() == 0                                                  '  exception if ".." points to root directory
          n_sec := clus2sec(2)                                                  '   root directory located in cluster 2
        else
          n_sec := clus2sec(firstCluster())                                     '   set n_sec to 1st sector of 1st cluster of file
        quit
      elseif byte[name_ptr] == $00                                              '  if end of path reached
        if (entry_address == 0) and (byte[p_temp] == $E5 or byte[p_temp] == $00) '  if entry_address not set, and 1st byte is $E5 or $00
          entry_address := (n_sec << 9) | (i & 511)                             '    set entry_address to 1st unused entry (for newFile / newDirectory)
          debug("  [searchDir] Free slot at n_sec=", udec_(n_sec), " i=", udec_(i), " entry_address=$", uhex_(entry_address))

      if byte[p_temp] == $00                                                    '  entry not found in directory
        return false
      i += 32                                                                   '  increment to next entry
      if i & 511 == 0                                                           '  read new directory sector/cluster if needed
        readNextSector(BUF_DIR)
  file_idx := 0
  return true

PUB fileName() : result | p_temp, i
'' Return the 8.3 filename of the currently opened file.
''
'' @returns result - Pointer to filename string
'' @local p_temp - Pointer to temporary filename buffer
'' @local i - Loop counter for parsing

  p_temp := @"filename.txt"
  bytemove(p_temp,@entry_buffer,11)
  i := 0
  repeat until byte[p_temp + i++] == " " or i == 9
  bytemove(p_temp + i,p_temp + 8,3)
  if attributes() & $10
    byte[p_temp + i-1] := $00
  else
    byte[p_temp + i-1] := "."
    byte[p_temp + i+3] := $00
  return p_temp

PUB attributes() : result
'' Return the attribute byte of the currently opened file.
''
'' @returns result - FAT attribute byte

  return entry_buffer[$0B]

PUB volumeLabel() : result
'' Return pointer to volume label string.
''
'' @returns result - Pointer to volume label (11 chars + null)

  return @vol_label

PUB debugDumpRootDir() | sec, i, p_entry
'' DEBUG: Dump root directory entries to debug output.
'' This is a diagnostic function for debugging. It reads the root directory
'' and prints each entry's first 11 bytes (filename) and first cluster.
'' Called from test cog so output appears in headless logs.
''
'' @local sec - Current sector being read
'' @local i - Entry index counter
'' @local p_entry - Pointer to current directory entry

  sec := root_sec
  debug("  [debugDumpRootDir] root_sec=", udec_(sec), " cog_dir_sec=", udec_(cog_dir_sec[COGID()]))
  readSector(sec, BUF_DIR)
  debug("  [debugDumpRootDir] Read sector ", udec_(sec), " into dir_buf")
  repeat i from 0 to 15                                                         ' First 16 entries
    p_entry := @dir_buf + (i * 32)
    if byte[p_entry] == 0
      debug("  Entry ", udec_(i), ": [END OF DIR]")
      quit
    elseif byte[p_entry] == $E5
      debug("  Entry ", udec_(i), ": [DELETED]")
    else
      debug("  Entry ", udec_(i), ": [", lstr_(p_entry, 11), "] attr=$", uhex_byte_(byte[p_entry+11]), " clus=", udec_(word[p_entry+26] | (word[p_entry+20] << 16)))

PUB syncDirCache()
'' Force directory cache invalidation - invalidates the directory sector cache.
'' The next read will re-fetch from card.
'' Use after file operations to ensure consistency when multiple files are accessed.
'' This is safe to call from any cog (just sets a DAT variable to -1).

  dir_sec_in_buf := -1

PUB debugGetRootSec() : result
'' DEBUG: Return root_sec for diagnostic.
''
'' @returns result - Root directory sector number

  return root_sec

PUB debugGetDirSec() : result
'' DEBUG: Return calling cog's current directory sector for diagnostic.
''
'' @returns result - Current directory sector number for calling cog

  return cog_dir_sec[COGID()]

PUB debugGetVbrSec() : result
'' DEBUG: Return VBR sector for diagnostic.
''
'' @returns result - Volume Boot Record sector number

  return vbr_sec

PUB debugGetFatSec() : result
'' DEBUG: Return FAT sector for diagnostic.
''
'' @returns result - FAT start sector number

  return fat_sec

PUB debugGetSecPerFat() : result
'' DEBUG: Return sectors per FAT for diagnostic.
''
'' @returns result - Number of sectors per FAT

  return sec_per_fat

PUB debugClearRootDir() : result
'' DEBUG: Clear root directory (fixes corruption).
'' Clears the root directory by writing zeros to root_sec.
'' Use this to fix a corrupted root directory.
'' WARNING: This DELETES all files and folders!
''
'' @returns result - 0 on success, -1 on error

  result := send_command(CMD_DEBUG_CLEAR_ROOT, 0, 0, 0, 0)

PUB debugGetReadSectorDiag(p_sector, p_buftype, p_token, p_b0, p_b1, p_b2, p_b3, p_pbuf)
'' DEBUG: Get readSector diagnostic data - copies diagnostic data from last readSector call.
'' Call this after readSectorRaw() to see what happened inside readSector.
''
'' @param p_sector - Pointer to receive last sector number
'' @param p_buftype - Pointer to receive last buffer type
'' @param p_token - Pointer to receive last token ($FE on success)
'' @param p_b0 - Pointer to receive buffer byte 0
'' @param p_b1 - Pointer to receive buffer byte 1
'' @param p_b2 - Pointer to receive buffer byte 2
'' @param p_b3 - Pointer to receive buffer byte 3
'' @param p_pbuf - Pointer to receive buffer pointer

  long[p_sector] := diag_last_sector
  long[p_buftype] := diag_last_buftype
  long[p_token] := diag_last_token
  long[p_b0] := diag_buf_byte0
  long[p_b1] := diag_buf_byte1
  long[p_b2] := diag_buf_byte2
  long[p_b3] := diag_buf_byte3
  long[p_pbuf] := diag_p_buf

PUB debugGetReadSectorDiagExt(p_before0, p_before1, p_before2, p_before3, p_spi_period)
'' DEBUG: Get extended readSector diagnostic data - buffer state BEFORE streamer and SPI timing.
''
'' @param p_before0 - Pointer to receive buffer byte 0 before streamer
'' @param p_before1 - Pointer to receive buffer byte 1 before streamer
'' @param p_before2 - Pointer to receive buffer byte 2 before streamer
'' @param p_before3 - Pointer to receive buffer byte 3 before streamer
'' @param p_spi_period - Pointer to receive SPI period value

  long[p_before0] := diag_before_b0
  long[p_before1] := diag_before_b1
  long[p_before2] := diag_before_b2
  long[p_before3] := diag_before_b3
  long[p_spi_period] := diag_spi_period

PUB debugReadSectorSlow(sector, p_buffer) : result | data, i, timeout
'' DEBUG: Read sector byte-by-byte (no streamer) - for comparison with streamer.
'' This is SLOW but useful for debugging streamer issues.
'' Requires worker cog to be running (SPI pins configured).
''
'' NOTE: This runs in Cog0 and requires SPI smart pins to be configured for this cog.
''       It will NOT work with the normal V3 driver architecture.
''       This is for DIAGNOSTIC USE ONLY.
''
'' @param sector - Sector number to read
'' @param p_buffer - Pointer to 512-byte destination buffer
'' @returns result - 0 on success, -1 on timeout/error
'' @local data - (unused in wrapper)
'' @local i - (unused in wrapper)
'' @local timeout - (unused in wrapper)

  result := send_command(CMD_DEBUG_SLOW_READ, sector, p_buffer, 0, 0)

PRI firstCluster() : result
' Return the 1st cluster location of the currently opened file.
'
' @returns result - First cluster number (combined from entry bytes $14-$15 and $1A-$1B)

  return word[@entry_buffer + $14] << 16 | word[@entry_buffer + $1A]

PUB fileSize() : result
'' Return the size of the currently opened file in bytes.
''
'' @returns result - File size from directory entry

  return long[@entry_buffer + $1C]

CON     '' FAT and sector methods
PRI readFat(cluster) : result | contents, p_contents
' Read a FAT location and return a pointer to the location of that entry.
'
' @param cluster - Cluster number to look up
' @returns result - Pointer to FAT entry in fat_buf
' @local contents - (unused)
' @local p_contents - (unused)

  readSector((cluster >> 7 + fat_sec), BUF_FAT)                                 '  128 entries in each FAT sector
  result := @fat_buf + ((cluster << 2) & 511)

PRI allocateCluster(cluster) : result | fat_idx, buf_idx, high_bits
' Search FAT for an empty cluster, allocate it, and return cluster number.
' If cluster parameter is non-zero, links the new cluster to that chain.
'
' @param cluster - Previous cluster to link (0 for new chain)
' @returns result - Newly allocated cluster number
' @local fat_idx - Current FAT byte index
' @local buf_idx - Index within FAT buffer
' @local high_bits - Preserved high 4 bits of FAT entry

  fat_idx := 8                                                                  ' Start at cluster 2 (skip reserved 0,1)
  readSector(fat_sec, BUF_FAT)                                                  ' Pre-load first FAT sector
  '   if cluster parameter <> 0, writes newly allocated cluster number in parameter cell
  repeat
    if fat_idx & 511 == 0 and fat_idx > 0                                       '  if at sector boundary (but not first iteration)
      readSector(fat_sec + fat_idx >> 9, BUF_FAT)                               '   load next sector of FAT
    buf_idx := fat_idx & 511
    result := long[@fat_buf + buf_idx]                                          '  read a cluster cell
    if (result & $0FFF_FFFF) == $0000_0000                                      '  if cluster cell is empty (check only low 28 bits)
      high_bits := result & $F000_0000                                          '  preserve high 4 bits
      long[@fat_buf + buf_idx] := high_bits | $0FFF_FFFF                        '  mark as end-of-chain, preserve high bits
      result := fat_idx >> 2                                                    '  store cluster number in result
      writeSector(fat_sec + result >> 7, BUF_FAT)                               '  write FAT1 sector
      writeSector(fat2_sec + result >> 7, BUF_FAT)                              '  write FAT2 sector (MIRROR)
      if cluster <> 0                                                           '  if allocateCluster was called with a non-zero cluster parameter
        readSector(fat_sec + cluster >> 7, BUF_FAT)                             '   read FAT sector containing cluster cell
        buf_idx := (cluster << 2) & 511
        high_bits := long[@fat_buf + buf_idx] & $F000_0000                      '  preserve high 4 bits
        long[@fat_buf + buf_idx] := high_bits | (result & $0FFF_FFFF)           '  link to new cluster, preserve high bits
        writeSector(fat_sec + cluster >> 7, BUF_FAT)                            '  write FAT1 sector
        writeSector(fat2_sec + cluster >> 7, BUF_FAT)                           '  write FAT2 sector (MIRROR)
      if fsi_free_count <> $FFFF_FFFF                                          '  track free count incrementally
        fsi_free_count--                                                        '   (avoids slow FAT scan on unmount)
      return
    fat_idx += 4                                                                '  advance index to next cluster cell

PRI clearCluster(cluster)
' Initialize entire contents of cluster to 0 - used for new directories.
'
' @param cluster - Cluster number to clear

  n_sec := clus2sec(cluster)                                                    '  set n_sec to 1st sector of specified cluster
  bytefill(@dir_buf, 0, 512)                                                    '  clear directory buffer
  repeat sec_per_clus                                                           '  repeat for all sectors in the cluster
    writeSector(n_sec++, BUF_DIR)                                               '   overwrite sector
  dir_sec_in_buf := n_sec - 1

PRI readNextSector(buf_type) | cluster, address, contents, p_buf
' Load the next sector into buffer - follows FAT chain at cluster boundaries.
'
' @param buf_type - Buffer type: BUF_DIR, BUF_FAT, or BUF_DATA
' @local cluster - Current cluster number
' @local address - FAT entry address
' @local contents - FAT entry contents
' @local p_buf - Pointer to buffer (unused)

  n_sec++
  if ((n_sec - cluster_offset) & (sec_per_clus - 1)) == 0                       '  if next sector is in a different cluster
    cluster := sec2clus(n_sec-1)                                                '   find current cluster number
    readSector(cluster >> 7 + fat_sec, BUF_FAT)                                 '   read sector of FAT containing cluster number (128 cluster entries in each FAT sector)
    address := @fat_buf + ((cluster << 2) & 511)                                '   find long within FAT buffer for current cluster
    contents := long[address]                                                   '   read contents to determine next cluster number
    if contents >= $0FFF_FFF8                                                   '   end-of-chain marker detected
      ' Fill appropriate buffer with zeros based on buf_type
      case buf_type
        BUF_DIR:
          bytefill(@dir_buf, 0, 512)
        BUF_FAT:
          bytefill(@fat_buf, 0, 512)
        other:
          bytefill(@buf, 0, 512)
      return                                                                    '    don't read invalid sector
    n_sec := clus2sec(contents)                                                 '   convert next cluster number into sector number
  readSector(n_sec, buf_type)

PRI followFatChain() | cluster, address, contents
' Follow FAT chain to next cluster - for multi-sector reads.
' Called after multi-sector read lands exactly on cluster boundary.
' Updates n_sec to first sector of next cluster in the chain.
' n_sec is already pointing at the first sector of the NEW cluster boundary.
'
' @local cluster - Current cluster number
' @local address - FAT entry address
' @local contents - FAT entry contents (next cluster or end marker)

  cluster := sec2clus(n_sec - 1)                                                '  find cluster number of the sector we just finished reading
  readSector(cluster >> 7 + fat_sec, BUF_FAT)                                   '  read sector of FAT containing cluster number
  address := @fat_buf + ((cluster << 2) & 511)                                  '  find long within FAT buffer for current cluster
  contents := long[address]                                                     '  read contents to determine next cluster number
  if contents < $0FFF_FFF8                                                      '  if not end-of-chain marker
    n_sec := clus2sec(contents)                                                 '   convert next cluster number into sector number
  ' else: end-of-chain - n_sec stays invalid (caller should check file_idx against fileSize)

CON     '' helper methods
PRI byte2clus(byte_address) : result
' Convert byte address to cluster number.
'
' @param byte_address - Byte address to convert
' @returns result - Cluster number containing that byte

  return (sec2clus(byte_address >> 9))

PRI sec2clus(sector) : result
' Convert sector number to cluster number.
'
' @param sector - Sector number to convert
' @returns result - Cluster number containing that sector

  return (sector - root_sec) / sec_per_clus + 2

PRI clus2byte(cluster) : result
' Convert cluster number to byte address.
'
' @param cluster - Cluster number to convert
' @returns result - Byte address of first byte in that cluster

  return clus2sec(cluster) << 9

PRI clus2sec(cluster) : result
' Convert cluster number to sector number.
'
' @param cluster - Cluster number to convert
' @returns result - Sector number of first sector in that cluster

  return (cluster - 2) * sec_per_clus + root_sec

CON     '' low-level SPI routines

PRI initSPIPins()
' Configure smart pins for SPI operation - initialize Smart Pins for high-speed SPI communication.
' Pattern from working isp_tile_sensor.spin2:
' - DIRL -> WRPIN -> WXPIN -> DIRH (no WYPIN during config)
' - Smart pins stay enabled, WYPIN triggers transfers
'
' SCK uses P_PULSE for clock generation (X = period | low_time<<16)
' MOSI uses P_SYNC_TX for synchronized transmit (clocked by SCK)
' MISO uses P_SYNC_RX for synchronized receive (clocked by SCK)
' CS remains standard GPIO (manual control)

  ' Smart pin mode configuration using compiler constants
  ' P_TRANSITION: clock generation with X = half-period (transitions toggle output)
  ' P_SYNC_TX: synchronized serial transmit (clocked by B-input)
  ' P_SYNC_RX: synchronized serial receive (clocked by B-input)
  ' P_PLUS2_B, P_PLUS3_B: B-input pin selector for clock source
  ' Reference: ManAtWork SpiFlash.spin2 (OBEX 2872) - working smart pin SPI
  ' CRITICAL: Do NOT use P_INVERT_OUTPUT for SD card SPI mode 0!
  ' ManAtWork's flash uses different polarity. SD cards need clock idle LOW.
  spi_clk_mode := P_TRANSITION | P_OE                                           ' Transition mode, idle LOW for SPI mode 0
  spi_tx_mode := P_SYNC_TX | P_OE | P_PLUS2_B                                   ' Sync TX, clock from pin+2 (SCK)
  spi_rx_mode := P_SYNC_RX | P_PLUS3_B                                          ' Sync RX, clock from pin+3 (SCK)

  debug("    [initSPIPins] Setting up smart pins (ManAtWork pattern)...")
  debug("    [initSPIPins] Mode values:")
  debug("    [initSPIPins]   spi_clk_mode=$", uhex_long(spi_clk_mode), " (P_TRANSITION | P_OE, idle LOW)")
  debug("    [initSPIPins]   spi_tx_mode=$", uhex_long(spi_tx_mode), " (P_SYNC_TX | P_OE | P_PLUS2_B)")
  debug("    [initSPIPins]   spi_rx_mode=$", uhex_long(spi_rx_mode), " (P_SYNC_RX | P_PLUS3_B)")
  debug("    [initSPIPins]   SCK=P", udec_(sck), " MOSI=P", udec_(mosi), " MISO=P", udec_(miso))

  ' ════════════════════════════════════════════════════════════════════
  ' CS PIN: Standard GPIO (unchanged from bit-bang)
  ' CS is manually controlled - LOW = selected, HIGH = deselected
  ' ════════════════════════════════════════════════════════════════════
  pinh(cs)                                                                      ' Start deselected

  ' ════════════════════════════════════════════════════════════════════
  ' SCK PIN: P_TRANSITION mode for clock generation
  ' X register: half-period in clocks (time between transitions)
  ' Y register: Number of transitions (2 per bit) - loaded via WYPIN per transfer
  ' Configure with FLTL -> WRPIN, then WXPIN/DRVL in setSPISpeed()
  ' ════════════════════════════════════════════════════════════════════
  pinfloat(sck)                                                                 ' FLTL - reset smart pin
  wrpin(sck, spi_clk_mode)                                                      ' P_TRANSITION | P_OE | P_INVERT_OUTPUT
  ' X register (half-period) will be set by setSPISpeed()
  debug("    [initSPIPins]   SCK configured: P_TRANSITION | P_OE (awaiting setSPISpeed)")

  ' ════════════════════════════════════════════════════════════════════
  ' MOSI PIN: P_SYNC_TX mode for synchronized transmit
  ' B-input set via P_PLUS2_B (clock from SCK which is 2 pins higher)
  ' X register: %M_NNNNN where M=mode (1=start/stop), N=bits-1
  ' Y register: Data to transmit - loaded via WYPIN per transfer
  ' Configure with DIRL -> WRPIN -> WXPIN -> DIRH (no WYPIN yet)
  ' ════════════════════════════════════════════════════════════════════
  pinfloat(mosi)                                                                ' DIRL - reset smart pin
  wrpin(mosi, spi_tx_mode)                                                      ' P_SYNC_TX | P_OE | P_PLUS2_B
  wxpin(mosi, %1_00111)                                                         ' Start-stop mode, 8 bits default
  pinh(mosi)                                                                    ' DIRH - enable smart pin
  debug("    [initSPIPins]   MOSI configured: P_SYNC_TX | P_PLUS2_B (enabled)")

  ' ════════════════════════════════════════════════════════════════════
  ' MISO PIN: P_SYNC_RX mode for synchronized receive
  ' B-input set via P_PLUS3_B (clock from SCK which is 3 pins higher)
  ' X register: %M_NNNNN where M=mode (1=post-edge for SPI mode 0), N=bits-1
  ' Z register: Received data - read via RDPIN per transfer
  ' Configure with DIRL -> WRPIN -> WXPIN -> DIRH (no WYPIN needed)
  ' ════════════════════════════════════════════════════════════════════
  pinfloat(miso)                                                                ' DIRL - reset smart pin
  wrpin(miso, spi_rx_mode)                                                      ' P_SYNC_RX | P_PLUS3_B
  wxpin(miso, %1_00111)                                                         ' On-edge sample (SPI mode 0), 8 bits
  pinh(miso)                                                                    ' DIRH - enable smart pin
  debug("    [initSPIPins]   MISO configured: P_SYNC_RX | P_PLUS3_B (enabled)")

  ' Configure event SE1 for efficient waiting on SCK completion
  ' Event format: D[5:0]=pin, D[7:6]=%01 for positive edge on IN
  ' This allows waitse1 instead of polling testp loop
  spi_event := %01_000000 | sck
  configureEvent(spi_event)
  debug("    [initSPIPins]   Event SE1 configured for SCK pin ", udec_(sck))

  ' Mark smart pin mode as active
  use_smartpin := 1
  debug("    [initSPIPins] Smart pins configured and enabled")

PRI configureEvent(event_config) | ev
' Configure SE1 event for waitse1 - helper to configure SE1 event from a computed value.
' Event format: D[5:0]=pin, D[7:6]=%01 for positive edge on IN
'
' @param event_config - Event configuration value
' @local ev - Copy of event config for inline assembly

  ev := event_config
  org
        setse1  ev
  end

PUB setSPISpeed(freq) | half_period, actual_freq
'' Set SPI clock frequency - configure SPI clock speed for sysclk-independent operation.
'' Made public for speed characterization testing.
'' Using P_TRANSITION mode: X = half-period (time between transitions)
'' Reference: ManAtWork SpiFlash.spin2
''
'' Formula: half_period = clkfreq / (freq * 2)
'' For 400 kHz: half_period = 320M / 800k = 400 clocks
'' For 25 MHz: half_period = 320M / 50M = 6.4 -> minimum 4
''
'' @param freq - Target SPI frequency in Hz (e.g., 400_000 or 25_000_000)
'' @local half_period - Calculated half-period in system clocks
'' @local actual_freq - Actual achieved frequency

  ' Calculate half-period (time between transitions) in system clocks
  ' Use ceiling division to ensure we never exceed target frequency
  ' Formula: ceil(a/b) = (a + b - 1) / b
  half_period := (clkfreq + (freq * 2) - 1) / (freq * 2)

  ' Guard against too-small period (ManAtWork uses minimum of 4)
  if half_period < 4
    half_period := 4
    debug("    [setSPISpeed] WARNING: Half-period clamped to minimum (4)")

  ' Calculate actual achieved frequency for debugging
  actual_freq := clkfreq / (half_period * 2)

  ' Store in DAT variables for debugging/monitoring
  spi_period := half_period
  spi_freq := actual_freq

  ' Configure SCK smart pin X register and enable with DRVL
  wxpin(sck, half_period)                                                       ' Set transition period
  pinl(sck)                                                                     ' DRVL enables smart pin (ManAtWork pattern)

  debug("    [setSPISpeed] Target=", udec_(freq/1000), " kHz, Actual=", udec_(actual_freq/1000), " kHz")
  debug("    [setSPISpeed] Half-period=", udec_(half_period), " clocks")

PRI calcDataCRC(pData, len) : crc | raw
' Calculate CRC-16-CCITT for SD card data - hardware-accelerated using P2's GETCRC instruction.
' Eliminates 512-byte lookup table with equivalent results.
'
' Algorithm:
'   1. GETCRC with reflected polynomial $8408 on raw data
'   2. XOR with precomputed base value (compensates for GETCRC quirks)
'   3. REV 31 reverses all 32 bits (LSB-first to MSB-first)
'   4. >> 16 extracts 16-bit CRC from upper half
'
' Note: This formula was validated against lookup table with 100% match
'       across 10 test patterns. See TestCard/SD_CRC_solution_test.spin2
'
' @param pData - Pointer to data buffer
' @param len - Number of bytes to process (must be 512 for sector data)
' @returns crc - 16-bit CRC-16-CCITT value matching SD card's calculation
' @local raw - Raw GETCRC result before transformation
  raw := GETCRC(pData, CRC_POLY_REFLECTED, len)
  crc := ((raw ^ CRC_BASE_512) REV 31) >> 16

PRI sp_transfer(data, bits) : result
' Smart pin SPI transfer (variable bits) - dispatches to 8-bit or 32-bit transfer.
' For now, only support 8-bit and 32-bit transfers.
'
' @param data - Data to transmit
' @param bits - Number of bits to transfer (8 or 32)
' @returns result - Received data

  if bits == 8
    result := sp_transfer_8(data)
  elseif bits == 32
    result := sp_transfer_32(data)
  else
    ' Fallback to bit-bang for unsupported sizes
    result := transfer(data, bits)

PRI sp_transfer_8(data) : result | _sck, _mosi, _miso, tx_data, raw_result
' 8-bit smart pin SPI transfer - full-duplex 8-bit SPI transfer using smart pins.
' Reference: ManAtWork SpiFlash.spin2 (OBEX 2872)
' TX: shl #24, rev, wypin data, 16 transitions
' RX: wait on MISO IN flag, rdpin, rev, zerox #7
'
' @param data - Byte to transmit
' @returns result - Byte received
' @local _sck - Local copy of SCK pin number
' @local _mosi - Local copy of MOSI pin number
' @local _miso - Local copy of MISO pin number
' @local tx_data - Prepared transmit data
' @local raw_result - Raw rdpin result before processing

  _sck := sck
  _mosi := mosi
  _miso := miso
  tx_data := data
  org
        ' Prepare TX data: shift to MSB position and reverse for LSB-first transmission
        shl     tx_data, #24                    ' Move byte to bits [31:24]
        rev     tx_data                         ' Reverse for MSB-first SPI

        ' Configure MOSI for 8-bit start-stop mode and load data
        wxpin   #$27, _mosi                     ' 8 bits, start-stop mode (%1_00111)
        wypin   tx_data, _mosi
        drvl    _mosi                           ' Enable TX smart pin

        ' Configure MISO for 8-bit receive
        ' Note: wrpin already set from initSPIPins - don't use dirl which clears it!
        wxpin   #$27, _miso                     ' 8 bits, start-stop mode
        akpin   _miso                           ' Clear any pending IN flag
        dirh    _miso                           ' Enable smart pin

        ' Start clock: 16 transitions = 8 clock cycles
        wypin   #16, _sck
        nop

        ' Wait for MISO receive complete (not clock!)
.waitRx testp   _miso                   wz      ' IN=1 when receive complete
  if_nz jmp     #.waitRx

        ' Read received data - keep raw value for debug
        rdpin   raw_result, _miso
        mov     result, raw_result
        rev     result                          ' Reverse for MSB-first
        zerox   result, #7                      ' Limit to 8 bits
  end
  ' Debug: show raw rdpin value and pin info occasionally
  if sp_debug_ctr < 5
    debug("    [sp_transfer_8] pins: miso=", udec_(_miso), " sck=", udec_(_sck), " raw=", uhex_long_(raw_result), " final=", uhex_byte_(result))
    sp_debug_ctr++

PRI sp_transfer_32(data) : result | _sck, _mosi, _miso, tx_data
' 32-bit smart pin SPI transfer - full-duplex 32-bit SPI transfer using smart pins.
'
' @param data - 32-bit data to transmit
' @returns result - 32-bit data received
' @local _sck - Local copy of SCK pin number
' @local _mosi - Local copy of MOSI pin number
' @local _miso - Local copy of MISO pin number
' @local tx_data - Prepared transmit data

  _sck := sck
  _mosi := mosi
  _miso := miso
  tx_data := data
  org
        ' Prepare TX data: reverse for LSB-first transmission
        rev     tx_data                         ' Reverse for MSB-first SPI

        ' Configure MOSI for 32-bit start-stop mode and load data
        wxpin   #$3F, _mosi                     ' 32 bits, start-stop mode (%1_11111)
        wypin   tx_data, _mosi
        drvl    _mosi                           ' Enable TX smart pin

        ' Configure MISO for 32-bit receive
        wxpin   #$3F, _miso                     ' 32 bits, start-stop mode
        drvl    _miso                           ' Enable RX smart pin

        ' Start clock: 64 transitions = 32 clock cycles
        wypin   #64, _sck
        nop

        ' Wait for MISO receive complete
.waitRx testp   _miso                   wz      ' IN=1 when receive complete
  if_nz jmp     #.waitRx

        ' Read received data
        rdpin   result, _miso
        rev     result                          ' Reverse for MSB-first
  end

PRI initCard() : result | t, resp, card_version, acmd41_arg
' Initialize SD card - performs complete card initialization sequence per SD spec.
' Steps: power-on delay, SPI setup, CMD0, CMD8, ACMD41 loop, CMD58.
'
' @returns result - TRUE on successful init, FALSE on failure
' @local t - Timeout counter
' @local resp - Command response byte
' @local card_version - Detected SD version (1 or 2)
' @local acmd41_arg - Argument for ACMD41 (HCS flag)

  debug("    [initCard] Starting card init...")
  debug("    [initCard] Reference: SPI_SD_Implementation_Reference.md")
  sec_in_buf := -1

  ' ============================================
  ' STEP 1: Power-on delay
  ' Spec: VDD must be stable, then wait 1ms minimum
  ' ============================================
  debug("    [initCard] Step 1: Power-on delay (100ms)...")
  waitms(100)

  ' ============================================
  ' STEP 2: Configure SPI pins and slow clock
  ' Spec: Use 100-400 kHz during initialization
  ' ============================================
  bit_delay := clkfreq / 100_000                                                '  ~50kHz for init (conservative)
  debug("    [initCard] Step 2: SPI config, bit_delay=", udec(bit_delay), " (~50kHz)")

  ' SD card SPI mode 0: CPOL=0, CPHA=0
  ' Data sampled on rising edge, changed on falling edge
  pinh(cs)                                                                      '  CS HIGH = deselected
  pinh(mosi)                                                                    '  MOSI HIGH (card expects high during idle)
  pinl(sck)                                                                     '  SCK LOW (SPI mode 0 idle state)
  pinf(miso)                                                                    '  MISO as floating input

  debug("    [initCard] Pins: CS=", udec_(pinr(cs)), " MOSI=", udec_(pinr(mosi)), " MISO=", udec_(pinr(miso)), " SCK=", udec_(pinr(sck)))

  ' ============================================
  ' STEP 3: Card recovery + init clocks
  ' If card is stuck mid-transfer, flush with extra clocks
  ' Then send 74+ clocks per spec for power-on init
  ' ============================================
  debug("    [initCard] Step 3: Recovery flush (4096 clocks to clear stuck transfer)...")
  repeat 4096                                                                     '  Enough to flush a full 512-byte sector
    pinh(sck)
    waitus(10)
    pinl(sck)
    waitus(10)

  debug("    [initCard] MISO after recovery flush: ", udec_(pinr(miso)), " (should be 1)")

  ' ============================================
  ' STEP 3.5: Initialize smart pins for SPI
  ' ============================================
  debug("    [initCard] Step 3.5: Initializing smart pins (ManAtWork pattern)...")
  initSPIPins()
  setSPISpeed(400_000)                                                          ' 400 kHz for init
  waitus(100)                                                                   ' Let smart pins settle

  ' Send dummy clocks using smart pins
  repeat 10
    sp_transfer_8($FF)
  debug("    [initCard] Dummy clocks sent via smart pins")

  ' ============================================
  ' STEP 4: CMD0 - GO_IDLE_STATE
  ' Sends: 0x40 0x00 0x00 0x00 0x00 0x95
  ' Expected R1: 0x01 (in idle state)
  ' ============================================
  debug("    [initCard] Step 4: CMD0 (GO_IDLE_STATE)...")
  resp := 0
  repeat 5                                                                      '  try up to 5 times
    resp := cmd(0, 0)
    debug("    [initCard] CMD0 response: $", uhex_(resp))
    if resp == $01
      quit
    waitms(10)

  if resp <> $01
    debug("    [initCard] FAIL: CMD0 expected $01, got $", uhex_(resp))
    if resp == $FF
      debug("    [initCard] ($FF = no response, check wiring)")
    return false

  debug("    [initCard] CMD0 OK - card in idle state")

  ' ============================================
  ' STEP 5: CMD8 - SEND_IF_COND
  ' Sends: 0x48 0x00 0x00 0x01 0xAA 0x87
  ' Argument: VHS=0x01 (2.7-3.6V), check_pattern=0xAA
  ' Expected R7: R1 + 4 bytes echoing VHS and pattern
  ' ============================================
  debug("    [initCard] Step 5: CMD8 (SEND_IF_COND, VHS=1, pattern=$AA)...")
  resp := cmd(8, $000001AA)                                                     '  send CMD8, get 32-bit echo
  debug("    [initCard] CMD8 response (32-bit): $", uhex_long(resp))

  card_version := 1                                                             '  assume v1.x until proven otherwise
  acmd41_arg := $00000000                                                       '  HCS=0 for v1.x cards

  if resp == 0                                                                  '  timeout or no response
    debug("    [initCard] CMD8 no response -> Ver 1.x SD card (SDSC only)")
    card_version := 1
    acmd41_arg := $00000000                                                     '  no HCS for v1.x
  elseif (resp & $FFF) == $1AA                                                  '  check VHS and pattern echo
    debug("    [initCard] CMD8 echo valid ($1AA) -> Ver 2.0+ SD card")
    card_version := 2
    acmd41_arg := $40000000                                                     '  HCS=1 for v2.0+ (support SDHC/SDXC)
  else
    debug("    [initCard] CMD8 echo unexpected: $", uhex_long(resp & $FFF), " expected $1AA")
    debug("    [initCard] Treating as Ver 1.x card")
    card_version := 1
    acmd41_arg := $00000000

  ' ============================================
  ' STEP 6: ACMD41 - SD_SEND_OP_COND (loop until ready)
  ' Requires CMD55 prefix before each ACMD41
  ' CMD55: 0x77 0x00 0x00 0x00 0x00 0x65
  ' ACMD41: 0x69 [arg] CRC
  ' Expected R1: 0x00 when ready, 0x01 while initializing
  ' ============================================
  debug("    [initCard] Step 6: ACMD41 init loop (arg=$", uhex_long(acmd41_arg), ")...")
  t := getct() + clkfreq * 2                                                    '  2 second timeout

  repeat
    resp := cmd(55, 0)                                                          '  APP_CMD prefix
    if resp > $01                                                               '  error other than "in idle"
      debug("    [initCard] CMD55 error: $", uhex_(resp))
      waitms(10)
    else
      resp := cmd(41, acmd41_arg)                                               '  SD_SEND_OP_COND
      if resp == $00                                                            '  card ready (not in idle anymore)
        debug("    [initCard] ACMD41 complete - card ready!")
        quit
      elseif resp == $01                                                        '  still initializing
        ' continue looping
      else
        debug("    [initCard] ACMD41 unexpected response: $", uhex_(resp))

    if getct() - t > 0
      debug("    [initCard] FAIL: ACMD41 timeout after 2 seconds")
      debug("    [initCard] Last response: $", uhex_(resp))
      return false
    waitms(10)

  ' ============================================
  ' STEP 7: CMD58 - READ_OCR
  ' Sends: 0x7A 0x00 0x00 0x00 0x00 0xFD
  ' Expected R3: R1 + 32-bit OCR register
  ' Check bit 31 (busy), bit 30 (CCS)
  ' ============================================
  debug("    [initCard] Step 7: CMD58 (READ_OCR)...")
  resp := cmd(58, 0)
  ocr_value := resp                                                             '  Cache OCR for later retrieval
  debug("    [initCard] OCR: $", uhex_long(resp))
  debug("    [initCard]   Bit 31 (ready): ", udec((resp >> 31) & 1))
  debug("    [initCard]   Bit 30 (CCS):   ", udec((resp >> 30) & 1))

  if (resp >> 30) & 1
    hcs := 0                                                                    '  SDHC/SDXC: block addressing (no shift)
    debug("    [initCard] Card type: SDHC/SDXC (block addressing)")
  else
    hcs := 9                                                                    '  SDSC: byte addressing (shift by 9 = multiply by 512)
    debug("    [initCard] Card type: SDSC (byte addressing)")

  ' ============================================
  ' STEP 8: Identify card and set optimal SPI speed
  ' Reads CID for manufacturer ID, CSD for TRAN_SPEED
  ' PNY cards ($1D) limited to 20 MHz due to timing sensitivity
  ' ============================================
  pinh(cs)                                                                      '  ensure CS HIGH before CID/CSD read
  debug("    [initCard] Step 8: Card identification and speed selection...")
  identifyCard()                                                                '  read CID/CSD, identify manufacturer
  setOptimalSpeed()                                                             '  set speed based on card type
  ' Send dummy clocks with CS HIGH to stabilize new clock rate
  repeat 8
    sp_transfer(-1, 8)                                                          '  8 dummy bytes = 64 clocks (using smart pins)
  debug("    [initCard] Dummy clocks sent, CS HIGH")
  debug("    [initCard] === INIT SUCCESS ===")
  return true


PRI cmd(op,parm) : result | t
' Send a SPI command using smart pins - sends command byte, argument, and CRC.
' Handles R1, R3, and R7 response formats based on command type.
'
' @param op - Command number (0-63)
' @param parm - 32-bit command argument
' @returns result - R1 response, or R3/R7 32-bit value for CMD8/CMD58
' @local t - Timeout counter

  if op == 0
    debug("      [cmd] CS before assert: ", udec_(pinr(cs)))
  sp_transfer(-1,8)                                                             '  required for certain cards (my 512MB card fails if not present)
  pinl(cs)                                                                      '  CS LOW = selected (standard active-LOW)
  if op == 0
    debug("      [cmd] CS after pinl: ", udec_(pinr(cs)), " MISO=", udec_(pinr(miso)))
  sp_transfer(-1,8)                                                             '  required for certain cards (my 512MB and 32GB cards fail if not present)
  sp_transfer($40 | op,8)
  sp_transfer(parm,32)
  if op == 0
    sp_transfer($95,8)                                                          '  send CRC for cmd(0,0)
    debug("      [cmd] After CMD0 sent, MISO=", udec_(pinr(miso)))
  else
    sp_transfer($87,8)                                                          '  send CRC for cmd(8,$1AA)
  t := getct() + clkfreq
  repeat
    result := sp_transfer(-1,8)                                                 '  read 1st byte of reply
    if result <> $FF
      quit
    if getct() - t > 0                                                          '  check timeout
      pinh(cs)                                                                  '  CS HIGH = deselected (standard active-LOW)
      return false
  if op == 8 or op == 58                                                        '  read 32-bit reply for cmd8 and cmd58
    result := sp_transfer(-1,32)                                                '  (memory card interface condition and operation conditions register
  if op <> 17 and op <> 24 and op <> CMD18 and op <> CMD25 and op <> 55         '  keep cs asserted for sector read/write and application commands
    pinh(cs)                                                                    '  CS HIGH = deselected (standard active-LOW)

PRI readSector(sector, buf_type) : result | _sck, _miso, data, loop_ctr, timeout, stream_mode, clk_count, xfrq, init_phase, p_buf, align_delay, p_cache
' Read a sector into buffer using P2 streamer - hardware DMA for bulk 512-byte transfer.
' Reference: flash_loader.spin2 pattern for SPI reads
'
' Protocol:
' 1. CMD17 (READ_SINGLE_BLOCK) with sector address
' 2. Wait for $FE start token (polled via sp_transfer_8)
' 3. Receive 512 bytes via streamer (MISO -> hub)
' 4. Receive 2 CRC bytes, validate against calculated CRC
' 5. Deselect card
'
' @param sector - Sector number to read
' @param buf_type - Buffer type: BUF_DIR, BUF_FAT, or BUF_DATA
' @returns result - 0 on success, -1 on timeout/error
' @local _sck - Local copy of SCK pin
' @local _miso - Local copy of MISO pin
' @local data - Received data/token
' @local loop_ctr - Token polling counter
' @local timeout - Timeout deadline
' @local stream_mode - Streamer mode word
' @local clk_count - Number of clock transitions
' @local xfrq - Streamer NCO frequency
' @local init_phase - Streamer initial phase
' @local p_buf - Pointer to destination buffer
' @local align_delay - Alignment delay before streamer
' @local p_cache - Pointer to cache variable

  ' Select buffer and cache based on type
  case buf_type
    BUF_DIR:
      p_buf := @dir_buf
      p_cache := @dir_sec_in_buf
    BUF_FAT:
      p_buf := @fat_buf
      p_cache := @fat_sec_in_buf
    other:  ' BUF_DATA or default
      p_buf := @buf
      p_cache := @sec_in_buf

  if sector == long[p_cache]
    'if buf_type == BUF_DIR
    '  debug("  [readSector] CACHE HIT sector ", udec_(sector), " bytes: $", uhex_byte_(byte[p_buf]), " $", uhex_byte_(byte[p_buf+1]), " $", uhex_byte_(byte[p_buf+2]))
    return 0
  'debug("  [readSector] Reading sector ", udec_(sector), " type=", udec_(buf_type), " p_buf=", uhex_(p_buf))
  long[p_cache] := sector

  ' Send CMD17 (READ_SINGLE_BLOCK)
  cmd(17, sector << hcs)

  ' Wait for start token ($FE) - use sp_transfer_8 for token polling
  timeout := getct() + (clkfreq / 100) * card_read_timeout_ms                   ' CSD-based timeout with 10x margin
  loop_ctr := 0
  repeat
    data := sp_transfer_8($FF)
    loop_ctr++
    if data == $FE
      quit                                                                      ' Got start token
    if data <> $FF
      debug("  [readSector] ERROR: got $", uhex_byte_(data), " instead of $FF or $FE")
      pinh(cs)
      long[p_cache] := -1
      return -1
    if getct() - timeout > 0
      debug("  [readSector] TIMEOUT waiting for start token")
      pinh(cs)
      long[p_cache] := -1
      return -1

  ' ════════════════════════════════════════════════════════════════════════════
  ' STREAMER BULK TRANSFER: Receive 512 bytes from MISO to hub buffer
  ' Pattern: SETXFRQ -> WRFAST -> WYPIN(clk) -> WAITX -> XINIT -> WAITXFI
  ' CRITICAL: Must disable MISO smart pin before streamer capture!
  ' ════════════════════════════════════════════════════════════════════════════
  _sck := sck
  _miso := miso
  ' p_buf already set above based on buf_type

  ' CRITICAL FIX: Disable MISO smart pin before streamer capture
  ' The smart pin interferes with streamer's direct pin reading
  ' Reference: flash_loader.spin2 does NOT configure smart pin on MISO during reads
  ' Verified fix: 2026-01-23 in SD_streamer_lut_test.spin2
  pinclear(_miso)                                                               ' Clear smart pin mode
  pinf(_miso)                                                                   ' Float pin (input mode)
  ' Mode word format: base_mode | (pin << 17) | bit_count
  ' For 512 bytes: 512 * 8 = 4096 bits = $1000
  stream_mode := STREAM_RX_BASE | (_miso << 17) | (512 * 8)                     ' RX mode + MISO pin + bit count
  clk_count := 512 * 8 * 2                                                      ' 8192 clock transitions

  ' Calculate streamer NCO frequency to match SPI clock
  ' NCO adds xfrq to phase accumulator each sysclock; sample occurs on MSB 0->1 transition
  ' Full SPI bit period = 2 * spi_period sysclocks
  ' xfrq = $8000_0000 / (full_period) = $8000_0000 / (2 * spi_period) = $4000_0000 / spi_period
  ' BUG FIX: Previous code had << 1 which DOUBLED the rate, sampling twice per bit!
  xfrq := $4000_0000 / spi_period                                               ' One sample per full clock period

  ' Phase alignment: sample in middle of each bit for stability
  ' After wypin starts clock: first rising edge at T=spi_period
  ' With waitx spi_period, xinit happens at T=spi_period (first rising edge)
  ' init_phase=$4000_0000 causes first sample ~spi_period later (middle of bit 0)
  init_phase := $4000_0000                                                      ' Sample mid-bit for stability
  align_delay := spi_period                                                     ' Wait one half-period before streamer

  ' DIAGNOSTIC: Capture buffer state BEFORE streamer
  diag_before_b0 := byte[p_buf]
  diag_before_b1 := byte[p_buf+1]
  diag_before_b2 := byte[p_buf+2]
  diag_before_b3 := byte[p_buf+3]
  diag_spi_period := spi_period

  ' ════════════════════════════════════════════════════════════════════════════
  ' STREAMER BULK TRANSFER: 512 bytes from MISO to hub via DMA
  ' ════════════════════════════════════════════════════════════════════════════
  org
        setxfrq xfrq                              ' Set streamer NCO rate
        wrfast  #0, p_buf                         ' Setup WRFAST to hub buffer
        wypin   clk_count, _sck                   ' Start clock transitions
        waitx   align_delay                       ' Wait one half-period to align with first rising edge
        xinit   stream_mode, init_phase           ' Start streamer with phase offset
        waitxfi                                   ' Wait for streamer to complete
  end

  ' DIAGNOSTIC: Capture data for test cog to read
  diag_last_sector := sector
  diag_last_buftype := buf_type
  diag_last_token := data                                                       ' Start token ($FE if success)
  diag_p_buf := p_buf
  diag_buf_byte0 := byte[p_buf]
  diag_buf_byte1 := byte[p_buf+1]
  diag_buf_byte2 := byte[p_buf+2]
  diag_buf_byte3 := byte[p_buf+3]

  ' Re-enable MISO smart pin for CRC reads (sp_transfer_8 needs it)
  wrpin(_miso, spi_rx_mode)                                                     ' P_SYNC_RX | P_PLUS3_B
  wxpin(_miso, %1_00111)                                                        ' On-edge sample, 8 bits
  pinh(_miso)                                                                   ' DIRH - enable smart pin

  ' Read and capture 2 CRC bytes (high byte first per SD protocol)
  diag_recv_crc := sp_transfer_8($FF) << 8
  diag_recv_crc |= sp_transfer_8($FF)

  ' CRC-16 validation: calculate CRC of received data and compare with card's CRC
  if diag_crc_enabled
    diag_calc_crc := calcDataCRC(p_buf, 512)
    if diag_calc_crc == diag_recv_crc
      diag_crc_matches++
    else
      diag_crc_mismatches++
      debug("  [readSector] CRC MISMATCH! recv=$", uhex_(diag_recv_crc), " calc=$", uhex_(diag_calc_crc))

  pinh(cs)                                                                      ' Deselect card

  ' CMD13: Verify card is in good state after read
  if checkCardStatus(@"readSector") < 0
    long[p_cache] := -1                                                         ' Invalidate cache on error
    return -1

  result := 0

PRI readSectorSlow(sector, p_buffer) : result | data, i, timeout
' DEBUG: Read sector byte-by-byte (no streamer) - for streamer debugging.
' This is SLOW (~50x slower than streamer) but helps isolate timing issues.
'
' @param sector - Sector number to read
' @param p_buffer - Pointer to 512-byte destination buffer
' @returns result - 0 on success, -1 on timeout/error
' @local data - Received byte/token
' @local i - Loop counter
' @local timeout - Timeout deadline

  ' Send CMD17 (READ_SINGLE_BLOCK)
  cmd(17, sector << hcs)

  ' Wait for start token ($FE)
  timeout := getct() + (clkfreq / 100) * card_read_timeout_ms
  repeat
    data := sp_transfer_8($FF)
    if data == $FE
      quit                                                                      ' Got start token
    if data <> $FF
      pinh(cs)
      return -1                                                                 ' Error token
    if getct() - timeout > 0
      pinh(cs)
      return -1                                                                 ' Timeout

  ' Read 512 bytes one at a time using sp_transfer_8
  repeat i from 0 to 511
    byte[p_buffer + i] := sp_transfer_8($FF)

  ' Read and capture 2 CRC bytes (high byte first per SD protocol)
  diag_recv_crc := sp_transfer_8($FF) << 8
  diag_recv_crc |= sp_transfer_8($FF)

  ' CRC-16 validation: calculate CRC of received data and compare with card's CRC
  if diag_crc_enabled
    diag_calc_crc := calcDataCRC(p_buffer, 512)
    if diag_calc_crc == diag_recv_crc
      diag_crc_matches++
    else
      diag_crc_mismatches++
      debug("  [readSectorSlow] CRC MISMATCH! recv=$", uhex_(diag_recv_crc), " calc=$", uhex_(diag_calc_crc))

  pinh(cs)                                                                      ' Deselect card
  return 0                                                                      ' Success

PRI readSectors(start_sector, count, p_buffer) : sectors_read | _sck, _miso, p_buf, stream_mode, clk_count, xfrq, init_phase, align_delay, i, resp
' Read multiple consecutive sectors using CMD18 (READ_MULTIPLE_BLOCK).
' More efficient than individual readSector() calls because:
' - Only one CMD18 command instead of N CMD17 commands
' - No inter-sector gaps from CS deassert/reassert
' - Card can pre-fetch ahead for sequential access
'
' Protocol: CMD18 -> (wait $FE -> read 512 bytes -> CRC) x N -> CMD12
'
' @param start_sector - First sector to read
' @param count - Number of sectors to read (0 returns immediately)
' @param p_buffer - Pointer to buffer (must be at least count * 512 bytes)
' @returns sectors_read - Number of sectors successfully read (0 on error)
' @local _sck - Local copy of SCK pin
' @local _miso - Local copy of MISO pin
' @local p_buf - Current buffer position
' @local stream_mode - Streamer mode word
' @local clk_count - Number of clock transitions
' @local xfrq - Streamer NCO frequency
' @local init_phase - Streamer initial phase
' @local align_delay - Alignment delay before streamer
' @local i - Loop counter (unused)
' @local resp - Command response

  if count == 0
    return 0

  ' Setup variables for streamer
  _sck := sck
  _miso := miso
  stream_mode := STREAM_RX_BASE | (_miso << 17) | (512 * 8)                     ' RX mode + MISO pin + 4096 bits
  clk_count := 512 * 8 * 2                                                      ' 8192 clock transitions
  xfrq := $4000_0000 / spi_period                                               ' One sample per full clock period
  init_phase := $4000_0000                                                      ' Sample mid-bit for stability
  align_delay := spi_period                                                     ' Wait one half-period before streamer

  ' Send CMD18 (READ_MULTIPLE_BLOCK) with starting sector
  ' Note: cmd() handles CS assertion and returns R1 response
  resp := cmd(CMD18, start_sector << hcs)
  if resp <> $00
    debug("  [readSectors] CMD18 failed, R1=$", uhex_byte_(resp))
    pinh(cs)
    return 0

  ' Read each sector
  sectors_read := 0
  repeat count
    p_buf := p_buffer + (sectors_read * 512)                                    ' Calculate buffer position

    ' Wait for data token ($FE) for this sector
    if waitDataToken() < 0
      debug("  [readSectors] No data token for sector ", udec_(start_sector + sectors_read))
      quit                                                                      ' Exit loop on error

    ' Disable MISO smart pin before streamer capture
    pinclear(_miso)
    pinf(_miso)

    ' Streamer bulk transfer: 512 bytes from MISO to hub
    org
          setxfrq xfrq
          wrfast  #0, p_buf
          wypin   clk_count, _sck
          waitx   align_delay
          xinit   stream_mode, init_phase
          waitxfi
    end

    ' Re-enable MISO smart pin for CRC reads
    wrpin(_miso, spi_rx_mode)
    wxpin(_miso, %1_00111)
    pinh(_miso)

    ' Read and capture 2 CRC bytes, validate against calculated CRC
    diag_recv_crc := sp_transfer_8($FF) << 8
    diag_recv_crc |= sp_transfer_8($FF)

    if diag_crc_enabled
      diag_calc_crc := calcDataCRC(p_buf, 512)
      if diag_calc_crc == diag_recv_crc
        diag_crc_matches++
      else
        diag_crc_mismatches++
        debug("  [readSectors] CRC MISMATCH sec ", udec_(start_sector + sectors_read), " recv=$", uhex_(diag_recv_crc), " calc=$", uhex_(diag_calc_crc))

    sectors_read++

  ' Send CMD12 to stop transmission
  if sendStopTransmission() < 0
    debug("  [readSectors] CMD12 failed")
    ' Still return sectors_read - we got the data even if stop failed

  pinh(cs)                                                                      ' Deselect card

  ' CMD13: Verify card is in good state after multi-block read
  if checkCardStatus(@"readSectors") < 0
    debug("  [readSectors] CMD13 status check FAILED")
    ' Still return sectors_read - data may be valid

PRI writeSector(sector, buf_type) : result | _sck, _mosi, p_buf, stream_mode, clk_count, xfrq, t, resp, p_cache
' Write buffer into a sector using P2 streamer - hardware DMA for bulk 512-byte transfer.
' Reference: flash_loader.spin2 pattern for SPI writes
'
' PNY COMPATIBILITY: This implementation follows strict SPI write protocol:
' 1. CMD24 with sector address
' 2. Data start token ($FE)
' 3. 512 bytes of data via streamer (hub -> MOSI)
' 4. 2 CRC bytes (calculated CRC-16-CCITT, high byte first)
' 5. Wait for data-response token ($x5 = accepted)
' 6. Wait for MISO to go HIGH ($FF = programming complete)
' CRITICAL: CS must stay LOW and clocking must continue during entire busy period!
'
' @param sector - Sector number to write
' @param buf_type - Buffer type: BUF_DIR, BUF_FAT, or BUF_DATA
' @returns result - TRUE on success, FALSE on failure
' @local _sck - Local copy of SCK pin
' @local _mosi - Local copy of MOSI pin
' @local p_buf - Pointer to source buffer
' @local stream_mode - Streamer mode word
' @local clk_count - Number of clock transitions
' @local xfrq - Streamer NCO frequency
' @local t - Timeout counter
' @local resp - Response byte
' @local p_cache - Pointer to cache variable

  ' Select buffer and cache based on type
  case buf_type
    BUF_DIR:
      p_buf := @dir_buf
      p_cache := @dir_sec_in_buf
    BUF_FAT:
      p_buf := @fat_buf
      p_cache := @fat_sec_in_buf
    other:  ' BUF_DATA or default
      p_buf := @buf
      p_cache := @sec_in_buf

  _sck := sck
  _mosi := mosi
  ' p_buf already set above based on buf_type

  ' Invalidate cache for this buffer type after write
  long[p_cache] := -1

  cmd(24, sector << hcs)
  sp_transfer_8($FE)                                                            ' Data start token

  ' ════════════════════════════════════════════════════════════════════════════
  ' STREAMER BULK TRANSFER: Send 512 bytes from hub buffer to MOSI
  ' Pattern: SETXFRQ -> RDFAST -> XINIT -> WYPIN(clk) -> WAITXFI
  ' ════════════════════════════════════════════════════════════════════════════
  ' Mode word format: base_mode | (pin << 17) | bit_count
  ' For 512 bytes: 512 * 8 = 4096 bits = $1000
  stream_mode := STREAM_TX_BASE | (_mosi << 17) | (512 * 8)                     ' TX mode + MOSI pin + bit count
  clk_count := 512 * 8 * 2                                                      ' 8192 clock transitions

  ' Calculate streamer NCO frequency to match SPI clock
  ' Same formula as readSector: one bit per full clock period
  xfrq := $4000_0000 / spi_period                                               ' One output per full clock period

  ' CRITICAL FIX: Disable MOSI smart pin before streamer TX
  ' The smart pin configuration interferes with streamer's direct pin driving
  ' Same pattern as MISO disable in readSector()
  pinclear(_mosi)                                                               ' Clear smart pin mode
  pinl(_mosi)                                                                   ' Drive pin low (output mode)

  ' For TX: xinit BEFORE wypin (data leads clock) - per flash_loader pattern
  ' This ensures data is stable before rising edge when slave samples
  org
        setxfrq xfrq                              ' Set streamer bit rate
        rdfast  #0, p_buf                         ' Setup RDFAST from hub buffer
        xinit   stream_mode, #0                   ' Start streamer output first
        wypin   clk_count, _sck                   ' Then start clock transitions
        waitxfi                                   ' Wait for streamer to complete
  end

  ' Re-enable MOSI smart pin for CRC and response byte transfers (sp_transfer_8 needs it)
  wrpin(_mosi, spi_tx_mode)                                                     ' P_SYNC_TX | P_OE | P_PLUS2_B
  wxpin(_mosi, %1_00111)                                                        ' Start-stop mode, 8 bits
  pinh(_mosi)                                                                   ' DIRH - enable smart pin

  ' Calculate CRC-16 of the data we just sent and transmit it
  ' SD protocol: CRC high byte first, then low byte
  diag_sent_crc := calcDataCRC(p_buf, 512)
  sp_transfer_8(diag_sent_crc >> 8)                                             ' CRC high byte
  sp_transfer_8(diag_sent_crc & $FF)                                            ' CRC low byte

  ' Wait for data-response token (should be immediate, within a few bytes)
  t := getct() + clkfreq / 10                                                   ' 100ms timeout for response
  repeat
    resp := sp_transfer_8($FF)
    if resp <> $FF
      quit
    if getct() - t > 0
      debug("  [writeSector] TIMEOUT waiting for data-response")
      pinh(cs)
      return false

  ' Verify data-response token: bits [4:0] should be xxx00101 = $05 (data accepted)
  if (resp & $1F) <> $05
    debug("  [writeSector] Data rejected: response=$", uhex_(resp))
    pinh(cs)
    return false

  ' Wait for card to finish programming (busy period)
  ' Card holds MISO LOW during internal flash write, releases to HIGH ($FF) when done
  ' CRITICAL for PNY: Keep CS LOW and keep clocking until we see stable $FF!
  t := getct() + (clkfreq / 1000) * card_write_timeout_ms                       ' CSD-based timeout
  repeat
    resp := sp_transfer_8($FF)                                                  ' Clock 8 bits while reading MISO
    if resp == $FF                                                              ' Card released MISO = programming complete
      quit
    if getct() - t > 0
      debug("  [writeSector] TIMEOUT waiting for programming complete")
      pinh(cs)
      return false

  pinh(cs)

  ' CMD13: Verify card status after write
  if checkCardStatus(@"writeSector") < 0
    return false

  return true

PRI writeSectors(start_sector, count, p_buffer) : sectors_written | _sck, _mosi, p_buf, stream_mode, clk_count, xfrq, settle_delay, resp
' Write multiple consecutive sectors using CMD25 (WRITE_MULTIPLE_BLOCK).
' More efficient than individual writeSector() calls because:
' - Only one CMD25 command instead of N CMD24 commands
' - Card can optimize internal flash writes for sequential access
' - Reduced overhead from CS cycling and command processing
'
' CRITICAL: Multi-block write uses different tokens than single-block!
' - Each data block uses $FC (not $FE) as start token
' - Transmission ends with $FD stop token (not CMD12!)
'
' Protocol: CMD25 -> ($FC + 512 bytes + CRC + wait busy) x N -> $FD -> wait busy
'
' @param start_sector - First sector to write
' @param count - Number of sectors to write (0 returns immediately)
' @param p_buffer - Pointer to source data (must be at least count * 512 bytes)
' @returns sectors_written - Number of sectors successfully written (0 on error)
' @local _sck - Local copy of SCK pin
' @local _mosi - Local copy of MOSI pin
' @local p_buf - Current buffer position
' @local stream_mode - Streamer mode word
' @local clk_count - Number of clock transitions
' @local xfrq - Streamer NCO frequency
' @local settle_delay - Stabilization delay after pin transition
' @local resp - Response byte
  '' - Reduced overhead from CS cycling and command processing
  ''
  '' CRITICAL: Multi-block write uses different tokens than single-block!
  '' - Each data block uses $FC (not $FE) as start token
  '' - Transmission ends with $FD stop token (not CMD12!)
  ''
  '' Protocol: CMD25 -> ($FC + 512 bytes + CRC + wait busy) x N -> $FD -> wait busy

  if count == 0
    return 0

  ' Setup variables for streamer
  _sck := sck
  _mosi := mosi
  stream_mode := STREAM_TX_BASE | (_mosi << 17) | (512 * 8)                     ' TX mode + MOSI pin + 4096 bits
  clk_count := 512 * 8 * 2                                                      ' 8192 clock transitions
  xfrq := $4000_0000 / spi_period                                               ' One output per full clock period
  settle_delay := spi_period                                                    ' Stabilization delay after pin transition

  ' Send CMD25 (WRITE_MULTIPLE_BLOCK) with starting sector
  ' Note: cmd() handles CS assertion and returns R1 response
  resp := cmd(CMD25, start_sector << hcs)
  if resp <> $00
    debug("  [writeSectors] CMD25 failed, R1=$", uhex_byte_(resp))
    pinh(cs)
    return 0

  ' Write each sector
  sectors_written := 0
  repeat count
    p_buf := p_buffer + (sectors_written * 512)                                 ' Calculate buffer position

    ' Send multi-block write start token ($FC, NOT $FE!)
    sp_transfer_8(TOKEN_START_MULTI_WRITE)                                      ' $FC

    ' Disable MOSI smart pin before streamer TX
    ' CRITICAL: Must ensure clean transition from smart pin mode to streamer mode
    pinclear(_mosi)                                                               ' Clear smart pin mode
    pinl(_mosi)                                                                   ' Drive low directly
    wypin(0, sck)                                                                 ' Clear any pending clock counts

    ' Streamer bulk transfer: 512 bytes from hub to MOSI
    ' CRITICAL: settle_delay ensures MOSI pin and clock are stable after
    ' pinclear/pinl transition - prevents bit corruption on subsequent blocks
    org
          setxfrq xfrq
          rdfast  #0, p_buf
          waitx   settle_delay                    ' Stabilize after pinclear/pinl/wypin(0)
          xinit   stream_mode, #0
          wypin   clk_count, _sck
          waitxfi
    end

    ' Re-enable MOSI smart pin for CRC and response
    wrpin(_mosi, spi_tx_mode)
    wxpin(_mosi, %1_00111)
    pinh(_mosi)

    ' Calculate and send CRC-16 for this sector's data
    diag_sent_crc := calcDataCRC(p_buf, 512)
    sp_transfer_8(diag_sent_crc >> 8)                                           ' CRC high byte
    sp_transfer_8(diag_sent_crc & $FF)                                          ' CRC low byte

    ' Wait for data response token
    resp := waitDataResponse()
    if resp < 0
      debug("  [writeSectors] No data response for sector ", udec_(start_sector + sectors_written))
      quit
    if (resp & $0F) <> DATA_ACCEPTED
      debug("  [writeSectors] Data rejected for sector ", udec_(start_sector + sectors_written), " resp=$", uhex_byte_(resp))
      quit

    ' Wait for card to finish programming this block
    if waitBusyComplete() < 0
      debug("  [writeSectors] Busy timeout for sector ", udec_(start_sector + sectors_written))
      quit

    sectors_written++

  ' Send stop token ($FD) to terminate multi-block write (NOT CMD12!)
  sp_transfer_8(TOKEN_STOP_TRAN)                                                ' $FD

  ' Wait for card to finish any final programming
  if waitBusyComplete() < 0
    debug("  [writeSectors] Final busy timeout")
    ' Still return sectors_written - data may have been written

  pinh(cs)                                                                      ' Deselect card

  ' CMD13: Verify card status after multi-block write
  if checkCardStatus(@"writeSectors") < 0
    debug("  [writeSectors] CMD13 status check FAILED after writing ", udec_(sectors_written), " sectors")
    ' Still return sectors_written - some data may have been written

' ════════════════════════════════════════════════════════════════════════════════
' MULTI-BLOCK HELPER FUNCTIONS
' These factor out common patterns used by readSectors() and writeSectors()
' ════════════════════════════════════════════════════════════════════════════════

PRI waitR1Response() : result | t, resp
' Wait for R1 response (non-$FF byte) - polls for R1 response after sending a command.
' Timeout: 100ms (per SD spec NCR = 0-8 bytes, but we allow more for slow cards)
'
' @returns result - R1 response byte on success, -1 on timeout
' @local t - Timeout deadline
' @local resp - Received response byte

  t := getct() + clkfreq / 10                                                   ' 100ms timeout
  repeat
    resp := sp_transfer_8($FF)
    if resp <> $FF
      return resp                                                               ' Got response
    if getct() - t > 0
      debug("  [waitR1Response] TIMEOUT")
      return -1

PRI waitDataToken() : result | t, resp
' Wait for data start token ($FE) - polls for data token before sector data.
' Error tokens: $01-$0F indicate read errors.
' Timeout: Uses card_read_timeout_ms from CSD (minimum 100ms, with 10x safety factor)
'
' @returns result - 0 on success (got $FE), -1 on timeout or error token
' @local t - Timeout deadline
' @local resp - Received byte

  t := getct() + (clkfreq / 100) * card_read_timeout_ms                         ' CSD-based timeout with 10x margin
  repeat
    resp := sp_transfer_8($FF)
    if resp == TOKEN_START_BLOCK                                                ' $FE = data coming
      return 0                                                                  ' Success
    if resp <> $FF                                                              ' Error token (not $FF, not $FE)
      debug("  [waitDataToken] ERROR token: $", uhex_byte_(resp))
      return -1
    if getct() - t > 0
      debug("  [waitDataToken] TIMEOUT")
      return -1

PRI waitDataResponse() : result | t, resp
' Wait for data response token after write - polls for data response after sending a block.
' Response format: xxx0sss1 where sss = 010 (accepted), 101 (CRC err), 110 (write err)
' Timeout: 100ms
'
' @returns result - Response status on success, -1 on timeout
' @local t - Timeout deadline
' @local resp - Received byte

  t := getct() + clkfreq / 10                                                   ' 100ms timeout
  repeat
    resp := sp_transfer_8($FF)
    if resp <> $FF
      ' Got response - check if it's a valid data response token (bit 0 = 1, bit 4 = 0)
      if (resp & $11) == $01                                                    ' Valid data response format
        return resp & $1F                                                       ' Return lower 5 bits
      ' Not a valid response format, keep polling (might be noise)
    if getct() - t > 0
      debug("  [waitDataResponse] TIMEOUT")
      return -1

PRI waitBusyComplete() : result | t, resp
' Wait for card to finish programming - polls until MISO returns $FF (not busy).
' Timeout: Uses card_write_timeout_ms from CSD (default 250ms for SDHC, calculated for SDSC)
' CRITICAL: Must keep clocking and CS LOW during busy period!
'
' @returns result - 0 on success, -1 on timeout
' @local t - Timeout deadline
' @local resp - Received byte

  t := getct() + (clkfreq / 1000) * card_write_timeout_ms                       ' CSD-based timeout
  repeat
    resp := sp_transfer_8($FF)
    if resp == $FF                                                              ' Card released MISO = done
      return 0
    if getct() - t > 0
      debug("  [waitBusyComplete] TIMEOUT - card still busy")
      return -1

PRI sendStopTransmission() : result | resp
' Send CMD12 to stop multi-block operation - terminates multi-block read/write.
' Note: CMD12 has a "stuff byte" before the response - we handle this by polling.
'
' @returns result - 0 on success, -1 on error
' @local resp - Response byte

  sp_transfer_8($40 | CMD12)                                                    ' Command byte: 0x40 | 12 = 0x4C
  sp_transfer_8($00)                                                            ' Argument bytes (ignored for CMD12)
  sp_transfer_8($00)
  sp_transfer_8($00)
  sp_transfer_8($00)
  sp_transfer_8($61)                                                            ' CRC7 + stop bit for CMD12
  sp_transfer_8($FF)                                                            ' Stuff byte (required by spec)

  ' Wait for R1b response (R1 followed by busy)
  resp := waitR1Response()
  if resp < 0
    return -1
  if resp <> $00
    debug("  [sendStopTransmission] R1 error: $", uhex_byte_(resp))
    return -1

  ' Wait for busy to complete (card may still be finishing last block)
  result := waitBusyComplete()

PRI checkCardStatus(caller) : result | r1, status
' Send CMD13 to verify card status after operation - checks R2 response for errors.
' R2 response format: R1 byte + status byte.
' Call this after every write operation and after CMD12.
'
' @param caller - String identifying the calling function (for debug)
' @returns result - 0 on success (card OK), -1 on error
' @local r1 - R1 response byte
' @local status - Status byte (second byte of R2)

  ' Send dummy clocks with CS HIGH to ensure card is ready
  ' (Some cards need recovery time after previous operation)
  pinh(cs)
  sp_transfer_8($FF)
  sp_transfer_8($FF)

  ' CMD13 requires CS to be asserted
  pinl(cs)

  ' Send CMD13 with no argument (RCA = 0x0000 for SPI mode)
  sp_transfer_8($40 | CMD13)                                                    ' Command byte: 0x40 | 13 = 0x4D
  sp_transfer_8($00)                                                            ' Argument bytes (RCA, unused in SPI)
  sp_transfer_8($00)
  sp_transfer_8($00)
  sp_transfer_8($00)
  sp_transfer_8($FF)                                                            ' CRC disabled after init in SPI mode

  ' Get R1 response (first byte of R2)
  r1 := waitR1Response()
  if r1 < 0
    debug("  [checkCardStatus] ", zstr_(caller), ": TIMEOUT waiting for R1")
    pinh(cs)
    return -1

  ' Get status byte (second byte of R2)
  status := sp_transfer_8($FF)

  pinh(cs)                                                                      ' Deselect card

  ' ═══════════════════════════════════════════════════════════════════════
  ' STAGE CMD13 RESULTS - Preserve for diagnostic inspection
  ' ═══════════════════════════════════════════════════════════════════════
  last_cmd13_r1 := r1
  last_cmd13_status := status
  if r1 <> 0 or status <> 0
    last_cmd13_error := (r1 << 8) | status                                      ' Preserve last error

  ' Check for errors
  if r1 <> $00
    debug("  [checkCardStatus] ", zstr_(caller), ": R1 error=$", uhex_byte_(r1))
    return -1

  if status <> $00
    debug("  [checkCardStatus] ", zstr_(caller), ": STATUS error=$", uhex_byte_(status))
    if status & CSR_OUT_OF_RANGE
      debug("    -> OUT_OF_RANGE")
    if status & CSR_ERASE_PARAM
      debug("    -> ERASE_PARAM")
    if status & CSR_WP_VIOLATION
      debug("    -> WP_VIOLATION")
    if status & CSR_CARD_ECC_FAILED
      debug("    -> CARD_ECC_FAILED")
    if status & CSR_CC_ERROR
      debug("    -> CC_ERROR")
    if status & CSR_ERROR
      debug("    -> ERROR")
    if status & CSR_WP_ERASE_SKIP
      debug("    -> WP_ERASE_SKIP")
    if status & CSR_CARD_IS_LOCKED
      debug("    -> CARD_IS_LOCKED")
    return -1

  return 0                                                                      ' Card status OK

PRI transfer(data,bits) : result | _cs, _mosi, _miso, _sck, delay
' Transfer data to/from SD card - bit-bang fallback for unsupported sizes.
'
' @param data - Data to transmit
' @param bits - Number of bits to transfer
' @returns result - Received data
' @local _cs - Local copy of CS pin
' @local _mosi - Local copy of MOSI pin
' @local _miso - Local copy of MISO pin
' @local _sck - Local copy of SCK pin
' @local delay - Bit delay value

  longmove(@_cs,@cs,4)
  delay := bit_delay
  result := data << (32-bits)                                                   '  move data to MSB
  org
                rep       @.end_rep,bits
                 rcl      result,#1                     wc                      '  send from msb of result, receive into lsb of result
                 drvl     _sck
                 drvc     _mosi
                 waitx    delay
                 drvh     _sck
                 waitx    delay
                 testp    _miso                         wc
.end_rep
                drvh      _mosi
                rcl       result,#1
  end
  if bits < 32                                                                   '  mask to requested bit count
    result &= (1 << bits) - 1                                                   '  (skip for 32 bits - mask would wrap)

CON     '' debug methods
  _CLKFREQ = 80_000_000
PUB displaySector() | address, char, ascii_ptr, i
'' Display sector in buffer - prints hex dump with ASCII representation.
''
'' @local address - Current byte offset in buffer
'' @local char - Current character being processed
'' @local ascii_ptr - Pointer to ASCII representation string
'' @local i - Loop counter

  ascii_ptr := string("0123456789ABCDEF")
  repeat address from 0 to 495 step 16
    repeat i from 0 to 15
      case char := (buf[address + i])
        $20..$7E: byte[ascii_ptr + i] := char
        other:
          if char == 0
            byte[ascii_ptr + i] := "."
          else
            byte[ascii_ptr + i] := char // 26 + "a"
    debug(uhex_word_(address),uhex_byte_array_(@buf + address,8),"-",uhex_byte_array_(@buf + address + 8,8)," | ",lstr_(ascii_ptr,16))

PUB displayEntry() | address, char, ascii_ptr, i
'' Display directory entry - prints hex dump of entry_buffer with ASCII representation.
''
'' @local address - Current byte offset in entry
'' @local char - Current character being processed
'' @local ascii_ptr - Pointer to ASCII representation string
'' @local i - Loop counter

  ascii_ptr := string("0123456789ABCDEF")
  repeat address from 0 to 31 step 16
    repeat i from 0 to 15
      case char := (entry_buffer[address + i])
        $20..$7E: byte[ascii_ptr + i] := char
        other:
          if char == 0
            byte[ascii_ptr + i] := "."
          else
            byte[ascii_ptr + i] := char // 26 + "a"
    debug(uhex_word_(address),uhex_byte_array_(@entry_buffer + address,8),"-",uhex_byte_array_(@entry_buffer + address + 8,8)," | ",lstr_(ascii_ptr,16))

PUB displayFAT(cluster)
'' Display FAT sector containing cluster number - reads and displays FAT entries.
''
'' @param cluster - Cluster number to display FAT sector for

  n_sec := fat_sec + cluster >> 7
  readSector(n_sec, BUF_DATA)                                                   ' Uses BUF_DATA since displaySector reads from buf
  displaySector()

CON {{     FAT32 file system
  ┌─────────────────────────┐     The master boot record contains 446 bytes of boot code
  │ Master Boot Record      │      followed by four 16-byte partition entries
  │                         │      terminated with $55 $AA in the final 2 bytes
  │ Partitions      $55 $AA │     The 16-byte partition
  ├─────────────────────────┤     ┌──────┬───────┬──────┬─────┬───────┬───────────┐
  │ Reserved                │     │ Boot │ CHS   │ Type │ CHS │ LBA   │ Number of │  Type code located at byte address $1C2
  ├─────────────────────────┤     │ Flag │ Begin │ Code │ End │ Begin │ Sectors   │   Type code = $0B or $0C for FAT32
  │ Volume Boot Record 1    │     ├──────┼───────┼──────┼─────┼───────┼───────────┤  LBA Begin contains address of volume boot record (VBR)
  ├─────────────────────────┤     │      │       │  5   │     │ 9-12  │           │   VBR address located at byte address $1C6
  │ Reserved                │     └──────┴───────┴──────┴─────┴───────┴───────────┘
  ├─────────────────────────┤     Volume boot record contains
  │ Volume Boot Record 2    │     ┌─────────────────────────────────┬────────┬──────┬────────────────────┐
  ├─────────────────────────┤     │          Field                  │ Offset │ Size │ Value              │
  │ Reserved                │     ├─────────────────────────────────┼────────┼──────┼────────────────────┤
  ├─────────────────────────┤     │ Bytes per Sector                │  $0B   │ 16b  │       512          │
  │ File allocation table 1 │     │ Sectors per Cluster             │  $0D   │  8b  │1/2/4/8/16/32/64/128│
  ├─────────────────────────┤     │ Number of Reserved Sectors      │  $0E   │ 16b  │                    │
  │ File allocation table 2 │     │ Number of FATs                  │  $10   │  8b  │        2           │
  ├─────────────────────────┤     │ Sectors per FAT                 │  $24   │ 32b  │                    │
  │ Root directory and      │     │ Root Directory of First Cluster │  $2C   │ 32b  │        2           │
  │  Data region            │     │ Signature                       │ $1FE   │ 16b  │      $AA55         │
  │                         │     └─────────────────────────────────┴────────┴──────┴────────────────────┘
  │                         │      The address of the 1st FAT is VBR address + number of reserved sectors
  │                         │      The address of the root directory is FAT address + number of FATs x sectors per fat
  └─────────────────────────┘
                                  The file system directory contains 32-byte entries for each file in the root directory
                                  ┌─────────────────────────────────┬────────┬──────┐
                                  │          Field                  │ Offset │ Size │  The first byte of the short filename indicates the type of entry
                                  ├─────────────────────────────────┼────────┼──────┤   Normal entry     - as expected   "FILENAMETXT"
                                  │ Short Filename                  │  $00   │ 11B  │   Unused/deleted   - 1st byte $E5  "åILENAMETXT"
                                  │ Attrib Byte                     │  $0B   │  1B  │   End of directory - 1st byte $00
                                  │ Date of creation                │  $0E   │  4B  │
                                  │ First Cluster High              │  $14   │  2B  │
                                  │ Date of modification            │  $16   │  4B  │
                                  │ First Cluster Low               │  $1A   │  2B  │
                                  │ File Size                       │  $1C   │  4B  │
                                  └─────────────────────────────────┴────────┴──────┘
                                  Attrib byte contains bitfields
                                  ┌───┬───────────┬─────┬────────────────────────────────────┐
                                  │bit│ Function  │ LFN │ Comment                            │
                                  ├───┼───────────┼─────┼────────────────────────────────────┤
                                  │ 7 │ Unused    │  0  │ Should be zero                     │
                                  │ 6 │ Unused    │  0  │ Should be zero                     │
                                  │ 5 │ Archive   │  x  │ Has been changed since last backup │
                                  │ 4 │ Directory │  x  │ Is a subdirectory                  │
                                  │ 3 │ Volume ID │  1  │ Filename is Volume ID              │
                                  │ 2 │ System    │  1  │ File is operating system           │
                                  │ 1 │ Hidden    │  1  │ Should not show in dir listing     │
                                  │ 0 │ Read Only │  1  │ Should not allow writing           │
                                  └───┴───────────┴─────┴────────────────────────────────────┘
                                  Each entry in the file allocation table is 32 bits, entry 0 is associated with cluster 0, entry 1/cluster 1, and so on
                                   The 32-bit value contains 0 if the associated cluster is available
                                   contains $0FFF_FFFF if the data in the associated cluster ends in that cluster
                                   contains the address of the next cluster in the file if the file occupies multiple clusters
                                  ┌───────────┬───────────┬───────────┬───────────┐
              clusters $00 - $03  │ 0FFF_FFFF │ 0FFF_FFFF │ 0FFF_FFFF │ 0FFF_FFFF │  1st four clusters occupied by self-contained files
                       $04 - $07  │ 0000_0005 │ 0000_0006 │ 0000_0007 │ 0FFF_FFFF │  next four clusters occupied by a file in sequential clusters
                       $08 - $0B  │ 0000_000A │ 0FFF_FFFF │ 0000_000C │ 0FFF_FFFF │  a fragmented file starts in cluster 8, and occupies clusters 10, 12, and ends in 14
                       $0C - $0F  │ 0000_000E │ 0000_0000 │ 0FFF_FFFF │ 0000_0000 │  clusters 13 and 15 are unused
}}
CON
{{
┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                                   TERMS OF USE: MIT License                                                  │
├──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation    │
│files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,    │
│modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software│
│is furnished to do so, subject to the following conditions:                                                                   │
│                                                                                                                              │
│The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.│
│                                                                                                                              │
│THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE          │
│WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR         │
│COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,   │
│ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                         │
└──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
}}