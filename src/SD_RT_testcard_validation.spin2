'' =================================================================================================
''
''   File....... SD_RT_testcard_validation.spin2
''   Purpose.... Validate driver can read pre-formatted test card (cross-OS compatibility)
''   Author..... Stephen M Moraco
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... JAN 2026
''   Updated.... 16 JAN 2026
''
''   NOTE: This test requires the pre-formatted test card!
''         See TestCard/TEST-CARD-SPECIFICATION.md for card preparation.
''         Copy TestCard/TESTROOT/* to the SD card root before running.
''
'' =================================================================================================

CON

     _CLKFREQ        = 320_000_000

     ' Pin configuration for P2 Edge with SD card
     SD_CS   = 60
     SD_MOSI = 59
     SD_MISO = 58
     SD_SCK  = 61

     ' Buffer sizes for various tests
     SMALL_BUF = 64
     MEDIUM_BUF = 512
     LARGE_BUF = 4096

OBJ
    sd    : "SD_card_driver"
    utils : "SD_RT_utilities"

DAT

' Test file paths from specification
fileTiny        BYTE    "TINY.TXT", 0
fileExact512    BYTE    "EXACT512.BIN", 0
fileTwoSec      BYTE    "TWOSEC.TXT", 0
fileFourK       BYTE    "FOUR_K.BIN", 0
fileSixtyK      BYTE    "SIXTYFK.BIN", 0
fileSeekTest    BYTE    "SEEKTEST.BIN", 0
fileChecksum    BYTE    "CHECKSUM.BIN", 0
fileLevel1      BYTE    "/LEVEL1/INLEVEL1.TXT", 0
fileDeep        BYTE    "/LEVEL1/LEVEL2/DEEP.TXT", 0
dirMulti        BYTE    "MULTI", 0

' Expected content
tinyContent     BYTE    "TINY TEST FILE", 0    ' First 14 chars of TINY.TXT
level1Content   BYTE    "This file is in LEVEL1", 0  ' First 22 chars
deepContent     BYTE    "Deepest level", 0     ' First 13 chars

' Buffers
smallBuf        BYTE    0[SMALL_BUF]
mediumBuf       BYTE    0[MEDIUM_BUF]
largeBuf        BYTE    0[LARGE_BUF]

PUB go() | result

    debug(" ")
    debug("==============================================")
    debug("  SD Card Driver - Test Card Validation")
    debug("  (Cross-OS Compatibility Tests)")
    debug("==============================================")
    debug(" ")
    debug("NOTE: This test requires the pre-formatted test card!")
    debug("      See TestCard/TEST-CARD-SPECIFICATION.md")
    debug(" ")

    ' Mount the card
    result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    if result == false
        debug("ERROR: Could not mount SD card!")
        debug("Is the test card inserted?")
        debug("END_SESSION")
        return

    ' Show card info
    debug(" ")
    debug("* SD Card Information:")
    debug("   Volume Label: ", zstr_(sd.volumeLabel()))
    debug("   Free Space: ", udec(sd.freeSpace()), " sectors")

    ' Run all validation tests
    test_mount_validation()
    test_root_directory_enum()
    test_tiny_file()
    test_exact_sector()
    test_four_k_pattern()
    test_multi_sector_text()
    test_large_file_cluster_chain()
    test_seek_operations()
    test_checksum_integrity()
    test_path_resolution()
    test_deep_path()
    test_directory_navigation()
    test_benchmark_sequential()

    ' Unmount
    sd.unmount()

    ' Summary
    utils.ShowTestEndCounts()

    debug(" ")
    debug("* Test Card Validation Complete")
    debug("END_SESSION")


PRI test_mount_validation() | pLabel
    utils.startTestGroup(@"Test 1: Mount Validation")

    utils.startTest(@"Card mounted successfully")
    pLabel := sd.volumeLabel()
    utils.evaluateNotZero(pLabel, @"volumeLabel() not null")

    utils.startTest(@"Free space is reasonable")
    utils.evaluateRange(sd.freeSpace(), @"freeSpace()", 1, $7FFF_FFFF)


PRI test_root_directory_enum() | count, idx, pEntry
    utils.startTestGroup(@"Test 2: Root Directory Enumeration")

    utils.startTest(@"Enumerate root directory entries")
    count := 0
    idx := 0
    repeat
        pEntry := sd.readDirectory(idx)
        if pEntry == 0
            quit
        debug("  Entry ", udec_(idx), ": ", zstr_(sd.fileName()))
        count++
        idx++

    ' Expected: At least 7 items (files + LEVEL1 + MULTI directories)
    utils.evaluateRange(count, @"directory entry count", 7, 50)


PRI test_tiny_file() | result, fileSize, bytesRead
    utils.startTestGroup(@"Test 3: Small File Read (TINY.TXT)")

    utils.startTest(@"Open TINY.TXT")
    result := sd.openFile(@fileTiny)
    utils.evaluateBool(result, @"openFile()", true)

    utils.startTest(@"Verify file size is 29 bytes")
    fileSize := sd.fileSize()
    utils.evaluateSingleValue(fileSize, @"fileSize()", 29)

    utils.startTest(@"Read and verify content starts correctly")
    bytesRead := sd.read(@smallBuf, 14)
    smallBuf[14] := 0  ' null terminate for comparison
    utils.evaluateStringMatch(@smallBuf, @"content start", @tinyContent)

    utils.startTest(@"Verify first byte is 'T' (0x54)")
    sd.seek(0)
    bytesRead := sd.read(@smallBuf, 1)
    utils.evaluateSingleValueHex(smallBuf[0], @"first byte", $54)

    sd.closeFile()


PRI test_exact_sector() | result, i, allMatch
    utils.startTestGroup(@"Test 4: Exact Sector Boundary (EXACT512.BIN)")

    utils.startTest(@"Open EXACT512.BIN")
    result := sd.openFile(@fileExact512)
    utils.evaluateBool(result, @"openFile()", true)

    utils.startTest(@"Verify file size is exactly 512 bytes")
    utils.evaluateSingleValue(sd.fileSize(), @"fileSize()", 512)

    utils.startTest(@"Read 512 bytes")
    sd.read(@mediumBuf, 512)

    utils.startTest(@"Verify all bytes are 0x58 ('X')")
    allMatch := true
    repeat i from 0 to 511
        if mediumBuf[i] <> $58
            debug("  Mismatch at ", udec_(i), ": got $", uhex_(mediumBuf[i]))
            allMatch := false
            quit
    utils.evaluateBool(allMatch, @"all bytes = 0x58", true)

    sd.closeFile()


PRI test_four_k_pattern() | result, i, expected, allMatch
    utils.startTestGroup(@"Test 5: Multi-Sector Pattern (FOUR_K.BIN)")

    utils.startTest(@"Open FOUR_K.BIN")
    result := sd.openFile(@fileFourK)
    utils.evaluateBool(result, @"openFile()", true)

    utils.startTest(@"Verify file size is 4096 bytes")
    utils.evaluateSingleValue(sd.fileSize(), @"fileSize()", 4096)

    utils.startTest(@"Read and verify sequential pattern")
    allMatch := true

    ' Read in chunks and verify pattern: byte[i] = i & 0xFF
    repeat i from 0 to 7  ' 8 sectors
        sd.read(@mediumBuf, 512)
        repeat result from 0 to 511
            expected := ((i * 512) + result) & $FF
            if mediumBuf[result] <> expected
                debug("  Mismatch at ", udec_((i * 512) + result), ": got $", uhex_(mediumBuf[result]), " expected $", uhex_(expected))
                allMatch := false
                quit
        if not allMatch
            quit

    utils.evaluateBool(allMatch, @"pattern match", true)

    sd.closeFile()


PRI test_multi_sector_text() | result, fileSize
    utils.startTestGroup(@"Test 6: Multi-Sector Text (TWOSEC.TXT)")

    utils.startTest(@"Open TWOSEC.TXT")
    result := sd.openFile(@fileTwoSec)
    utils.evaluateBool(result, @"openFile()", true)

    utils.startTest(@"Verify file size is 2550 bytes")
    fileSize := sd.fileSize()
    utils.evaluateSingleValue(fileSize, @"fileSize()", 2550)

    utils.startTest(@"Read first line - should start with LINE0001")
    sd.read(@smallBuf, 8)
    smallBuf[8] := 0
    utils.evaluateStringMatch(@smallBuf, @"first 8 bytes", @"LINE0001")

    sd.closeFile()


PRI test_large_file_cluster_chain() | result, fileSize, pos, expected, actual
    utils.startTestGroup(@"Test 7: Multi-Cluster File (SIXTYFK.BIN)")

    utils.startTest(@"Open SIXTYFK.BIN")
    result := sd.openFile(@fileSixtyK)
    utils.evaluateBool(result, @"openFile()", true)

    utils.startTest(@"Verify file size is 65536 bytes")
    fileSize := sd.fileSize()
    utils.evaluateSingleValue(fileSize, @"fileSize()", 65536)

    utils.startTest(@"Verify pattern at various positions")
    utils.setCheckCountPerTest(8)

    ' Pattern: byte[i] = (block << 1) XOR (i & 0xFF) where block = i / 512
    repeat pos from 0 to 65535 step 8192  ' Check every 8KB
        sd.seek(pos)
        sd.read(@smallBuf, 1)
        expected := ((pos / 512) << 1) ^ (pos & $FF)
        utils.evaluateSubValueHex(smallBuf[0], @"pattern byte", expected)

    sd.closeFile()


PRI test_seek_operations() | result
    utils.startTestGroup(@"Test 8: Seek Operations (SEEKTEST.BIN)")

    utils.startTest(@"Open SEEKTEST.BIN")
    result := sd.openFile(@fileSeekTest)
    utils.evaluateBool(result, @"openFile()", true)

    utils.startTest(@"Verify file size is 2016 bytes")
    utils.evaluateSingleValue(sd.fileSize(), @"fileSize()", 2016)

    ' File has 32 blocks of 63 bytes each: "BLK##---" + 55 bytes of 0x55
    utils.startTest(@"Seek to block 0 (offset 0)")
    sd.seek(0)
    sd.read(@smallBuf, 8)
    smallBuf[8] := 0
    utils.evaluateStringMatch(@smallBuf, @"block 0 header", @"BLK00---")

    utils.startTest(@"Seek to block 1 (offset 63)")
    sd.seek(63)
    sd.read(@smallBuf, 8)
    smallBuf[8] := 0
    utils.evaluateStringMatch(@smallBuf, @"block 1 header", @"BLK01---")

    utils.startTest(@"Seek to block 10 (offset 630)")
    sd.seek(630)
    sd.read(@smallBuf, 8)
    smallBuf[8] := 0
    utils.evaluateStringMatch(@smallBuf, @"block 10 header", @"BLK10---")

    utils.startTest(@"Seek to block 31 (offset 1953)")
    sd.seek(1953)
    sd.read(@smallBuf, 8)
    smallBuf[8] := 0
    utils.evaluateStringMatch(@smallBuf, @"block 31 header", @"BLK31---")

    sd.closeFile()


PRI test_checksum_integrity() | result, i, sum
    utils.startTestGroup(@"Test 9: Checksum Verification (CHECKSUM.BIN)")

    utils.startTest(@"Open CHECKSUM.BIN")
    result := sd.openFile(@fileChecksum)
    utils.evaluateBool(result, @"openFile()", true)

    utils.startTest(@"Verify file size is 1024 bytes")
    utils.evaluateSingleValue(sd.fileSize(), @"fileSize()", 1024)

    utils.startTest(@"Read and calculate checksum")
    ' Read in two chunks since buffer is 512
    sum := 0
    sd.read(@mediumBuf, 512)
    repeat i from 0 to 511
        sum += mediumBuf[i]
    sd.read(@mediumBuf, 512)
    repeat i from 0 to 511
        sum += mediumBuf[i]

    ' Expected sum: 130560 (bytes 0-255 repeated 4 times: 4 * (0+1+2+...+255) = 4 * 32640)
    utils.evaluateSingleValue(sum, @"checksum", 130560)

    sd.closeFile()


PRI test_path_resolution() | result, fileSize
    utils.startTestGroup(@"Test 10: Subdirectory Path Resolution")

    utils.startTest(@"Open /LEVEL1/INLEVEL1.TXT with absolute path")
    result := sd.openFile(@fileLevel1)
    utils.evaluateBool(result, @"openFile()", true)

    utils.startTest(@"Verify file size is 54 bytes")
    fileSize := sd.fileSize()
    utils.evaluateSingleValue(fileSize, @"fileSize()", 54)

    utils.startTest(@"Verify content starts correctly")
    sd.read(@smallBuf, 22)
    smallBuf[22] := 0
    utils.evaluateStringMatch(@smallBuf, @"content start", @level1Content)

    sd.closeFile()


PRI test_deep_path() | result, fileSize
    utils.startTestGroup(@"Test 11: Deep Nested Path")

    utils.startTest(@"Open /LEVEL1/LEVEL2/DEEP.TXT")
    result := sd.openFile(@fileDeep)
    utils.evaluateBool(result, @"openFile()", true)

    utils.startTest(@"Verify file size is 71 bytes")
    fileSize := sd.fileSize()
    utils.evaluateSingleValue(fileSize, @"fileSize()", 71)

    utils.startTest(@"Verify content starts correctly")
    sd.read(@smallBuf, 13)
    smallBuf[13] := 0
    utils.evaluateStringMatch(@smallBuf, @"content start", @deepContent)

    sd.closeFile()


PRI test_directory_navigation() | result, count, idx, pEntry
    utils.startTestGroup(@"Test 12: Directory Navigation (MULTI)")

    utils.startTest(@"Change to MULTI directory")
    result := sd.changeDirectory(@dirMulti)
    utils.evaluateBool(result, @"changeDirectory()", true)

    utils.startTest(@"Enumerate files in MULTI - expect 5")
    count := 0
    idx := 0
    repeat
        pEntry := sd.readDirectory(idx)
        if pEntry == 0
            quit
        debug("  File: ", zstr_(sd.fileName()))
        count++
        idx++

    utils.evaluateSingleValue(count, @"file count", 5)

    utils.startTest(@"Navigate back to root")
    result := sd.changeDirectory(@"/")
    utils.evaluateBool(result, @"changeDirectory(/)", true)


PRI test_benchmark_sequential() | start, elapsed, bytesRead, i, bytesPerSec
    utils.startTestGroup(@"Performance Benchmark")

    utils.startTest(@"Sequential read 64KB - timing")
    sd.openFile(@fileSixtyK)

    start := getct()
    repeat i from 0 to 127
        sd.read(@mediumBuf, 512)
    elapsed := getct() - start

    sd.closeFile()

    ' Calculate throughput
    ' elapsed is in clock ticks, convert to microseconds then to bytes/sec
    bytesPerSec := (65536 * (clkfreq / 1000)) / (elapsed / 1000)

    debug("  64KB read time: ", udec_(elapsed / (clkfreq / 1000000)), " microseconds")
    debug("  Throughput: ~", udec_(bytesPerSec / 1024), " KB/sec")
    debug("   -> pass (benchmark complete)")


con { license }

{{
  =================================================================================================

  Terms of Use: MIT License

  Copyright (c) 2026 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  =================================================================================================
}}
