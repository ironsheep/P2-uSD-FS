'' =================================================================================================
''
''   File....... SD_RT_multihandle_tests.spin2
''   Purpose.... This object tests V3 multi-file handle functionality
''   Author..... Stephen M Moraco
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... JAN 2026
''   Updated.... 29 JAN 2026
''
'' =================================================================================================
''
'' Tests the V3 handle-based file API:
''   - Multiple simultaneous file opens
''   - Per-handle independent positions
''   - Single-writer policy enforcement
''   - Handle allocation and release
''   - Data persistence through write/close/reopen/read cycle
''   - Sync operations
''
'' =================================================================================================

CON

     _CLKFREQ        = 320_000_000

     ' Pin configuration for P2 Edge with SD card
     SD_CS   = 60
     SD_MOSI = 59
     SD_MISO = 58
     SD_SCK  = 61

     ' V3 Error codes we expect to encounter
     E_TOO_MANY_FILES    = -90
     E_INVALID_HANDLE    = -91
     E_FILE_ALREADY_OPEN = -92
     E_FILE_NOT_FOUND    = -40
     E_FILE_EXISTS       = -41

     ' Maximum handles to test
     MAX_TEST_HANDLES = 4

OBJ
    sd    : "SD_card_driver_v3"
    utils : "SD_RT_utilities"

DAT

' Test filenames - unique names for multi-handle tests
testfile1       BYTE    "MHTEST1.TXT", 0
testfile2       BYTE    "MHTEST2.TXT", 0
testfile3       BYTE    "MHTEST3.TXT", 0
testfile4       BYTE    "MHTEST4.TXT", 0
testfile5       BYTE    "MHTEST5.TXT", 0      ' Fifth file for overflow test

' Test content - unique for each file
content1        BYTE    "Content for file ONE - first test file", 0
content2        BYTE    "Content for file TWO - second test file", 0
content3        BYTE    "Content for file THREE - third test file", 0
content4        BYTE    "Content for file FOUR - fourth test file", 0

' Buffer for read operations
readBuffer      BYTE    0[256]

PUB go() | result, h1, h2, h3, h4, h5, bytesRead, bytesWritten, pos, size

    debug(" ")
    debug("==============================================")
    debug("  SD Card Driver V3 - Multi-Handle Tests")
    debug("==============================================")

    ' Mount the card first
    result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    if result == false
        debug("ERROR: Could not mount SD card!")
        debug("END_SESSION")
        return

    ' Show card info
    debug(" ")
    debug("* SD Card Information:")
    debug("   Volume Label: ", zstr_(sd.volumeLabel()))
    debug("   Free Space: ", udec(sd.freeSpace()), " sectors")

    ' Clean up any existing test files
    cleanupTestFiles()

    ' Create test files with known content
    createTestFiles()

    ' ======================================================================
    ' TEST GROUP: Multiple Read Handles
    ' ======================================================================
    utils.startTestGroup(@"Multiple Read Handles")

    ' Test: Open 4 files for read, get unique handles
    utils.startTest(@"Open 4 files for read returns unique handles 0-3")
    h1 := sd.openFileRead(@testfile1)
    h2 := sd.openFileRead(@testfile2)
    h3 := sd.openFileRead(@testfile3)
    h4 := sd.openFileRead(@testfile4)

    utils.evaluateSubBool(h1 >= 0, @"Handle 1 valid", true)
    utils.evaluateSubBool(h2 >= 0, @"Handle 2 valid", true)
    utils.evaluateSubBool(h3 >= 0, @"Handle 3 valid", true)
    utils.evaluateSubBool(h4 >= 0, @"Handle 4 valid", true)
    utils.evaluateSubBool(h1 <> h2 and h2 <> h3 and h3 <> h4, @"All handles unique", true)

    ' Test: Read from all 4 files, verify correct data
    utils.startTest(@"Read from 4 handles returns correct data")
    utils.setCheckCountPerTest(4)

    bytefill(@readBuffer, 0, 256)
    bytesRead := sd.readHandle(h1, @readBuffer, strsize(@content1))
    utils.evaluateSubBool(strcomp(@readBuffer, @content1), @"Handle 1 content", true)

    bytefill(@readBuffer, 0, 256)
    bytesRead := sd.readHandle(h2, @readBuffer, strsize(@content2))
    utils.evaluateSubBool(strcomp(@readBuffer, @content2), @"Handle 2 content", true)

    bytefill(@readBuffer, 0, 256)
    bytesRead := sd.readHandle(h3, @readBuffer, strsize(@content3))
    utils.evaluateSubBool(strcomp(@readBuffer, @content3), @"Handle 3 content", true)

    bytefill(@readBuffer, 0, 256)
    bytesRead := sd.readHandle(h4, @readBuffer, strsize(@content4))
    utils.evaluateSubBool(strcomp(@readBuffer, @content4), @"Handle 4 content", true)

    ' Close all handles
    sd.closeFileHandle(h1)
    sd.closeFileHandle(h2)
    sd.closeFileHandle(h3)
    sd.closeFileHandle(h4)

    ' ======================================================================
    ' TEST GROUP: Independent Positions
    ' ======================================================================
    utils.startTestGroup(@"Independent Handle Positions")

    ' Test: Same file, two read handles, independent positions
    utils.startTest(@"Same file on 2 handles have independent positions")
    h1 := sd.openFileRead(@testfile1)
    h2 := sd.openFileRead(@testfile1)

    utils.evaluateSubBool(h1 >= 0, @"First handle valid", true)
    utils.evaluateSubBool(h2 >= 0, @"Second handle valid", true)
    utils.evaluateSubBool(h1 <> h2, @"Handles are different", true)

    ' Seek handle 1 to position 12 ("file ONE" starts there)
    sd.seekHandle(h1, 12)

    ' Read from both - should get different data
    bytefill(@readBuffer, 0, 256)
    bytesRead := sd.readHandle(h1, @readBuffer, 8)  ' Read "file ONE"
    utils.evaluateSubBool(strncmp(@readBuffer, @"file ONE", 8), @"Handle 1 at pos 12", true)

    bytefill(@readBuffer, 0, 256)
    bytesRead := sd.readHandle(h2, @readBuffer, 7)  ' Read "Content"
    utils.evaluateSubBool(strncmp(@readBuffer, @"Content", 7), @"Handle 2 at pos 0", true)

    sd.closeFileHandle(h1)
    sd.closeFileHandle(h2)

    ' ======================================================================
    ' TEST GROUP: Single-Writer Policy
    ' ======================================================================
    utils.startTestGroup(@"Single-Writer Policy")

    ' Test: Second write open returns E_FILE_ALREADY_OPEN
    utils.startTest(@"Second write-open returns E_FILE_ALREADY_OPEN")
    h1 := sd.openFileWrite(@testfile1)
    utils.evaluateSubBool(h1 >= 0, @"First write-open succeeds", true)

    h2 := sd.openFileWrite(@testfile1)
    utils.evaluateSingleValue(h2, @"Second write-open error", E_FILE_ALREADY_OPEN)

    sd.closeFileHandle(h1)

    ' Test: Write open blocks write, but read is allowed
    utils.startTest(@"Read allowed while file open for write")
    h1 := sd.openFileWrite(@testfile1)
    utils.evaluateSubBool(h1 >= 0, @"Write-open succeeds", true)

    h2 := sd.openFileRead(@testfile1)
    utils.evaluateSubBool(h2 >= 0, @"Read-open succeeds", true)

    sd.closeFileHandle(h1)
    sd.closeFileHandle(h2)

    ' ======================================================================
    ' TEST GROUP: Handle Limit Enforcement
    ' ======================================================================
    utils.startTestGroup(@"Handle Limit Enforcement")

    ' Test: Opening 5th file returns E_TOO_MANY_FILES
    utils.startTest(@"Opening 5th file returns E_TOO_MANY_FILES")

    ' Create the 5th test file
    h1 := sd.createFileNew(@testfile5)
    if h1 >= 0
        sd.closeFileHandle(h1)

    h1 := sd.openFileRead(@testfile1)
    h2 := sd.openFileRead(@testfile2)
    h3 := sd.openFileRead(@testfile3)
    h4 := sd.openFileRead(@testfile4)

    utils.evaluateSubBool(h1 >= 0, @"Handle 1 allocated", true)
    utils.evaluateSubBool(h2 >= 0, @"Handle 2 allocated", true)
    utils.evaluateSubBool(h3 >= 0, @"Handle 3 allocated", true)
    utils.evaluateSubBool(h4 >= 0, @"Handle 4 allocated", true)

    h5 := sd.openFileRead(@testfile5)
    utils.evaluateSingleValue(h5, @"5th open error", E_TOO_MANY_FILES)

    sd.closeFileHandle(h1)
    sd.closeFileHandle(h2)
    sd.closeFileHandle(h3)
    sd.closeFileHandle(h4)

    ' ======================================================================
    ' TEST GROUP: Handle Release and Reuse
    ' ======================================================================
    utils.startTestGroup(@"Handle Release and Reuse")

    ' Test: Close handles in non-sequential order, verify slots become reusable
    utils.startTest(@"Closed handles become reusable")

    h1 := sd.openFileRead(@testfile1)
    h2 := sd.openFileRead(@testfile2)
    h3 := sd.openFileRead(@testfile3)
    h4 := sd.openFileRead(@testfile4)

    ' Close in non-sequential order: 2, 0, 3, 1
    result := sd.closeFileHandle(h3)  ' Close handle for file 3
    utils.evaluateSubValue(result, @"Close h3", 0)

    result := sd.closeFileHandle(h1)  ' Close handle for file 1
    utils.evaluateSubValue(result, @"Close h1", 0)

    result := sd.closeFileHandle(h4)  ' Close handle for file 4
    utils.evaluateSubValue(result, @"Close h4", 0)

    result := sd.closeFileHandle(h2)  ' Close handle for file 2
    utils.evaluateSubValue(result, @"Close h2", 0)

    ' Now open should work again
    h1 := sd.openFileRead(@testfile1)
    utils.evaluateSubBool(h1 >= 0, @"Reopen after close", true)
    sd.closeFileHandle(h1)

    ' ======================================================================
    ' TEST GROUP: Write Persistence
    ' ======================================================================
    utils.startTestGroup(@"Write Persistence")

    ' Test: Write, close, reopen, read back - verify data persisted
    utils.startTest(@"Write persists through close/reopen cycle")

    ' Delete the test file if it exists, then create fresh
    sd.deleteFile(@testfile5)
    h1 := sd.createFileNew(@testfile5)
    utils.evaluateSubBool(h1 >= 0, @"Create new file", true)

    ' Write test data
    bytesWritten := sd.writeHandle(h1, @"Persistence Test Data", 21)
    utils.evaluateSubValue(bytesWritten, @"Bytes written", 21)

    ' Close the file
    result := sd.closeFileHandle(h1)
    utils.evaluateSubValue(result, @"Close after write", 0)

    ' Reopen for read
    h1 := sd.openFileRead(@testfile5)
    utils.evaluateSubBool(h1 >= 0, @"Reopen for read", true)

    ' Check file size
    size := sd.fileSizeHandle(h1)
    utils.evaluateSubValue(size, @"File size", 21)

    ' Read back and verify
    bytefill(@readBuffer, 0, 256)
    bytesRead := sd.readHandle(h1, @readBuffer, 21)
    utils.evaluateSubValue(bytesRead, @"Bytes read", 21)
    utils.evaluateSubBool(strcomp(@readBuffer, @"Persistence Test Data"), @"Data matches", true)

    sd.closeFileHandle(h1)

    ' ======================================================================
    ' TEST GROUP: Sync Operations
    ' ======================================================================
    utils.startTestGroup(@"Sync Operations")

    ' Test: Sync flushes data without closing
    utils.startTest(@"syncHandle flushes without closing")

    ' Create and write to a file
    sd.deleteFile(@testfile5)
    h1 := sd.createFileNew(@testfile5)
    utils.evaluateSubBool(h1 >= 0, @"Create file", true)

    bytesWritten := sd.writeHandle(h1, @"Sync Test", 9)
    utils.evaluateSubValue(bytesWritten, @"Bytes written", 9)

    ' Sync the handle
    result := sd.syncHandle(h1)
    utils.evaluateSubValue(result, @"Sync result", 0)

    ' Handle should still be valid - write more data
    bytesWritten := sd.writeHandle(h1, @" More", 5)
    utils.evaluateSubValue(bytesWritten, @"Write after sync", 5)

    ' Check size includes both writes
    size := sd.fileSizeHandle(h1)
    utils.evaluateSubValue(size, @"Size after sync+write", 14)

    sd.closeFileHandle(h1)

    ' Verify by reopening
    h1 := sd.openFileRead(@testfile5)
    size := sd.fileSizeHandle(h1)
    utils.evaluateSubValue(size, @"Final size", 14)

    bytefill(@readBuffer, 0, 256)
    bytesRead := sd.readHandle(h1, @readBuffer, 14)
    utils.evaluateSubBool(strcomp(@readBuffer, @"Sync Test More"), @"All data present", true)

    sd.closeFileHandle(h1)

    ' ======================================================================
    ' TEST GROUP: EOF Detection
    ' ======================================================================
    utils.startTestGroup(@"EOF Detection")

    utils.startTest(@"eofHandle returns correct state")
    h1 := sd.openFileRead(@testfile1)

    ' At start, should not be at EOF
    result := sd.eofHandle(h1)
    utils.evaluateSubBool(result == 0, @"Not at EOF initially", true)

    ' Read entire file
    size := sd.fileSizeHandle(h1)
    bytefill(@readBuffer, 0, 256)
    bytesRead := sd.readHandle(h1, @readBuffer, size)

    ' Now should be at EOF
    result := sd.eofHandle(h1)
    utils.evaluateSubBool(result <> 0, @"At EOF after reading all", true)

    ' Seek back - should not be at EOF
    sd.seekHandle(h1, 0)
    result := sd.eofHandle(h1)
    utils.evaluateSubBool(result == 0, @"Not at EOF after seek to 0", true)

    sd.closeFileHandle(h1)

    ' ======================================================================
    ' Cleanup and Summary
    ' ======================================================================
    cleanupTestFiles()

    sd.unmount()

    utils.ShowTestEndCounts()

    debug(" ")
    debug("END_SESSION")

PRI cleanupTestFiles()
    '' Delete all test files (ignore errors for non-existent files)
    sd.deleteFile(@testfile1)
    sd.deleteFile(@testfile2)
    sd.deleteFile(@testfile3)
    sd.deleteFile(@testfile4)
    sd.deleteFile(@testfile5)

PRI createTestFiles() | h
    '' Create test files with known content

    debug(" ")
    debug("* Creating test files...")

    ' File 1
    h := sd.createFileNew(@testfile1)
    if h >= 0
        sd.writeHandle(h, @content1, strsize(@content1))
        sd.closeFileHandle(h)
        debug("  Created: ", zstr_(@testfile1))
    else
        debug("  ERROR creating ", zstr_(@testfile1))

    ' File 2
    h := sd.createFileNew(@testfile2)
    if h >= 0
        sd.writeHandle(h, @content2, strsize(@content2))
        sd.closeFileHandle(h)
        debug("  Created: ", zstr_(@testfile2))
    else
        debug("  ERROR creating ", zstr_(@testfile2))

    ' File 3
    h := sd.createFileNew(@testfile3)
    if h >= 0
        sd.writeHandle(h, @content3, strsize(@content3))
        sd.closeFileHandle(h)
        debug("  Created: ", zstr_(@testfile3))
    else
        debug("  ERROR creating ", zstr_(@testfile3))

    ' File 4
    h := sd.createFileNew(@testfile4)
    if h >= 0
        sd.writeHandle(h, @content4, strsize(@content4))
        sd.closeFileHandle(h)
        debug("  Created: ", zstr_(@testfile4))
    else
        debug("  ERROR creating ", zstr_(@testfile4))

    debug("* Test files created")
    debug(" ")

PRI strncmp(p1, p2, n) : match | i
    '' Compare first n bytes of two strings
    match := true
    repeat i from 0 to n - 1
        if BYTE[p1][i] <> BYTE[p2][i]
            match := false
            quit

{{
=================================================================================================
=                                LICENSE MIT                                                     =
=================================================================================================
  Copyright (c) 2026 Stephen M Moraco

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
=================================================================================================
}}
