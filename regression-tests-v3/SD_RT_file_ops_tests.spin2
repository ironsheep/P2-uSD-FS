'' =================================================================================================
''
''   File....... SD_RT_file_ops_tests.spin2
''   Purpose.... This object exercises file create/open/close/delete/rename operations using V3 handle API
''   Author..... Stephen M Moraco
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... JAN 2026
''   Updated.... 29 JAN 2026
''
'' =================================================================================================
''
'' Updated for V3 handle-based API:
''   - Uses createFileNew() instead of newFile()
''   - Uses openFileRead() / openFileWrite() instead of openFile()
''   - Uses closeFileHandle(handle) instead of closeFile()
''   - Uses writeHandle() / readHandle() instead of writeString() / readString()
''
'' =================================================================================================

CON

     _CLKFREQ        = 320_000_000

     ' Pin configuration for P2 Edge with SD card
     SD_CS   = 60
     SD_MOSI = 59
     SD_MISO = 58
     SD_SCK  = 61

     ' V3 Error codes
     E_FILE_EXISTS     = -41
     E_FILE_NOT_FOUND  = -40

OBJ
    sd    : "SD_card_driver_v3"
    utils : "SD_RT_utilities"

DAT

' Test filenames - use unique names to avoid conflicts
testfile1       BYTE    "RTFILE1.TXT", 0
testfile2       BYTE    "RTFILE2.BIN", 0
testfile3       BYTE    "RTFILE3.DAT", 0
renamedFile     BYTE    "RENAMED.TXT", 0
testContent1    BYTE    "Hello, SD Card!", 0
testContent2    BYTE    "This is test content for file operations.", 0

readBuffer      BYTE    0[128]
sectorBuffer    BYTE    0[512]        ' For reading raw sectors during diagnostics

PUB go() | result, handle, h1, h2, h3, pFilename, fileSize, attrs, bytesWritten, bytesRead, root_sec, i, pEntry, d_sec, d_buftype, d_token, d_b0, d_b1, d_b2, d_b3, d_pbuf, d_bef0, d_bef1, d_bef2, d_bef3, d_spi

    debug(" ")
    debug("==============================================")
    debug("  SD Card Driver V3 - File Operations Tests")
    debug("  (Using Handle-Based API)")
    debug("==============================================")

    ' Mount the card first
    result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    if result == false
        debug("ERROR: Could not mount SD card!")
        debug("END_SESSION")
        return

    ' Show card info
    debug(" ")
    debug("* SD Card Information:")
    debug("   Volume Label: ", zstr_(sd.volumeLabel()))

    ' Show FAT32 geometry for verification
    debug("   VBR sector: ", udec_(sd.debugGetVbrSec()))
    debug("   FAT sector: ", udec_(sd.debugGetFatSec()))
    debug("   Sec/FAT: ", udec_(sd.debugGetSecPerFat()))
    debug("   Root sec: ", udec_(sd.debugGetRootSec()))

    ' WORKAROUND: Clear corrupted root directory if detected
    debug("  CLEARING ROOT DIRECTORY...")
    result := sd.debugClearRootDir()
    debug("  Clear result: ", sdec_(result))

    ' EARLY DIAGNOSTIC: Test multiple sectors to find pattern
    debug("  EARLY-DIAG: Testing sector reads...")
    ' Test sectors: 0, 1, 10, 100, 1000, then root_sec
    repeat i from 0 to 5
        case i
            0: root_sec := 0
            1: root_sec := 1
            2: root_sec := 10
            3: root_sec := 100
            4: root_sec := 1000
            5: root_sec := sd.debugGetRootSec()
        bytefill(@sectorBuffer, $EE, 512)
        result := sd.readSectorRaw(root_sec, @sectorBuffer)
        debug("  Sector ", udec_(root_sec), ": $", uhex_byte_(sectorBuffer[0]), " $", uhex_byte_(sectorBuffer[1]), " $", uhex_byte_(sectorBuffer[2]), " $", uhex_byte_(sectorBuffer[3]))
        ' For high sectors, also show internal diagnostic data
        if root_sec > 30000
            sd.debugGetReadSectorDiag(@d_sec, @d_buftype, @d_token, @d_b0, @d_b1, @d_b2, @d_b3, @d_pbuf)
            sd.debugGetReadSectorDiagExt(@d_bef0, @d_bef1, @d_bef2, @d_bef3, @d_spi)
            debug("    DIAG: sec=", udec_(d_sec), " buftype=", udec_(d_buftype), " token=$", uhex_byte_(d_token))
            debug("    DIAG: p_buf=$", uhex_long_(d_pbuf), " BEFORE: $", uhex_byte_(d_bef0), " $", uhex_byte_(d_bef1), " $", uhex_byte_(d_bef2), " $", uhex_byte_(d_bef3))
            debug("    DIAG: STREAMER: $", uhex_byte_(d_b0), " $", uhex_byte_(d_b1), " $", uhex_byte_(d_b2), " $", uhex_byte_(d_b3), " spi_period=", udec_(d_spi))
            ' Now read same sector using slow byte-by-byte method for comparison
            bytefill(@sectorBuffer, $DD, 512)
            result := sd.debugReadSectorSlow(root_sec, @sectorBuffer)
            debug("    DIAG: SLOW READ: $", uhex_byte_(sectorBuffer[0]), " $", uhex_byte_(sectorBuffer[1]), " $", uhex_byte_(sectorBuffer[2]), " $", uhex_byte_(sectorBuffer[3]), " result=", sdec_(result))
            ' Dump first 64 bytes (2 directory entries) to understand structure
            debug("    DIAG: Entry0 (0-31): [", lstr_(@sectorBuffer, 11), "] attr=$", uhex_byte_(sectorBuffer[11]))
            debug("    DIAG: Entry1 (32-63): [", lstr_(@sectorBuffer + 32, 11), "] attr=$", uhex_byte_(sectorBuffer[32+11]))

    debug("   Free Space: ", udec(sd.freeSpace()), " sectors")

    ' ----------------------------------
    ' TEST GROUP: File creation with handles
    ' ----------------------------------
    utils.startTestGroup(@"File Creation (V3 Handle API)")

    ' Clean up any existing test files first
    sd.deleteFile(@testfile1)
    sd.deleteFile(@testfile2)
    sd.deleteFile(@testfile3)
    sd.deleteFile(@renamedFile)

    utils.startTest(@"createFileNew() returns valid handle")
    debug("  DEBUG: Creating file [", zstr_(@testfile1), "]")
    handle := sd.createFileNew(@testfile1)
    debug("  DEBUG: createFileNew returned handle=", sdec_(handle))
    utils.evaluateSubBool(handle >= 0, @"createFileNew()", true)

    ' Write content and close file (setup for other tests)
    if handle >= 0
        bytesWritten := sd.writeHandle(handle, @testContent1, strsize(@testContent1))
        debug("  Wrote ", udec_(bytesWritten), " bytes")
        result := sd.closeFileHandle(handle)
        debug("  File closed, result=", sdec_(result))
    else
        debug("  SKIP: handle invalid, skipping write/close")

    ' WORKAROUND: Force directory cache sync from Cog0
    ' This fixes an issue where searchDirectory can't find files after creation
    sd.syncDirCache()

    ' DIAGNOSTIC: Print buffer addresses
    debug("  DIAG: @sectorBuffer = $", uhex_long_(@sectorBuffer))
    debug("  DIAG: Testing basic sector read (MBR)...")
    bytefill(@sectorBuffer, $AA, 512)
    result := sd.readSectorRaw(0, @sectorBuffer)
    debug("  DIAG: readSectorRaw(0) returned ", sdec_(result))
    debug("  DIAG: MBR bytes 510-511: $", uhex_byte_(sectorBuffer[510]), " $", uhex_byte_(sectorBuffer[511]))
    if sectorBuffer[510] == $55 and sectorBuffer[511] == $AA
        debug("  DIAG: MBR signature OK!")
    else
        debug("  DIAG: MBR signature BAD - card read broken?")

    ' Try reading sector 1 (partition table area) to see if issue is sector-specific
    debug("  DIAG: Reading sector 1...")
    bytefill(@sectorBuffer, $CC, 512)
    result := sd.readSectorRaw(1, @sectorBuffer)
    debug("  DIAG: Sector 1 first bytes: $", uhex_byte_(sectorBuffer[0]), " $", uhex_byte_(sectorBuffer[1]), " $", uhex_byte_(sectorBuffer[2]), " $", uhex_byte_(sectorBuffer[3]))

    ' Now read root directory sector
    root_sec := sd.debugGetRootSec()
    debug("  DIAG: root_sec = ", udec_(root_sec), " ($", uhex_long_(root_sec), ")")
    bytefill(@sectorBuffer, $BB, 512)
    result := sd.readSectorRaw(root_sec, @sectorBuffer)
    debug("  DIAG: readSectorRaw(root) returned ", sdec_(result))
    debug("  DIAG: First 8 bytes: $", uhex_byte_(sectorBuffer[0]), " $", uhex_byte_(sectorBuffer[1]), " $", uhex_byte_(sectorBuffer[2]), " $", uhex_byte_(sectorBuffer[3]), " $", uhex_byte_(sectorBuffer[4]), " $", uhex_byte_(sectorBuffer[5]), " $", uhex_byte_(sectorBuffer[6]), " $", uhex_byte_(sectorBuffer[7]))
    ' Check if buffer was written at all
    if sectorBuffer[0] == $BB
        debug("  DIAG: Buffer NOT WRITTEN!")
    elseif sectorBuffer[0] == 0 or sectorBuffer[0] == $E5
        debug("  DIAG: Root entry is empty/deleted")
    elseif sectorBuffer[0] >= $20 and sectorBuffer[0] < $7F
        debug("  DIAG: Root entry: [", lstr_(@sectorBuffer, 11), "]")
    else
        debug("  DIAG: First byte is $", uhex_byte_(sectorBuffer[0]))

    ' Quick sanity check - verify we can reopen the file we just created
    result := sd.openFileRead(@testfile1)
    if result >= 0
        sd.closeFileHandle(result)
    else
        debug("  WARNING: File not found after close! Error=", sdec_(result))

    utils.startTest(@"createFileNew() fails if file already exists")
    debug("  DEBUG: Attempting to create same file again...")
    handle := sd.createFileNew(@testfile1)
    debug("  DEBUG: Second createFileNew returned handle=", sdec_(handle))
    utils.evaluateSingleValue(handle, @"createFileNew() on existing", E_FILE_EXISTS)

    ' ----------------------------------
    ' TEST GROUP: File open/close with handles
    ' ----------------------------------
    utils.startTestGroup(@"File Open/Close (V3 Handle API)")

    utils.startTest(@"openFileRead() opens existing file")
    handle := sd.openFileRead(@testfile1)
    utils.evaluateSubBool(handle >= 0, @"openFileRead()", true)

    utils.startTest(@"fileSizeHandle() returns correct size")
    if handle >= 0
        fileSize := sd.fileSizeHandle(handle)
        utils.evaluateSingleValue(fileSize, @"fileSizeHandle()", strsize(@testContent1))

    utils.startTest(@"readHandle() returns correct content")
    if handle >= 0
        bytefill(@readBuffer, 0, 128)
        bytesRead := sd.readHandle(handle, @readBuffer, strsize(@testContent1))
        utils.evaluateSubValue(bytesRead, @"bytesRead", strsize(@testContent1))
        utils.evaluateSubBool(strcomp(@readBuffer, @testContent1), @"content matches", true)

    utils.startTest(@"closeFileHandle() on open handle")
    if handle >= 0
        result := sd.closeFileHandle(handle)
        utils.evaluateSingleValue(result, @"closeFileHandle()", 0)

    utils.startTest(@"openFileRead() fails for non-existent file")
    handle := sd.openFileRead(@"NOEXIST.TXT")
    utils.evaluateSingleValue(handle, @"openFileRead() non-existent", E_FILE_NOT_FOUND)

    ' ----------------------------------
    ' TEST GROUP: File deletion
    ' ----------------------------------
    utils.startTestGroup(@"File Deletion")

    ' Create a file to delete
    utils.startTest(@"Create file to delete")
    handle := sd.createFileNew(@testfile2)
    utils.evaluateSubBool(handle >= 0, @"createFileNew()", true)
    if handle >= 0
        sd.writeHandle(handle, @"Delete me", 9)
        sd.closeFileHandle(handle)

    utils.startTest(@"deleteFile() removes the file")
    result := sd.deleteFile(@testfile2)
    utils.evaluateBool(result, @"deleteFile()", true)

    utils.startTest(@"Verify file is deleted (openFileRead fails)")
    handle := sd.openFileRead(@testfile2)
    utils.evaluateSingleValue(handle, @"openFileRead() after delete", E_FILE_NOT_FOUND)

    utils.startTest(@"deleteFile() fails for non-existent file")
    result := sd.deleteFile(@testfile2)
    utils.evaluateBool(result, @"deleteFile() non-existent", false)

    ' ----------------------------------
    ' TEST GROUP: File rename
    ' ----------------------------------
    utils.startTestGroup(@"File Rename")

    ' Sync directory cache before rename operations
    sd.syncDirCache()

    utils.startTest(@"rename() changes filename")
    result := sd.rename(@testfile1, @renamedFile)
    utils.evaluateBool(result, @"rename()", true)

    utils.startTest(@"Original file no longer accessible")
    handle := sd.openFileRead(@testfile1)
    utils.evaluateSingleValue(handle, @"openFileRead() old name", E_FILE_NOT_FOUND)

    utils.startTest(@"Renamed file is accessible")
    handle := sd.openFileRead(@renamedFile)
    utils.evaluateSubBool(handle >= 0, @"openFileRead() new name", true)

    utils.startTest(@"Content preserved after rename")
    if handle >= 0
        fileSize := sd.fileSizeHandle(handle)
        utils.evaluateSingleValue(fileSize, @"fileSizeHandle()", strsize(@testContent1))
        sd.closeFileHandle(handle)

    utils.startTest(@"rename() fails for non-existent source")
    result := sd.rename(@"NOFILE.TXT", @"OTHER.TXT")
    utils.evaluateBool(result, @"rename() non-existent", false)

    ' ----------------------------------
    ' TEST GROUP: Multiple file creation
    ' ----------------------------------
    utils.startTestGroup(@"Multiple File Creation")

    ' Sync directory cache before multiple file operations
    sd.syncDirCache()

    ' Create multiple files
    utils.startTest(@"Create multiple test files")
    utils.setCheckCountPerTest(3)

    handle := sd.createFileNew(@testfile1)
    utils.evaluateSubBool(handle >= 0, @"createFileNew() file1", true)
    if handle >= 0
        sd.writeHandle(handle, @"File 1 content", 14)
        sd.closeFileHandle(handle)

    handle := sd.createFileNew(@testfile2)
    utils.evaluateSubBool(handle >= 0, @"createFileNew() file2", true)
    if handle >= 0
        sd.writeHandle(handle, @"File 2 content", 14)
        sd.closeFileHandle(handle)

    handle := sd.createFileNew(@testfile3)
    utils.evaluateSubBool(handle >= 0, @"createFileNew() file3", true)
    if handle >= 0
        sd.writeHandle(handle, @"File 3 content", 14)
        sd.closeFileHandle(handle)

    utils.startTest(@"Open each file and verify accessible")
    utils.setCheckCountPerTest(3)

    handle := sd.openFileRead(@testfile1)
    utils.evaluateSubBool(handle >= 0, @"openFileRead() file1", true)
    if handle >= 0
        sd.closeFileHandle(handle)

    handle := sd.openFileRead(@testfile2)
    utils.evaluateSubBool(handle >= 0, @"openFileRead() file2", true)
    if handle >= 0
        sd.closeFileHandle(handle)

    handle := sd.openFileRead(@testfile3)
    utils.evaluateSubBool(handle >= 0, @"openFileRead() file3", true)
    if handle >= 0
        sd.closeFileHandle(handle)

    ' ----------------------------------
    ' TEST GROUP: Multiple simultaneous handles
    ' ----------------------------------
    utils.startTestGroup(@"Multiple Simultaneous Handles")

    utils.startTest(@"Open all 3 files simultaneously")
    h1 := sd.openFileRead(@testfile1)
    h2 := sd.openFileRead(@testfile2)
    h3 := sd.openFileRead(@testfile3)

    utils.evaluateSubBool(h1 >= 0, @"handle 1 valid", true)
    utils.evaluateSubBool(h2 >= 0, @"handle 2 valid", true)
    utils.evaluateSubBool(h3 >= 0, @"handle 3 valid", true)
    utils.evaluateSubBool(h1 <> h2 and h2 <> h3, @"handles unique", true)

    utils.startTest(@"Read from all 3 and verify correct data")
    utils.setCheckCountPerTest(3)

    if h1 >= 0
        bytefill(@readBuffer, 0, 128)
        bytesRead := sd.readHandle(h1, @readBuffer, 14)
        utils.evaluateSubBool(strcomp(@readBuffer, @"File 1 content"), @"file1 content", true)

    if h2 >= 0
        bytefill(@readBuffer, 0, 128)
        bytesRead := sd.readHandle(h2, @readBuffer, 14)
        utils.evaluateSubBool(strcomp(@readBuffer, @"File 2 content"), @"file2 content", true)

    if h3 >= 0
        bytefill(@readBuffer, 0, 128)
        bytesRead := sd.readHandle(h3, @readBuffer, 14)
        utils.evaluateSubBool(strcomp(@readBuffer, @"File 3 content"), @"file3 content", true)

    ' Close all handles
    if h1 >= 0
        sd.closeFileHandle(h1)
    if h2 >= 0
        sd.closeFileHandle(h2)
    if h3 >= 0
        sd.closeFileHandle(h3)

    ' ----------------------------------
    ' Cleanup: Delete test files
    ' ----------------------------------
    debug(" ")
    debug("* Cleaning up test files...")
    sd.deleteFile(@testfile1)
    sd.deleteFile(@testfile2)
    sd.deleteFile(@testfile3)
    sd.deleteFile(@renamedFile)

    ' Unmount
    sd.unmount()

    ' ----------------------------------
    ' Summary
    ' ----------------------------------
    utils.ShowTestEndCounts()

    debug(" ")
    debug("* File Operations Tests Complete (V3 Handle API)")
    debug("END_SESSION")


con { license }

{{
  =================================================================================================

  Terms of Use: MIT License

  Copyright (c) 2026 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

  =================================================================================================
}}
