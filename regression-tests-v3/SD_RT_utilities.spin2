'' =================================================================================================
''
''   File....... SD_RT_utilities.spin2
''   Purpose.... This object provides commonly used regression test parts for SD card driver tests
''   Author..... Stephen M Moraco
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... JAN 2026
''   Updated.... 16 JAN 2026
''
'' =================================================================================================

CON

  TEST_SIGNATURE = $12345678

  ' Pin configuration for P2 Edge with SD card
  SD_CS   = 60
  SD_MOSI = 59
  SD_MISO = 58
  SD_SCK  = 61

VAR { test stats vars }

  LONG    numberTests
  LONG    subTestPer
  LONG    passCount
  LONG    failCount
  LONG    passCountSub
  LONG    failCountSub

  LONG    varSignature

  byte    filename[128]

pub null()

'' This is not an application
''  (invoke mount() to use the SD filesystem)

pri initIfNotAlready()
    if varSignature <> TEST_SIGNATURE
        numberTests := 0
        subTestPer := 1
        passCount := 0
        failCount := 0
        passCountSub := 0
        failCountSub := 0
        varSignature := TEST_SIGNATURE
        debug("* init VAR")

pub startTestGroup(pDescription)
    ' show test-group heading

    initIfNotAlready()
    showSubTestResults()

    debug(" ")  ' blank line
    debug(" ")  ' blank line
    debug(" ------------------------------------------------------------")
    debug("* Test Group: ", zstr_(pDescription))

pub startTest(pDescription) | ecGot, ecExpected, passScaled, failScaled, total
    ' if prior sub tests show sub tests results

    initIfNotAlready()
    showSubTestResults()

    numberTests++
    '  now show new test info
    debug(" ")  ' blank line
    debug("* Test #", udec_(numberTests), ": ", zstr_(pDescription))


pub showSubTestResults() | passScaled, failScaled, total, pPassFail
    if failCountSub <> 0 or passCountSub <> 0
        total := (passCountSub + failCountSub) / subTestPer
        passScaled := passCountSub / subTestPer
        failScaled := total - passScaled
        debug("  Sub-Test Results: count=", udec_(total), ", Pass: ", udec_(passScaled), ", Fail: ", udec_(failScaled))
        if failScaled < 0
          debug("  Sub-Test (", udec(passCountSub, failCountSub), ")")

        if failCountSub <> 0
            failCount++
        else
            passCount++
        pPassFail := failCountSub <> 0 ? @"FAIL" : @"pass"
        debug("   -> ", zstr_(pPassFail))
        passCountSub := 0
        failCountSub := 0


pub ShowTestEndCounts() | pMsg
    ' show summary of all tests
    showSubTestResults()  ' flush any pending sub-tests

    debug(" ")  ' blank line
    debug(" ============================================================")
    debug("* ", udec_(numberTests), " Tests - Pass: ", udec_(passCount), ", Fail: ", udec_(failCount))
    if numberTests <> passCount + failCount
      pMsg := (numberTests > passCount + failCount) ? @"missing" : @"extra"
      debug("*  BAD TEST COUNTS: ", udec_(numberTests), " <> ", udec_(passCount + failCount), " (", zstr_(pMsg), " ", udec_(abs(numberTests - (passCount + failCount))), " tests)")
    debug(" ============================================================")


pub setCheckCountPerTest(countTests)

'' set the number of subtests per record/group
''
'' @param countTests - the number of checks per item tested

  subTestPer := countTests

pub evaluateSubValue(result, pMessage, expectedResult) | bPassed, pPassFail
'' Evaluate a sub-test value (for multiple checks within a test)
    bPassed := result == expectedResult
    pPassFail := !bPassed ? @"Sub-FAIL" : @"pass"
    ifnot bPassed
        failCountSub++
    else
        passCountSub++
    ifnot bPassed               ' only show result on failure
        debug("  Sub-Test: ", zstr_(pMessage))
        debug("  Value: ", sdec_long_(result), " (expected ", sdec_long_(expectedResult), ")")
        debug("   -> ", zstr_(pPassFail))

pub evaluateSubValueHex(result, pMessage, expectedResult) | bPassed, pPassFail
'' Evaluate a sub-test value in hex format
    bPassed := result == expectedResult
    pPassFail := !bPassed ? @"Sub-FAIL" : @"pass"
    ifnot bPassed
        failCountSub++
    else
        passCountSub++
    ifnot bPassed               ' only show result on failure
        debug("  Sub-Test: ", zstr_(pMessage))
        debug("  Value: $", uhex_long_(result), " (expected $", uhex_long_(expectedResult), ")")
        debug("   -> ", zstr_(pPassFail))

pub evaluateSubBool(result, pMessage, expectedResult) | bPassed, pPassFail
'' Evaluate a sub-test boolean value
    bPassed := (result <> 0) == (expectedResult <> 0)
    pPassFail := !bPassed ? @"Sub-FAIL" : @"pass"
    ifnot bPassed
        failCountSub++
    else
        passCountSub++
    ifnot bPassed               ' only show result on failure
        debug("  Sub-Test: ", zstr_(pMessage))
        debug("  Value: ", udec_(result <> 0), " (expected ", udec_(expectedResult <> 0), ")")
        debug("   -> ", zstr_(pPassFail))


pub evaluateBool(result, pMessage, expectedResult) | bPassed, pPassFail
'' Evaluate a boolean result (true/false)
    bPassed := (result <> 0) == (expectedResult <> 0)
    pPassFail := !bPassed ? @"FAIL" : @"pass"
    ifnot bPassed
        debug("  ", zstr_(pMessage), ": ", udec_(result <> 0), " (expected ", udec_(expectedResult <> 0), ")")
        failCount++
    else
        debug("  ", zstr_(pMessage), ": ", udec_(result <> 0))
        passCount++
    debug("   -> ", zstr_(pPassFail))


pub recordPass()
'' Record a pass for a test that doesn't use evaluate functions
'' Use after startTest() when the test verifies success implicitly
    initIfNotAlready()
    passCount++
    debug("   -> pass")

pub recordFail()
'' Record a fail for a test that doesn't use evaluate functions
    initIfNotAlready()
    failCount++
    debug("   -> FAIL")


pub evaluateSingleValue(result, pMessage, expectedResult) | bPassed, pPassFail
'' Evaluate a single test result value
    bPassed := result == expectedResult
    pPassFail := !bPassed ? @"FAIL" : @"pass"
    ifnot bPassed
        debug("  ", zstr_(pMessage), ": ", sdec_long_(result), " (expected ", sdec_long_(expectedResult), ")")
        failCount++
    else
        debug("  ", zstr_(pMessage), ": ", sdec_long_(result))
        passCount++
    debug("   -> ", zstr_(pPassFail))

pub evaluateSingleValueHex(result, pMessage, expectedResult) | bPassed, pPassFail
'' Evaluate a single test result value in hex
    bPassed := result == expectedResult
    pPassFail := !bPassed ? @"FAIL" : @"pass"
    ifnot bPassed
        debug("  ", zstr_(pMessage), ": $", uhex_long_(result), " (expected $", uhex_long_(expectedResult), ")")
        failCount++
    else
        debug("  ", zstr_(pMessage), ": $", uhex_long_(result))
        passCount++
    debug("   -> ", zstr_(pPassFail))

pub evaluateRange(result, pMessage, minExpected, maxExpected) | bPassed, pPassFail
'' Evaluate that result is within a range
    bPassed := result >= minExpected and result <= maxExpected
    pPassFail := !bPassed ? @"FAIL" : @"pass"
    ifnot bPassed
        debug("  ", zstr_(pMessage), ": ", sdec_long_(result), " (expected ", sdec_long_(minExpected), " to ", sdec_long_(maxExpected), ")")
        failCount++
    else
        debug("  ", zstr_(pMessage), ": ", sdec_long_(result))
        passCount++
    debug("   -> ", zstr_(pPassFail))

pub evaluateNotZero(result, pMessage) | bPassed, pPassFail
'' Evaluate that result is not zero
    bPassed := result <> 0
    pPassFail := !bPassed ? @"FAIL" : @"pass"
    ifnot bPassed
        debug("  ", zstr_(pMessage), ": ", sdec_long_(result), " (expected non-zero)")
        failCount++
    else
        debug("  ", zstr_(pMessage), ": ", sdec_long_(result))
        passCount++
    debug("   -> ", zstr_(pPassFail))

pub evaluateStringMatch(pResult, pMessage, pExpected) | bPassed, pPassFail
'' Evaluate that two strings match
    bPassed := strcomp(pResult, pExpected)
    pPassFail := !bPassed ? @"FAIL" : @"pass"
    ifnot bPassed
        debug("  ", zstr_(pMessage), ": [", zstr_(pResult), "] (expected [", zstr_(pExpected), "])")
        failCount++
    else
        debug("  ", zstr_(pMessage), ": [", zstr_(pResult), "]")
        passCount++
    debug("   -> ", zstr_(pPassFail))

pub evaluateBufferMatch(pBuffer1, pBuffer2, length, pMessage) | bPassed, pPassFail, idx, mismatchIdx
'' Evaluate that two buffers match
    bPassed := true
    mismatchIdx := -1
    repeat idx from 0 to length - 1
        if BYTE[pBuffer1][idx] <> BYTE[pBuffer2][idx]
            bPassed := false
            mismatchIdx := idx
            quit
    pPassFail := !bPassed ? @"FAIL" : @"pass"
    ifnot bPassed
        debug("  ", zstr_(pMessage), ": mismatch at offset ", udec_(mismatchIdx))
        debug("    Got: $", uhex_(BYTE[pBuffer1][mismatchIdx]), " Expected: $", uhex_(BYTE[pBuffer2][mismatchIdx]))
        failCount++
    else
        debug("  ", zstr_(pMessage), ": ", udec_(length), " bytes match")
        passCount++
    debug("   -> ", zstr_(pPassFail))


pub showError(pCaller, bResult)
'' Display an error message
    if bResult == false
        debug("ERROR: ", zstr_(pCaller), " failed!")
    else
        debug("OK: ", zstr_(pCaller), " succeeded")


' -------
' Memory dump utilities

pub dbgMemDump(pMessage, pBytes, lenBytes) | rowCount, rowLen, pCurrByte, lastRowByteCount, bytesSoFar, offset

    if pMessage
        debug("** ", zstr_(pMessage), ":")

    offset := 0
    rowCount := lenBytes / 16
    lastRowByteCount := lenBytes - (rowCount * 16)
    pCurrByte := pBytes
    bytesSoFar := 0

    ' emit full lines
    if rowCount > 0
        repeat rowCount
            dbgMemDumpRow(pCurrByte, 16, offset)
            offset += 16
            pCurrByte += 16
            bytesSoFar += 16

    if  bytesSoFar < lenBytes
        ' emit last line
        dbgMemDumpRow(pCurrByte, lastRowByteCount, offset)

pri dbgMemDumpRow(pBytes, lenBytes, offset)
' emit address followed by bytes
    debug(" ", uhex_long_(offset), ": ", uhex_byte_array_(pBytes, lenBytes))


' -------
' Test data generation utilities

pub fillBufferWithPattern(pBuffer, length, startValue) | idx
'' Fill buffer with incrementing pattern
    repeat idx from 0 to length - 1
        BYTE[pBuffer][idx] := (startValue + idx) & $FF

pub fillBufferWithValue(pBuffer, length, value) | idx
'' Fill buffer with constant value
    bytefill(pBuffer, value, length)

pub fillBufferWithRandom(pBuffer, length) | idx
'' Fill buffer with random values
    repeat idx from 0 to length - 1
        BYTE[pBuffer][idx] := getrnd() & $FF

pub verifyBufferPattern(pBuffer, length, startValue) : bMatch | idx, expected
'' Verify buffer contains incrementing pattern, returns true if match
    bMatch := true
    repeat idx from 0 to length - 1
        expected := (startValue + idx) & $FF
        if BYTE[pBuffer][idx] <> expected
            bMatch := false
            debug("  Pattern mismatch at ", udec_(idx), ": got $", uhex_(BYTE[pBuffer][idx]), " expected $", uhex_(expected))
            quit

pub verifyBufferValue(pBuffer, length, value) : bMatch | idx
'' Verify buffer contains constant value, returns true if match
    bMatch := true
    repeat idx from 0 to length - 1
        if BYTE[pBuffer][idx] <> value
            bMatch := false
            debug("  Value mismatch at ", udec_(idx), ": got $", uhex_(BYTE[pBuffer][idx]), " expected $", uhex_(value))
            quit


con { license }

{{
  =================================================================================================

  Terms of Use: MIT License

  Copyright (c) 2026 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  =================================================================================================
}}
