'' =================================================================================================
''
''   File....... SD_RT_format_tests.spin2
''   Purpose.... Regression tests for SD card FAT32 formatter - Cross-OS Compatibility
''   Author..... Stephen M Moraco
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... JAN 2026
''   Updated.... 16 JAN 2026
''
'' =================================================================================================
''
''  This test formats a blank SD card and verifies the FAT32 structure is correct for
''  cross-OS compatibility (Windows, macOS, Linux).
''
''  REQUIREMENTS:
''    - A BLANK SD card (all data will be erased!)
''    - Card must be at least 64MB for FAT32
''
''  WARNING: This test ERASES ALL DATA on the card!
''
'' =================================================================================================

CON

    _CLKFREQ        = 320_000_000

    ' Pin configuration for P2 Edge with SD card
    SD_CS   = 60
    SD_MOSI = 59
    SD_MISO = 58
    SD_SCK  = 61

    ' Expected FAT32 constants
    MBR_SIGNATURE       = $AA55
    PARTITION_TYPE_FAT32_LBA = $0C
    FSINFO_SIG1         = $41615252  ' "RRaA"
    FSINFO_SIG2         = $61417272  ' "rrAa"
    FSINFO_TRAIL_SIG    = $AA550000  ' Trail signature (stored little-endian)
    FAT32_MEDIA_TYPE    = $F8        ' Fixed disk
    EXT_BOOT_SIG        = $29        ' Extended boot signature
    PARTITION_START     = 8192       ' 4MB alignment

OBJ

    utils : "SD_RT_utilities"
    fmt   : "SD_format_utility"
    sd    : "SD_card_driver_v2"

VAR

    BYTE    buf[512]
    BYTE    buf2[512]
    LONG    sectorsPerFat
    LONG    totalSectors
    LONG    partitionStart

PUB go() | result, dataStart, fat1Start, fat2Start, idx, mismatch, cardSectors

    debug("==============================================")
    debug("  SD_RT_format_tests - FAT32 Format Tests")
    debug("  (Cross-OS Compatibility Verification)")
    debug("==============================================")
    debug(" ")
    debug("WARNING: This test will ERASE ALL DATA on the card!")
    debug(" ")

    ' ----------------------------------------
    ' TEST 1: Format card with default label
    ' ----------------------------------------
    utils.startTestGroup(@"Format Operation")
    utils.startTest(@"Format card with default label")

    result := fmt.format(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    utils.evaluateBool(result, @"format() returns true", true)

    ' Initialize card for raw access
    result := sd.initCardOnly(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    if result == false
        debug("ERROR: Cannot initialize card for verification!")
        debug("END_SESSION")
        return

    cardSectors := sd.cardSizeSectors()
    debug("  Card size: ", udec(cardSectors), " sectors (", udec(cardSectors / 2048), " MB)")

    ' ========================================
    ' MBR VERIFICATION (Sector 0)
    ' ========================================
    utils.startTestGroup(@"MBR Verification")

    sd.readSectorRaw(0, @buf)

    utils.startTest(@"MBR boot signature")
    result := WORD[@buf + $1FE]
    utils.evaluateBool(result == MBR_SIGNATURE, @"$AA55 at offset $1FE", true)

    utils.startTest(@"Partition 1 bootable flag")
    result := buf[$1BE]
    utils.evaluateBool(result == $00 OR result == $80, @"$00 or $80", true)

    utils.startTest(@"Partition 1 type")
    result := buf[$1C2]
    utils.evaluateBool(result == PARTITION_TYPE_FAT32_LBA, @"$0C (FAT32 LBA)", true)

    utils.startTest(@"Partition 1 start sector")
    partitionStart := LONG[@buf + $1C6]
    utils.evaluateBool(partitionStart == PARTITION_START, @"8192 (4MB aligned)", true)

    utils.startTest(@"Partition 1 size")
    result := LONG[@buf + $1CA]
    ' Partition size should be card size minus partition start
    utils.evaluateBool(result > 0, @"Size > 0", true)
    debug("  Partition size: ", udec(result), " sectors")

    ' ========================================
    ' VBR VERIFICATION (Primary Boot Sector)
    ' ========================================
    utils.startTestGroup(@"VBR Verification")

    sd.readSectorRaw(partitionStart, @buf)

    utils.startTest(@"VBR jump instruction")
    ' Must start with $EB xx $90 or $E9 xx xx
    result := buf[0]
    utils.evaluateBool(result == $EB OR result == $E9, @"Jump ($EB or $E9)", true)

    utils.startTest(@"VBR boot signature")
    result := WORD[@buf + $1FE]
    utils.evaluateBool(result == MBR_SIGNATURE, @"$AA55 at offset $1FE", true)

    utils.startTest(@"OEM name present")
    ' OEM name at offset $03, should be printable ASCII
    result := buf[$03]
    utils.evaluateBool(result >= $20 AND result <= $7E, @"Printable OEM name", true)
    debug("  OEM name: ", lstr_(@buf + $03, 8))

    utils.startTest(@"Bytes per sector")
    result := WORD[@buf + $0B]
    utils.evaluateBool(result == 512, @"512 bytes/sector", true)

    utils.startTest(@"Sectors per cluster")
    result := buf[$0D]
    ' Must be power of 2: 1, 2, 4, 8, 16, 32, 64, 128
    utils.evaluateBool(result >= 1 AND result <= 128 AND (result & (result - 1)) == 0, @"Power of 2", true)
    debug("  Sectors per cluster: ", udec(result))

    utils.startTest(@"Reserved sectors")
    result := WORD[@buf + $0E]
    utils.evaluateBool(result == 32, @"32 reserved sectors", true)

    utils.startTest(@"Number of FATs")
    result := buf[$10]
    utils.evaluateBool(result == 2, @"2 FATs", true)

    utils.startTest(@"Root entry count (must be 0 for FAT32)")
    result := WORD[@buf + $11]
    utils.evaluateBool(result == 0, @"0 (FAT32 requirement)", true)

    utils.startTest(@"Total sectors 16-bit (must be 0 for FAT32)")
    result := WORD[@buf + $13]
    utils.evaluateBool(result == 0, @"0 (FAT32 uses 32-bit)", true)

    utils.startTest(@"Media type")
    result := buf[$15]
    utils.evaluateBool(result == FAT32_MEDIA_TYPE, @"$F8 (fixed disk)", true)

    utils.startTest(@"FAT size 16-bit (must be 0 for FAT32)")
    result := WORD[@buf + $16]
    utils.evaluateBool(result == 0, @"0 (FAT32 uses 32-bit)", true)

    utils.startTest(@"Hidden sectors match partition start")
    result := LONG[@buf + $1C]
    utils.evaluateBool(result == partitionStart, @"Matches partition start", true)

    utils.startTest(@"Total sectors 32-bit")
    totalSectors := LONG[@buf + $20]
    utils.evaluateBool(totalSectors > 0, @"Total sectors > 0", true)
    debug("  Total sectors: ", udec(totalSectors))

    utils.startTest(@"FAT32 sectors per FAT")
    sectorsPerFat := LONG[@buf + $24]
    utils.evaluateBool(sectorsPerFat > 0, @"Sectors per FAT > 0", true)
    debug("  Sectors per FAT: ", udec(sectorsPerFat))

    utils.startTest(@"Root cluster number")
    result := LONG[@buf + $2C]
    utils.evaluateBool(result == 2, @"Root cluster = 2", true)

    utils.startTest(@"FSInfo sector location")
    result := WORD[@buf + $30]
    utils.evaluateBool(result == 1, @"FSInfo at sector 1", true)

    utils.startTest(@"Backup boot sector location")
    result := WORD[@buf + $32]
    utils.evaluateBool(result == 6, @"Backup at sector 6", true)

    utils.startTest(@"Extended boot signature")
    result := buf[$42]
    utils.evaluateBool(result == EXT_BOOT_SIG, @"$29", true)

    utils.startTest(@"File system type string")
    ' At offset $52, should be "FAT32   " (8 bytes)
    result := true
    if buf[$52] <> "F" OR buf[$53] <> "A" OR buf[$54] <> "T" OR buf[$55] <> "3" OR buf[$56] <> "2"
        result := false
    utils.evaluateBool(result, @"FAT32 string at $52", true)
    debug("  FS Type: ", lstr_(@buf + $52, 8))

    ' ========================================
    ' BACKUP VBR VERIFICATION
    ' ========================================
    utils.startTestGroup(@"Backup VBR Verification")

    utils.startTest(@"Backup VBR matches primary")
    ' Read backup boot sector at partition + 6
    sd.readSectorRaw(partitionStart + 6, @buf2)

    ' Compare the two boot sectors
    mismatch := false
    repeat idx from 0 to 511
        if buf[idx] <> buf2[idx]
            mismatch := true
            debug("  Mismatch at offset ", udec(idx), ": $", uhex_(buf[idx]), " vs $", uhex_(buf2[idx]))
            quit
    utils.evaluateBool(mismatch == false, @"Primary and backup match", true)

    ' ========================================
    ' FSINFO VERIFICATION
    ' ========================================
    utils.startTestGroup(@"FSInfo Verification")

    sd.readSectorRaw(partitionStart + 1, @buf)

    utils.startTest(@"FSInfo lead signature")
    result := LONG[@buf + 0]
    utils.evaluateBool(result == FSINFO_SIG1, @"$41615252 (RRaA)", true)

    utils.startTest(@"FSInfo structure signature")
    result := LONG[@buf + 484]
    utils.evaluateBool(result == FSINFO_SIG2, @"$61417272 (rrAa)", true)

    utils.startTest(@"FSInfo trail signature")
    result := LONG[@buf + $1FC]
    utils.evaluateBool(result == FSINFO_TRAIL_SIG, @"$AA550000 at $1FC", true)

    utils.startTest(@"FSInfo free cluster count")
    result := LONG[@buf + 488]
    ' Can be $FFFFFFFF (unknown) or actual count
    utils.evaluateBool(result <> 0, @"Free count set", true)
    debug("  Free clusters: ", udec(result))

    utils.startTest(@"FSInfo next free cluster hint")
    result := LONG[@buf + 492]
    ' Should be 3 (first free after root) or $FFFFFFFF (unknown)
    utils.evaluateBool(result == 3 OR result == $FFFFFFFF, @"Next free = 3 or unknown", true)
    debug("  Next free hint: ", udec(result))

    utils.startTest(@"Backup FSInfo matches primary")
    sd.readSectorRaw(partitionStart + 7, @buf2)
    mismatch := false
    repeat idx from 0 to 511
        if buf[idx] <> buf2[idx]
            mismatch := true
            quit
    utils.evaluateBool(mismatch == false, @"Primary and backup FSInfo match", true)

    ' ========================================
    ' FAT TABLE VERIFICATION
    ' ========================================
    utils.startTestGroup(@"FAT Table Verification")

    fat1Start := partitionStart + 32
    fat2Start := fat1Start + sectorsPerFat

    utils.startTest(@"FAT1 first sector entries")
    sd.readSectorRaw(fat1Start, @buf)

    ' FAT[0] = media type with high bits set
    result := LONG[@buf + 0]
    utils.evaluateBool(result == $0FFFFFF8, @"FAT[0] = $0FFFFFF8", true)

    ' FAT[1] = end of chain marker
    result := LONG[@buf + 4]
    utils.evaluateBool(result == $0FFFFFFF, @"FAT[1] = $0FFFFFFF (EOC)", true)

    ' FAT[2] = root directory end of chain
    result := LONG[@buf + 8]
    utils.evaluateBool(result == $0FFFFFFF, @"FAT[2] = $0FFFFFFF (root EOC)", true)

    ' FAT[3] onwards should be 0 (free)
    result := LONG[@buf + 12]
    utils.evaluateBool(result == 0, @"FAT[3] = 0 (free)", true)

    utils.startTest(@"FAT2 mirrors FAT1 (first sector)")
    sd.readSectorRaw(fat2Start, @buf2)
    mismatch := false
    repeat idx from 0 to 511
        if buf[idx] <> buf2[idx]
            mismatch := true
            debug("  FAT mismatch at offset ", udec(idx))
            quit
    utils.evaluateBool(mismatch == false, @"FAT1 and FAT2 identical", true)

    utils.startTest(@"FAT1 second sector is zeroed")
    sd.readSectorRaw(fat1Start + 1, @buf)
    mismatch := false
    repeat idx from 0 to 511
        if buf[idx] <> 0
            mismatch := true
            quit
    utils.evaluateBool(mismatch == false, @"All zeros", true)

    utils.startTest(@"FAT2 second sector is zeroed")
    sd.readSectorRaw(fat2Start + 1, @buf)
    mismatch := false
    repeat idx from 0 to 511
        if buf[idx] <> 0
            mismatch := true
            quit
    utils.evaluateBool(mismatch == false, @"All zeros", true)

    ' ========================================
    ' ROOT DIRECTORY VERIFICATION
    ' ========================================
    utils.startTestGroup(@"Root Directory Verification")

    dataStart := partitionStart + 32 + 2 * sectorsPerFat
    debug("  Data region starts at sector ", udec(dataStart))

    sd.readSectorRaw(dataStart, @buf)

    utils.startTest(@"Volume label entry present")
    ' First entry should be volume label
    result := buf[$0B]
    utils.evaluateBool(result == $08, @"Attr = $08 (volume label)", true)

    utils.startTest(@"Volume label name")
    debug("  Volume label: ", lstr_(@buf, 11))
    ' Check first char is printable
    result := buf[0]
    utils.evaluateBool(result >= $20 AND result <= $7E, @"Valid label chars", true)

    utils.startTest(@"Second entry is end marker or empty")
    result := buf[$20]
    ' Should be $00 (end) or another valid entry
    utils.evaluateBool(result == $00 OR result == $E5 OR (result >= $20 AND result <= $7E), @"Valid second entry", true)

    utils.startTest(@"Rest of root cluster is zeroed")
    mismatch := false
    repeat idx from $40 to 511  ' Start after possible 2nd entry
        if buf[idx] <> 0
            mismatch := true
            quit
    utils.evaluateBool(mismatch == false, @"Remaining bytes zero", true)

    ' ========================================
    ' MOUNT AND USABILITY TEST
    ' ========================================
    utils.startTestGroup(@"Mount and Usability")

    utils.startTest(@"Mount formatted card")
    result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    utils.evaluateBool(result, @"mount() succeeds", true)

    utils.startTest(@"Read volume label")
    debug("  Mounted volume: ", zstr_(sd.volumeLabel()))
    result := sd.volumeLabel()
    utils.evaluateBool(result <> 0, @"Label pointer valid", true)

    utils.startTest(@"Check free space reported")
    result := sd.freeSpace()
    utils.evaluateBool(result > 0, @"Free space > 0", true)
    debug("  Free space: ", udec(result), " sectors")

    sd.unmount()

    ' ----------------------------------------
    ' Summary
    ' ----------------------------------------
    utils.ShowTestEndCounts()

    debug(" ")
    debug("END_SESSION")

CON { license }

{{
  =================================================================================================

  Terms of Use: MIT License

  Copyright (c) 2026 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  =================================================================================================
}}
