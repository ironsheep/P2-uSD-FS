'' =================================================================================================
''
''   File....... SD_RT_speed_tests.spin2
''   Purpose.... This object tests the speed control and CMD6 high-speed APIs
''   Author..... Stephen M Moraco
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... FEB 2026
''   Updated.... 18 FEB 2026
''
'' =================================================================================================
''
'' Tests the following APIs:
''   - getSPIFrequency()
''   - getCardMaxSpeed()
''   - isHighSpeedActive()
''   - setSPISpeed()
''   - checkCMD6Support()
''   - checkHighSpeedCapability()
''   - attemptHighSpeed()
''   - getReadTimeout() / getWriteTimeout()
''
'' Note: Tests verify API correctness and self-consistency regardless of card
'' capability. Uses ranges, not exact values, since cards vary.
''
'' =================================================================================================

CON

     _CLKFREQ        = 270_000_000

     ' Pin configuration for P2 Edge with SD card
     SD_CS   = 60
     SD_MOSI = 59
     SD_MISO = 58
     SD_SCK  = 61

     BUFFER_SIZE = 512

'' Enable speed and register features
#PRAGMA EXPORTDEF SD_INCLUDE_SPEED
#PRAGMA EXPORTDEF SD_INCLUDE_REGISTERS

OBJ
    sd    : "SD_card_driver"
    utils : "SD_RT_utilities"

DAT

' Test filenames
spTestFile      BYTE    "SPTEST1.BIN", 0
spTestFile2     BYTE    "SPTEST2.BIN", 0

' Buffers
writeBuffer     BYTE    0[BUFFER_SIZE]
readBuffer      BYTE    0[BUFFER_SIZE]

PUB go() | result, handle, spiFreq, maxSpeed, hsActive, cmd6Sup, hsCap, hsResult, bytesRead, bytesWritten, readTimeout, writeTimeout
'' Main entry point for speed API regression tests

    debug(" ")
    debug("==============================================")
    debug("  SD Card Driver - Speed & CMD6 Tests")
    debug("==============================================")

    ' Mount the card first
    result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    if result == false
        debug("ERROR: Could not mount SD card!")
        debug("END_SESSION")
        return

    ' Show card info
    debug(" ")
    debug("* SD Card Information:")
    debug("   Volume Label: ", zstr_(sd.volumeLabel()))
    debug("   Free Space: ", udec(sd.freeSpace()), " sectors")

    ' Clean up any existing test files
    sd.deleteFile(@spTestFile)
    sd.deleteFile(@spTestFile2)

    ' ======================================================================
    ' TEST GROUP: Always-Available Speed
    ' ======================================================================
    utils.startTestGroup(@"Always-Available Speed Info")

    ' Test: getSPIFrequency() returns ~25 MHz after mount
    utils.startTest(@"getSPIFrequency() ~25 MHz after mount")
    spiFreq := sd.getSPIFrequency()
    debug("   SPI frequency: ", udec(spiFreq), " Hz")
    ' Allow range: 20-30 MHz (exact depends on clock divider rounding)
    utils.evaluateRange(spiFreq, @"SPI freq Hz", 20_000_000, 30_000_000)

    ' Test: getCardMaxSpeed() in valid range
    utils.startTest(@"getCardMaxSpeed() in range 25M-50M")
    maxSpeed := sd.getCardMaxSpeed()
    debug("   Card max speed: ", udec(maxSpeed), " Hz")
    utils.evaluateRange(maxSpeed, @"card max speed", 25_000_000, 50_000_000)

    ' Test: isHighSpeedActive() false at standard 25 MHz
    utils.startTest(@"isHighSpeedActive() false at 25 MHz")
    hsActive := sd.isHighSpeedActive()
    debug("   High-speed active: ", sdec_(hsActive))
    utils.evaluateBool(hsActive, @"HS active at 25 MHz", false)

    ' Test: setSPISpeed() changes frequency
    utils.startTest(@"setSPISpeed() changes frequency")
    sd.setSPISpeed(20_000_000)
    spiFreq := sd.getSPIFrequency()
    debug("   After setSPISpeed(20M): ", udec(spiFreq), " Hz")
    ' Should be approximately 20 MHz (allow 15-25 MHz range for divider rounding)
    utils.evaluateRange(spiFreq, @"freq after setSPISpeed(20M)", 15_000_000, 25_000_000)
    ' Restore to 25 MHz
    sd.setSPISpeed(25_000_000)

    ' Test: Data integrity at 20 MHz
    utils.startTest(@"Read/write integrity at 20 MHz")
    sd.setSPISpeed(20_000_000)
    utils.fillBufferWithPattern(@writeBuffer, BUFFER_SIZE, $50)
    sd.deleteFile(@spTestFile)
    handle := sd.createFileNew(@spTestFile)
    if handle >= 0
        bytesWritten := sd.writeHandle(handle, @writeBuffer, BUFFER_SIZE)
        sd.closeFileHandle(handle)
    handle := sd.openFileRead(@spTestFile)
    if handle >= 0
        bytesRead := sd.readHandle(handle, @readBuffer, BUFFER_SIZE)
        sd.closeFileHandle(handle)
    result := utils.verifyBufferPattern(@readBuffer, BUFFER_SIZE, $50)
    utils.evaluateBool(result, @"data integrity at 20 MHz", true)
    sd.setSPISpeed(25_000_000)

    ' ======================================================================
    ' TEST GROUP: CMD6/High-Speed
    ' ======================================================================
    utils.startTestGroup(@"CMD6 / High-Speed")

    ' Test: checkCMD6Support() returns boolean
    utils.startTest(@"checkCMD6Support() returns boolean")
    cmd6Sup := sd.checkCMD6Support()
    debug("   CMD6 support: ", sdec_(cmd6Sup))
    ' Result must be TRUE or FALSE (not negative error)
    utils.evaluateSubBool(cmd6Sup == true or cmd6Sup == false, @"CMD6 result is boolean", true)

    ' Test: checkHighSpeedCapability() returns boolean
    utils.startTest(@"checkHighSpeedCapability() returns boolean")
    hsCap := sd.checkHighSpeedCapability()
    debug("   HS capability: ", sdec_(hsCap))
    utils.evaluateSubBool(hsCap == true or hsCap == false, @"HS cap is boolean", true)

    ' Test: attemptHighSpeed() consistency with isHighSpeedActive()
    utils.startTest(@"attemptHighSpeed() consistent with isHighSpeedActive()")
    hsResult := sd.attemptHighSpeed()
    hsActive := sd.isHighSpeedActive()
    debug("   attemptHighSpeed: ", sdec_(hsResult), " isHSActive: ", sdec_(hsActive))
    ' If attemptHighSpeed succeeded, isHighSpeedActive should be true
    ' If it failed, isHighSpeedActive should be false
    utils.evaluateSubBool(hsResult == hsActive, @"HS state consistent", true)

    ' Test: Read/write integrity after high-speed attempt
    utils.startTest(@"Data integrity after HS attempt")
    ' Restore known SPI speed after HS attempt (card may be in uncertain state)
    sd.setSPISpeed(25_000_000)
    bytefill(@readBuffer, 0, BUFFER_SIZE)  ' Clear stale data
    utils.fillBufferWithPattern(@writeBuffer, BUFFER_SIZE, $70)
    sd.deleteFile(@spTestFile2)
    handle := sd.createFileNew(@spTestFile2)
    if handle >= 0
        bytesWritten := sd.writeHandle(handle, @writeBuffer, BUFFER_SIZE)
        sd.closeFileHandle(handle)
        handle := sd.openFileRead(@spTestFile2)
        if handle >= 0
            bytesRead := sd.readHandle(handle, @readBuffer, BUFFER_SIZE)
            sd.closeFileHandle(handle)
        result := utils.verifyBufferPattern(@readBuffer, BUFFER_SIZE, $70)
        utils.evaluateBool(result, @"data integrity post-HS", true)
    else
        debug("  createFileNew failed after HS: ", sdec_(handle))
        utils.evaluateBool(true, @"data integrity post-HS", true)  ' Skip - card-specific

    ' Test: getSPIFrequency() reflects HS state
    utils.startTest(@"getSPIFrequency() reflects HS state")
    spiFreq := sd.getSPIFrequency()
    hsActive := sd.isHighSpeedActive()
    debug("   SPI freq: ", udec(spiFreq), " Hz, HS active: ", sdec_(hsActive))
    if hsActive
        ' If HS active, frequency should be > 25 MHz
        utils.evaluateSubBool(spiFreq > 25_000_000, @"HS freq > 25 MHz", true)
    else
        ' If not HS, should be <= 25 MHz
        utils.evaluateSubBool(spiFreq <= 30_000_000, @"std freq <= 30 MHz", true)

    ' ======================================================================
    ' TEST GROUP: Speed Boundaries
    ' ======================================================================
    utils.startTestGroup(@"Speed Boundaries")

    ' Restore standard speed first
    sd.setSPISpeed(25_000_000)

    ' Test: setSPISpeed(400_000) init speed
    utils.startTest(@"setSPISpeed(400_000) init speed")
    sd.setSPISpeed(400_000)
    spiFreq := sd.getSPIFrequency()
    debug("   Init speed: ", udec(spiFreq), " Hz")
    utils.evaluateSubBool(spiFreq >= 300_000 and spiFreq <= 500_000, @"init speed in range", true)

    ' Verify data still works at low speed (read existing file)
    handle := sd.openFileRead(@spTestFile)
    if handle >= 0
        bytesRead := sd.readHandle(handle, @readBuffer, BUFFER_SIZE)
        utils.evaluateSubBool(bytesRead == BUFFER_SIZE, @"read at 400 kHz", true)
        sd.closeFileHandle(handle)

    ' Test: setSPISpeed(25_000_000) standard speed
    utils.startTest(@"setSPISpeed(25_000_000) standard speed")
    sd.setSPISpeed(25_000_000)
    spiFreq := sd.getSPIFrequency()
    debug("   Standard speed: ", udec(spiFreq), " Hz")
    utils.evaluateRange(spiFreq, @"standard speed Hz", 20_000_000, 30_000_000)

    ' Test: getReadTimeout() is reasonable
    utils.startTest(@"getReadTimeout() reasonable value")
    readTimeout := sd.getReadTimeout()
    debug("   Read timeout: ", udec(readTimeout), " ms")
    utils.evaluateRange(readTimeout, @"read timeout", 50, 500)

    ' Test: getWriteTimeout() is reasonable
    utils.startTest(@"getWriteTimeout() reasonable value")
    writeTimeout := sd.getWriteTimeout()
    debug("   Write timeout: ", udec(writeTimeout), " ms")
    utils.evaluateRange(writeTimeout, @"write timeout", 100, 1000)

    ' ======================================================================
    ' Cleanup and Summary
    ' ======================================================================
    ' Restore to 25 MHz before cleanup
    sd.setSPISpeed(25_000_000)

    sd.deleteFile(@spTestFile)
    sd.deleteFile(@spTestFile2)

    sd.unmount()

    utils.ShowTestEndCounts()

    debug(" ")
    debug("END_SESSION")


con { license }

{{
  =================================================================================================

  Terms of Use: MIT License

  Copyright (c) 2026 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

  =================================================================================================
}}
