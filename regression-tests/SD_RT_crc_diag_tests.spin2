'' =================================================================================================
''
''   File....... SD_RT_crc_diag_tests.spin2
''   Purpose.... This object tests the CRC diagnostic and validation toggle APIs
''   Author..... Stephen M Moraco
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... FEB 2026
''   Updated.... 18 FEB 2026
''
'' =================================================================================================
''
'' Tests the following APIs:
''   - getCRCMatchCount()
''   - getCRCMismatchCount()
''   - getCRCRetryCount()
''   - getLastReceivedCRC()
''   - getLastCalculatedCRC()
''   - getLastSentCRC()
''   - setCRCValidation()
''   - getLastCMD13()
''   - getLastCMD13Error()
''
'' =================================================================================================

CON

     _CLKFREQ        = 270_000_000

     ' Pin configuration for P2 Edge with SD card
     SD_CS   = 60
     SD_MOSI = 59
     SD_MISO = 58
     SD_SCK  = 61

     BUFFER_SIZE = 512

'' Enable debug/diagnostic features
#PRAGMA EXPORTDEF SD_INCLUDE_DEBUG

OBJ
    sd    : "micro_sd_fat32_fs"
    utils : "isp_rt_utilities"

DAT

' Test filenames
crcTestFile     BYTE    "CRCTEST1.BIN", 0
crcTestFile2    BYTE    "CRCTEST2.BIN", 0

' Buffers
writeBuffer     BYTE    0[BUFFER_SIZE]
readBuffer      BYTE    0[BUFFER_SIZE]

PUB go() | result, handle, bytesRead, bytesWritten, matchCount, mismatchCount, retryCount, lastRecvCRC, lastCalcCRC, lastSentCRC, matchBefore, matchAfter, cmd13val, cmd13err
'' Main entry point for CRC diagnostic regression tests

    debug(" ")
    debug("==============================================")
    debug("  SD Card Driver - CRC Diagnostic Tests")
    debug("==============================================")

    ' Mount the card first
    result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    if result == false
        debug("ERROR: Could not mount SD card!")
        debug("END_SESSION")
        return

    ' Show card info
    debug(" ")
    debug("* SD Card Information:")
    debug("   Volume Label: ", zstr_(sd.volumeLabel()))
    debug("   Free Space: ", udec(sd.freeSpace()), " sectors")

    ' Clean up any existing test files
    sd.deleteFile(@crcTestFile)
    sd.deleteFile(@crcTestFile2)

    ' ======================================================================
    ' TEST GROUP: CRC Counter Initial State
    ' ======================================================================
    utils.startTestGroup(@"CRC Counter Initial State")

    ' Test: Match count > 0 after mount (mount reads sectors)
    utils.startTest(@"CRC match count > 0 after mount")
    matchCount := sd.getCRCMatchCount()
    debug("   CRC match count: ", udec(matchCount))
    utils.evaluateSubBool(matchCount > 0, @"match count > 0", true)

    ' Test: Mismatch count == 0 on healthy card
    utils.startTest(@"CRC mismatch count == 0 on healthy card")
    mismatchCount := sd.getCRCMismatchCount()
    debug("   CRC mismatch count: ", udec(mismatchCount))
    utils.evaluateSingleValue(mismatchCount, @"mismatch count", 0)

    ' Test: Retry count == 0 on healthy card
    utils.startTest(@"CRC retry count == 0 on healthy card")
    retryCount := sd.getCRCRetryCount()
    debug("   CRC retry count: ", udec(retryCount))
    utils.evaluateSingleValue(retryCount, @"retry count", 0)

    ' Test: lastReceivedCRC != 0 (mount performed reads)
    utils.startTest(@"lastReceivedCRC != 0 after mount")
    lastRecvCRC := sd.getLastReceivedCRC()
    debug("   Last received CRC: $", uhex_(lastRecvCRC))
    utils.evaluateNotZero(lastRecvCRC, @"lastReceivedCRC")

    ' ======================================================================
    ' TEST GROUP: CRC Values After Operations
    ' ======================================================================
    utils.startTestGroup(@"CRC Values After Operations")

    ' Record match count before reads
    matchBefore := sd.getCRCMatchCount()

    ' Perform a read operation to generate CRC activity
    utils.startTest(@"CRC match count increases after reads")
    utils.fillBufferWithPattern(@writeBuffer, BUFFER_SIZE, $30)
    handle := sd.createFileNew(@crcTestFile)
    if handle >= 0
        sd.writeHandle(handle, @writeBuffer, BUFFER_SIZE)
        sd.closeFileHandle(handle)
    handle := sd.openFileRead(@crcTestFile)
    if handle >= 0
        bytesRead := sd.readHandle(handle, @readBuffer, BUFFER_SIZE)
        sd.closeFileHandle(handle)

    matchAfter := sd.getCRCMatchCount()
    debug("   Match before: ", udec(matchBefore), " after: ", udec(matchAfter))
    utils.evaluateSubBool(matchAfter > matchBefore, @"match count increased", true)

    ' Test: lastCalculatedCRC != 0 after reads
    utils.startTest(@"lastCalculatedCRC != 0 after reads")
    lastCalcCRC := sd.getLastCalculatedCRC()
    debug("   Last calculated CRC: $", uhex_(lastCalcCRC))
    utils.evaluateNotZero(lastCalcCRC, @"lastCalculatedCRC")

    ' Test: lastSentCRC != 0 after write
    utils.startTest(@"lastSentCRC != 0 after write")
    lastSentCRC := sd.getLastSentCRC()
    debug("   Last sent CRC: $", uhex_(lastSentCRC))
    utils.evaluateNotZero(lastSentCRC, @"lastSentCRC")

    ' Test: Counters after unmount/remount
    utils.startTest(@"CRC counters reset after unmount/remount")
    sd.unmount()
    result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    utils.evaluateSubBool(result, @"remount succeeds", true)
    matchCount := sd.getCRCMatchCount()
    debug("   Match count after remount: ", udec(matchCount))
    ' After remount, count should be > 0 (mount reads sectors) but less than before
    utils.evaluateSubBool(matchCount > 0, @"match count > 0 after remount", true)

    ' ======================================================================
    ' TEST GROUP: setCRCValidation Toggle
    ' ======================================================================
    utils.startTestGroup(@"setCRCValidation Toggle")

    ' Test: Enable CRC validation, count increases on read
    utils.startTest(@"CRC enabled: count increases on read")
    sd.setCRCValidation(true)
    matchBefore := sd.getCRCMatchCount()
    handle := sd.openFileRead(@crcTestFile)
    if handle >= 0
        bytesRead := sd.readHandle(handle, @readBuffer, BUFFER_SIZE)
        sd.closeFileHandle(handle)
    matchAfter := sd.getCRCMatchCount()
    debug("   CRC enabled - before: ", udec(matchBefore), " after: ", udec(matchAfter))
    utils.evaluateSubBool(matchAfter > matchBefore, @"enabled: count increased", true)

    ' Test: Disable CRC validation, count unchanged on read
    utils.startTest(@"CRC disabled: count unchanged on read")
    sd.setCRCValidation(false)
    matchBefore := sd.getCRCMatchCount()
    handle := sd.openFileRead(@crcTestFile)
    if handle >= 0
        bytesRead := sd.readHandle(handle, @readBuffer, BUFFER_SIZE)
        sd.closeFileHandle(handle)
    matchAfter := sd.getCRCMatchCount()
    debug("   CRC disabled - before: ", udec(matchBefore), " after: ", udec(matchAfter))
    utils.evaluateSingleValue(matchAfter, @"disabled: count unchanged", matchBefore)

    ' Test: Reads work correctly with CRC disabled
    utils.startTest(@"Reads work with CRC disabled")
    handle := sd.openFileRead(@crcTestFile)
    if handle >= 0
        bytesRead := sd.readHandle(handle, @readBuffer, BUFFER_SIZE)
        sd.closeFileHandle(handle)
    result := utils.verifyBufferPattern(@readBuffer, BUFFER_SIZE, $30)
    utils.evaluateBool(result, @"data correct with CRC off", true)

    ' Test: Reads work after re-enabling CRC
    utils.startTest(@"Reads work after CRC re-enabled")
    sd.setCRCValidation(true)
    handle := sd.openFileRead(@crcTestFile)
    if handle >= 0
        bytesRead := sd.readHandle(handle, @readBuffer, BUFFER_SIZE)
        sd.closeFileHandle(handle)
    result := utils.verifyBufferPattern(@readBuffer, BUFFER_SIZE, $30)
    utils.evaluateBool(result, @"data correct with CRC on", true)

    ' ======================================================================
    ' TEST GROUP: CMD13 Diagnostic
    ' ======================================================================
    utils.startTestGroup(@"CMD13 Diagnostic")

    ' Test: getLastCMD13() returns valid value
    utils.startTest(@"getLastCMD13() returns valid value")
    cmd13val := sd.getLastCMD13()
    debug("   Last CMD13: $", uhex_(cmd13val))
    ' CMD13 R2 response: $0000 means no error, $FFFF means timeout
    ' Any value is valid - just check it's accessible
    utils.recordPass()

    ' Test: getLastCMD13Error() == 0 on healthy card
    utils.startTest(@"getLastCMD13Error() == 0 on healthy card")
    cmd13err := sd.getLastCMD13Error()
    debug("   Last CMD13 error: $", uhex_(cmd13err))
    utils.evaluateSingleValue(cmd13err, @"CMD13 error", 0)

    ' ======================================================================
    ' Cleanup and Summary
    ' ======================================================================

    ' Re-enable CRC validation before cleanup
    sd.setCRCValidation(true)

    sd.deleteFile(@crcTestFile)
    sd.deleteFile(@crcTestFile2)

    sd.unmount()

    utils.ShowTestEndCounts()

    debug(" ")
    debug("END_SESSION")


con { license }

{{
  =================================================================================================

  Terms of Use: MIT License

  Copyright (c) 2026 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

  =================================================================================================
}}
