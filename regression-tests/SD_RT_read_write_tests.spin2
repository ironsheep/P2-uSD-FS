'' =================================================================================================
''
''   File....... SD_RT_read_write_tests.spin2
''   Purpose.... This object exercises read/write operations with various data patterns
''   Author..... Stephen M Moraco
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... JAN 2026
''   Updated.... 16 JAN 2026
''
'' =================================================================================================

CON

     _CLKFREQ        = 320_000_000

     ' Pin configuration for P2 Edge with SD card
     SD_CS   = 60
     SD_MOSI = 59
     SD_MISO = 58
     SD_SCK  = 61

     BUFFER_SIZE = 512
     LARGE_BUFFER_SIZE = 2048

OBJ
    sd    : "SD_card_driver_v2"
    utils : "SD_RT_utilities"

DAT

' Test filenames
testBytes       BYTE    "RTBYTES.BIN", 0
testString      BYTE    "RTSTRING.TXT", 0
testLarge       BYTE    "RTLARGE.BIN", 0
testMulti       BYTE    "RTMULTI.BIN", 0
testPattern     BYTE    "RTPATTRN.BIN", 0

' Buffers
writeBuffer     BYTE    0[BUFFER_SIZE]
readBuffer      BYTE    0[BUFFER_SIZE]
largeWriteBuf   BYTE    0[LARGE_BUFFER_SIZE]
largeReadBuf    BYTE    0[LARGE_BUFFER_SIZE]

' Test strings
testStr1        BYTE    "Hello, World!", 0
testStr2        BYTE    "The quick brown fox jumps over the lazy dog.", 0
testStr3        BYTE    "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", 0

PUB go() | result, bytesRead, idx, fileSize

    debug(" ")
    debug("==============================================")
    debug("  SD Card Driver - Read/Write Tests")
    debug("==============================================")

    ' Mount the card first
    result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    if result == false
        debug("ERROR: Could not mount SD card!")
        debug("END_SESSION")
        return

    ' Show card info
    debug(" ")
    debug("* SD Card Information:")
    debug("   Volume Label: ", zstr_(sd.volumeLabel()))
    debug("   Free Space: ", udec(sd.freeSpace()), " sectors")

    ' Clean up any existing test files
    sd.deleteFile(@testBytes)
    sd.deleteFile(@testString)
    sd.deleteFile(@testLarge)
    sd.deleteFile(@testMulti)
    sd.deleteFile(@testPattern)

    ' ----------------------------------
    ' TEST GROUP: Byte-level writes
    ' ----------------------------------
    utils.startTestGroup(@"Byte-level write/read")

    utils.startTest(@"writeByte() - write 10 bytes")
    result := sd.newFile(@testBytes)
    if result
        repeat idx from 1 to 10
            sd.writeByte(idx)
        sd.closeFile()
        debug("  Wrote 10 bytes (1-10)")
        utils.recordPass()
    else
        debug("  ERROR: Could not create file")
        utils.recordFail()

    utils.startTest(@"read() - read back 10 bytes")
    result := sd.openFile(@testBytes)
    utils.evaluateBool(result, @"openFile()", true)

    utils.startTest(@"Verify byte values")
    utils.setCheckCountPerTest(10)
    bytesRead := sd.read(@readBuffer, 10)
    repeat idx from 0 to 9
        utils.evaluateSubValue(readBuffer[idx], @"byte value", idx + 1)

    utils.startTest(@"Verify file size")
    fileSize := sd.fileSize()
    utils.evaluateSingleValue(fileSize, @"fileSize()", 10)
    sd.closeFile()

    ' ----------------------------------
    ' TEST GROUP: String writes
    ' ----------------------------------
    utils.startTestGroup(@"String write/read")

    utils.startTest(@"writeString() - write test string")
    result := sd.newFile(@testString)
    utils.evaluateBool(result, @"newFile()", true)

    utils.startTest(@"Write first string")
    sd.writeString(@testStr1)
    sd.writeByte(13)  ' CR
    sd.writeByte(10)  ' LF
    debug("  Wrote: ", zstr_(@testStr1))
    utils.recordPass()

    utils.startTest(@"Write second string")
    sd.writeString(@testStr2)
    sd.writeByte(13)
    sd.writeByte(10)
    debug("  Wrote: ", zstr_(@testStr2))
    utils.recordPass()

    utils.startTest(@"Write third string")
    sd.writeString(@testStr3)
    sd.closeFile()
    debug("  Wrote: ", zstr_(@testStr3))
    utils.recordPass()

    utils.startTest(@"Read back and verify content")
    result := sd.openFile(@testString)
    utils.evaluateBool(result, @"openFile()", true)

    ' Calculate expected size
    fileSize := strsize(@testStr1) + 2 + strsize(@testStr2) + 2 + strsize(@testStr3)

    utils.startTest(@"Verify total file size")
    utils.evaluateSingleValue(sd.fileSize(), @"fileSize()", fileSize)
    sd.closeFile()

    ' ----------------------------------
    ' TEST GROUP: Buffer writes
    ' ----------------------------------
    utils.startTestGroup(@"Buffer write/read")

    ' Fill buffer with pattern
    utils.fillBufferWithPattern(@writeBuffer, 256, $A0)

    utils.startTest(@"write() - write 256 byte buffer")
    result := sd.newFile(@testPattern)
    utils.evaluateBool(result, @"newFile()", true)

    utils.startTest(@"Write buffer with pattern $A0-$FF, $00-$9F")
    sd.write(@writeBuffer, 256)
    sd.closeFile()
    debug("  Wrote 256 bytes")
    utils.recordPass()

    utils.startTest(@"Read back buffer")
    result := sd.openFile(@testPattern)
    if result
        bytesRead := sd.read(@readBuffer, 256)
        utils.evaluateSingleValue(bytesRead, @"bytes read", 256)
    else
        debug("  ERROR: Could not open file")
        utils.recordFail()

    utils.startTest(@"Verify buffer content")
    result := utils.verifyBufferPattern(@readBuffer, 256, $A0)
    utils.evaluateBool(result, @"pattern match", true)
    sd.closeFile()

    ' ----------------------------------
    ' TEST GROUP: Large file writes (multi-sector)
    ' ----------------------------------
    utils.startTestGroup(@"Multi-sector write/read")

    ' Fill large buffer with pattern
    utils.fillBufferWithPattern(@largeWriteBuf, LARGE_BUFFER_SIZE, $00)

    utils.startTest(@"Write 2KB file (4 sectors)")
    result := sd.newFile(@testLarge)
    if result
        sd.write(@largeWriteBuf, LARGE_BUFFER_SIZE)
        sd.closeFile()
        debug("  Wrote ", udec_(LARGE_BUFFER_SIZE), " bytes")
        utils.recordPass()
    else
        utils.recordFail()

    utils.startTest(@"Read back 2KB file")
    result := sd.openFile(@testLarge)
    utils.evaluateBool(result, @"openFile()", true)

    utils.startTest(@"Verify file size is 2048")
    fileSize := sd.fileSize()
    utils.evaluateSingleValue(fileSize, @"fileSize()", LARGE_BUFFER_SIZE)

    utils.startTest(@"Read and verify content")
    bytesRead := sd.read(@largeReadBuf, LARGE_BUFFER_SIZE)
    utils.evaluateSingleValue(bytesRead, @"bytes read", LARGE_BUFFER_SIZE)

    utils.startTest(@"Verify large buffer pattern")
    result := utils.verifyBufferPattern(@largeReadBuf, LARGE_BUFFER_SIZE, $00)
    utils.evaluateBool(result, @"pattern match", true)
    sd.closeFile()

    ' ----------------------------------
    ' TEST GROUP: Multiple writes to same file
    ' ----------------------------------
    utils.startTestGroup(@"Multiple writes (append behavior)")

    utils.startTest(@"Create file with first write")
    result := sd.newFile(@testMulti)
    if result
        utils.fillBufferWithValue(@writeBuffer, 100, $AA)
        sd.write(@writeBuffer, 100)
        sd.closeFile()
        debug("  Wrote 100 bytes of $AA")
        utils.recordPass()
    else
        utils.recordFail()

    utils.startTest(@"Reopen and append more data")
    ' Note: SD driver opens at end for writing
    result := sd.openFile(@testMulti)
    utils.evaluateBool(result, @"openFile()", true)

    utils.startTest(@"Verify file size after first write")
    fileSize := sd.fileSize()
    utils.evaluateSingleValue(fileSize, @"fileSize()", 100)
    sd.closeFile()

    ' ----------------------------------
    ' TEST GROUP: Write with sync
    ' ----------------------------------
    utils.startTestGroup(@"Write with sync()")

    utils.startTest(@"Create file and write data")
    sd.deleteFile(@testPattern)
    result := sd.newFile(@testPattern)
    utils.evaluateBool(result, @"newFile()", true)

    utils.startTest(@"Write first chunk")
    utils.fillBufferWithValue(@writeBuffer, 100, $11)
    sd.write(@writeBuffer, 100)
    debug("  Wrote 100 bytes of $11")
    utils.recordPass()

    utils.startTest(@"Call sync() to flush without close")
    result := sd.sync()
    utils.evaluateBool(result, @"sync()", true)

    utils.startTest(@"Write second chunk")
    utils.fillBufferWithValue(@writeBuffer, 100, $22)
    sd.write(@writeBuffer, 100)
    debug("  Wrote 100 bytes of $22")
    utils.recordPass()

    utils.startTest(@"Close file")
    sd.closeFile()
    debug("  closeFile(): completed")
    utils.recordPass()

    utils.startTest(@"Verify total file size")
    result := sd.openFile(@testPattern)
    fileSize := sd.fileSize()
    utils.evaluateSingleValue(fileSize, @"fileSize()", 200)
    sd.closeFile()

    ' ----------------------------------
    ' TEST GROUP: Edge cases
    ' ----------------------------------
    utils.startTestGroup(@"Edge cases")

    utils.startTest(@"Read 0 bytes returns 0")
    result := sd.openFile(@testPattern)
    bytesRead := sd.read(@readBuffer, 0)
    utils.evaluateSingleValue(bytesRead, @"read(0)", 0)
    sd.closeFile()

    utils.startTest(@"Read more than file size")
    result := sd.openFile(@testBytes)  ' 10 byte file
    bytesRead := sd.read(@readBuffer, 100)  ' Request 100
    utils.evaluateSingleValue(bytesRead, @"read() at EOF", 10)  ' Should get 10
    sd.closeFile()

    ' ----------------------------------
    ' Cleanup
    ' ----------------------------------
    debug(" ")
    debug("* Cleaning up test files...")
    sd.deleteFile(@testBytes)
    sd.deleteFile(@testString)
    sd.deleteFile(@testLarge)
    sd.deleteFile(@testMulti)
    sd.deleteFile(@testPattern)

    ' Unmount
    sd.unmount()

    ' ----------------------------------
    ' Summary
    ' ----------------------------------
    utils.ShowTestEndCounts()

    debug(" ")
    debug("* Read/Write Tests Complete")
    debug("END_SESSION")


con { license }

{{
  =================================================================================================

  Terms of Use: MIT License

  Copyright (c) 2026 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  =================================================================================================
}}
