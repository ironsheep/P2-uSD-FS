'' =================================================================================================
''
''   File....... SD_RT_register_tests.spin2
''   Purpose.... This object tests CSD register access and timeout value APIs
''   Author..... Stephen M Moraco
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... FEB 2026
''   Updated.... 18 FEB 2026
''
'' =================================================================================================
''
'' Tests the following APIs:
''   - readCSDRaw() - CSD register raw read
''   - getReadTimeout() / getWriteTimeout() - timeout values
''   - cardSizeSectors() - capacity cross-check
''   - getCardMaxSpeed() - TRAN_SPEED cross-check
''
'' =================================================================================================

CON

     _CLKFREQ        = 270_000_000

     ' Pin configuration for P2 Edge with SD card
     SD_CS   = 60
     SD_MOSI = 59
     SD_MISO = 58
     SD_SCK  = 61

'' Enable register and raw access
#PRAGMA EXPORTDEF SD_INCLUDE_REGISTERS
#PRAGMA EXPORTDEF SD_INCLUDE_RAW
#PRAGMA EXPORTDEF SD_INCLUDE_SPEED

OBJ
    sd    : "micro_sd_fat32_fs"
    utils : "isp_rt_utilities"

DAT

' CSD register buffer (16 bytes)
csdBuf          BYTE    0[16]

PUB go() | result, csdVer, tranSpeed, capacity, cardSectors, readTimeout, writeTimeout, maxSpeed
'' Main entry point for register access regression tests

    debug(" ")
    debug("==============================================")
    debug("  SD Card Driver - Register & Timeout Tests")
    debug("==============================================")

    ' Mount the card first
    result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    if result == false
        debug("ERROR: Could not mount SD card!")
        debug("END_SESSION")
        return

    ' Show card info
    debug(" ")
    debug("* SD Card Information:")
    debug("   Volume Label: ", zstr_(sd.volumeLabel()))
    debug("   Free Space: ", udec(sd.freeSpace()), " sectors")

    ' ======================================================================
    ' TEST GROUP: readCSDRaw
    ' ======================================================================
    utils.startTestGroup(@"readCSDRaw")

    ' Test: readCSDRaw returns data
    utils.startTest(@"readCSDRaw() returns data successfully")
    bytefill(@csdBuf, 0, 16)
    result := sd.readCSDRaw(@csdBuf)
    utils.evaluateBool(result, @"readCSDRaw()", true)

    ' Test: CSD version is valid (0 for SDSC, 1 for SDHC/SDXC)
    utils.startTest(@"CSD version is valid (0 or 1)")
    csdVer := (csdBuf[0] >> 6) & $03
    debug("   CSD version: ", udec_(csdVer))
    utils.evaluateRange(csdVer, @"CSD_STRUCTURE", 0, 1)

    ' Test: TRAN_SPEED is valid (byte 3 of CSD)
    utils.startTest(@"TRAN_SPEED is valid ($32-$5A)")
    tranSpeed := csdBuf[3]
    debug("   TRAN_SPEED: $", uhex_(tranSpeed))
    ' $32 = 25 MHz, $5A = 50 MHz - standard values for SD cards
    utils.evaluateRange(tranSpeed, @"TRAN_SPEED byte", $32, $5A)

    ' Test: Capacity > 0
    utils.startTest(@"Card capacity > 0 sectors")
    cardSectors := sd.cardSizeSectors()
    debug("   Card sectors: ", udec(cardSectors))
    utils.evaluateSubBool(cardSectors > 0, @"capacity > 0", true)

    ' Test: Capacity matches cardSizeSectors()
    utils.startTest(@"CSD capacity consistent with cardSizeSectors()")
    ' For CSD v1 (SDHC/SDXC), capacity = (C_SIZE + 1) * 1024 sectors
    if csdVer == 1
        ' C_SIZE is in CSD bytes 7-9 (bits 69:48)
        capacity := ((csdBuf[7] & $3F) << 16) | (csdBuf[8] << 8) | csdBuf[9]
        capacity := (capacity + 1) * 1024
        debug("   CSD computed sectors: ", udec(capacity))
        ' Should match within rounding
        utils.evaluateSingleValue(capacity, @"CSD vs cardSizeSectors", cardSectors)
    else
        ' SDSC: more complex calculation, just verify non-zero
        utils.evaluateSubBool(cardSectors > 0, @"SDSC capacity > 0", true)

    ' Test: readCSDRaw works via initCardOnly path (unmounted)
    utils.startTest(@"readCSDRaw() works after initCardOnly")
    sd.unmount()
    result := sd.initCardOnly(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    utils.evaluateSubBool(result, @"initCardOnly()", true)
    bytefill(@csdBuf, 0, 16)
    result := sd.readCSDRaw(@csdBuf)
    utils.evaluateSubBool(result, @"readCSDRaw() unmounted", true)
    ' Verify same version
    result := (csdBuf[0] >> 6) & $03
    utils.evaluateSubValue(result, @"CSD version matches", csdVer)
    sd.stop()

    ' Remount for timeout tests
    result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    if result == false
        debug("ERROR: Could not remount!")
        utils.ShowTestEndCounts()
        debug("END_SESSION")
        return

    ' ======================================================================
    ' TEST GROUP: Timeout Values
    ' ======================================================================
    utils.startTestGroup(@"Timeout Values")

    ' Test: getReadTimeout() is reasonable (50-500ms)
    utils.startTest(@"getReadTimeout() in reasonable range")
    readTimeout := sd.getReadTimeout()
    debug("   Read timeout: ", udec(readTimeout), " ms")
    utils.evaluateRange(readTimeout, @"read timeout ms", 50, 500)

    ' Test: getWriteTimeout() is reasonable (100-1000ms)
    utils.startTest(@"getWriteTimeout() in reasonable range")
    writeTimeout := sd.getWriteTimeout()
    debug("   Write timeout: ", udec(writeTimeout), " ms")
    utils.evaluateRange(writeTimeout, @"write timeout ms", 100, 1000)

    ' Test: Write timeout >= read timeout
    utils.startTest(@"Write timeout >= read timeout")
    utils.evaluateSubBool(writeTimeout >= readTimeout, @"write >= read", true)

    ' Test: TRAN_SPEED matches getCardMaxSpeed()
    utils.startTest(@"TRAN_SPEED consistent with getCardMaxSpeed()")
    maxSpeed := sd.getCardMaxSpeed()
    debug("   Card max speed: ", udec(maxSpeed), " Hz")
    ' 25 MHz = $32 TRAN_SPEED, 50 MHz = $5A TRAN_SPEED
    if tranSpeed == $32
        utils.evaluateSingleValue(maxSpeed, @"25 MHz from $32", 25_000_000)
    elseif tranSpeed == $5A
        utils.evaluateSingleValue(maxSpeed, @"50 MHz from $5A", 50_000_000)
    else
        ' Other TRAN_SPEED values - just check range
        utils.evaluateRange(maxSpeed, @"max speed Hz", 25_000_000, 50_000_000)

    ' ======================================================================
    ' Cleanup and Summary
    ' ======================================================================
    sd.unmount()

    utils.ShowTestEndCounts()

    debug(" ")
    debug("END_SESSION")


con { license }

{{
  =================================================================================================

  Terms of Use: MIT License

  Copyright (c) 2026 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

  =================================================================================================
}}
