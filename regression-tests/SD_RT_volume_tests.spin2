'' =================================================================================================
''
''   File....... SD_RT_volume_tests.spin2
''   Purpose.... This object tests volume operations, sync, date, and VBR access
''   Author..... Stephen M Moraco
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... FEB 2026
''   Updated.... 18 FEB 2026
''
'' =================================================================================================
''
'' Tests the following APIs:
''   - setVolumeLabel() / volumeLabel()
''   - syncAllHandles()
''   - sync() (legacy)
''   - setDate() with timestamp verification
''   - VBR access via readSectorRaw() (readVBRRaw is broken - calls SPI from wrong cog)
''
'' =================================================================================================

CON

     _CLKFREQ        = 270_000_000

     ' Pin configuration for P2 Edge with SD card
     SD_CS   = 60
     SD_MOSI = 59
     SD_MISO = 58
     SD_SCK  = 61

     MBR_SIGNATURE = $AA55

'' Enable register access and raw sector access for VBR verification
#PRAGMA EXPORTDEF SD_INCLUDE_REGISTERS
#PRAGMA EXPORTDEF SD_INCLUDE_RAW

OBJ
    sd    : "SD_card_driver"
    utils : "SD_RT_utilities"

DAT

' Test filenames
vlTestFile1     BYTE    "VLTEST1.TXT", 0
vlTestFile2     BYTE    "VLTEST2.TXT", 0
vlTestFile3     BYTE    "VLTEST3.TXT", 0
vlSyncFile      BYTE    "VLSYNC.TXT", 0
vlDateFile      BYTE    "VLDATE1.TXT", 0
vlDateFile2     BYTE    "VLDATE2.TXT", 0
vlDateDir       BYTE    "VLDTDIR", 0
vlLegacyFile    BYTE    "VLLEGCY.TXT", 0

' Volume label test strings
newLabel        BYTE    "TESTLABEL  ", 0
maxLabel        BYTE    "12345678901", 0

' File content
testContent     BYTE    "Volume test content data", 0
syncContent     BYTE    "Sync test data chunk one", 0

' Buffers
vbrBuf          BYTE    0[512]
readBuffer      BYTE    0[256]

' Saved original label
origLabel       BYTE    0[12]

PUB go() | result, handle, h1, h2, h3, bytesWritten, bytesRead, pLabel, idx, pEntry, wrtDate, wrtTime, fileSize, vbrSector, found
'' Main entry point for volume operation regression tests

    debug(" ")
    debug("==============================================")
    debug("  SD Card Driver V3 - Volume Operation Tests")
    debug("==============================================")

    ' Mount the card first
    result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    if result == false
        debug("ERROR: Could not mount SD card!")
        debug("END_SESSION")
        return

    ' Show card info
    debug(" ")
    debug("* SD Card Information:")
    debug("   Volume Label: ", zstr_(sd.volumeLabel()))
    debug("   Free Space: ", udec(sd.freeSpace()), " sectors")

    ' Save original volume label
    pLabel := sd.volumeLabel()
    bytefill(@origLabel, 0, 12)
    bytemove(@origLabel, pLabel, strsize(pLabel))
    debug("   Original Label saved: [", zstr_(@origLabel), "]")

    ' Clean up any existing test files
    cleanupTestFiles()

    ' ======================================================================
    ' TEST GROUP: setVolumeLabel
    ' ======================================================================
    utils.startTestGroup(@"setVolumeLabel")

    ' Test: Set a new volume label
    utils.startTest(@"setVolumeLabel() changes label")
    result := sd.setVolumeLabel(@newLabel)
    utils.evaluateBool(result, @"setVolumeLabel()", true)

    ' Test: volumeLabel() returns the new label
    utils.startTest(@"volumeLabel() returns new label after set")
    pLabel := sd.volumeLabel()
    debug("   New label: [", zstr_(pLabel), "]")
    result := strncmp(pLabel, @"TESTLABEL", 9)
    utils.evaluateBool(result, @"label matches TESTLABEL", true)

    ' Test: Max length label (11 chars)
    utils.startTest(@"setVolumeLabel() accepts 11-char label")
    result := sd.setVolumeLabel(@maxLabel)
    utils.evaluateBool(result, @"setVolumeLabel(11 chars)", true)

    ' Test: Label persists through unmount/remount
    utils.startTest(@"Label persists through unmount/remount")
    sd.unmount()
    result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    utils.evaluateSubBool(result, @"remount succeeds", true)
    pLabel := sd.volumeLabel()
    debug("   Label after remount: [", zstr_(pLabel), "]")
    result := strncmp(pLabel, @"12345678901", 11)
    utils.evaluateSubBool(result, @"label persisted", true)

    ' Test: Restore original label
    utils.startTest(@"Restore original volume label")
    result := sd.setVolumeLabel(@origLabel)
    utils.evaluateBool(result, @"restore label", true)
    pLabel := sd.volumeLabel()
    debug("   Restored label: [", zstr_(pLabel), "]")

    ' ======================================================================
    ' TEST GROUP: syncAllHandles
    ' ======================================================================
    utils.startTestGroup(@"syncAllHandles")

    ' Test: syncAllHandles with no handles open
    utils.startTest(@"syncAllHandles() with no handles open")
    result := sd.syncAllHandles()
    utils.evaluateSingleValue(result, @"syncAllHandles() no handles", 0)

    ' Test: syncAllHandles flushes single write handle
    utils.startTest(@"syncAllHandles() flushes single write handle")
    sd.deleteFile(@vlSyncFile)
    h1 := sd.createFileNew(@vlSyncFile)
    utils.evaluateSubBool(h1 >= 0, @"create file", true)
    if h1 >= 0
        bytesWritten := sd.writeHandle(h1, @syncContent, strsize(@syncContent))
        result := sd.syncAllHandles()
        utils.evaluateSubValue(result, @"syncAllHandles()", 0)
        ' File should still be writable
        bytesWritten := sd.writeHandle(h1, @syncContent, strsize(@syncContent))
        utils.evaluateSubBool(bytesWritten > 0, @"write after sync", true)
        sd.closeFileHandle(h1)

    ' Test: syncAllHandles flushes multiple write handles
    utils.startTest(@"syncAllHandles() flushes multiple write handles")
    sd.deleteFile(@vlTestFile1)
    sd.deleteFile(@vlTestFile2)
    h1 := sd.createFileNew(@vlTestFile1)
    h2 := sd.createFileNew(@vlTestFile2)
    if h1 >= 0
        sd.writeHandle(h1, @testContent, strsize(@testContent))
    if h2 >= 0
        sd.writeHandle(h2, @testContent, strsize(@testContent))
    result := sd.syncAllHandles()
    utils.evaluateSingleValue(result, @"syncAllHandles() multi", 0)
    if h1 >= 0
        sd.closeFileHandle(h1)
    if h2 >= 0
        sd.closeFileHandle(h2)

    ' Test: syncAllHandles with mixed read+write handles
    utils.startTest(@"syncAllHandles() with read+write mix")
    h1 := sd.openFileRead(@vlTestFile1)
    sd.deleteFile(@vlTestFile3)
    h2 := sd.createFileNew(@vlTestFile3)
    if h2 >= 0
        sd.writeHandle(h2, @testContent, strsize(@testContent))
    result := sd.syncAllHandles()
    utils.evaluateSingleValue(result, @"syncAllHandles() mix", 0)
    if h1 >= 0
        sd.closeFileHandle(h1)
    if h2 >= 0
        sd.closeFileHandle(h2)

    ' ======================================================================
    ' TEST GROUP: sync (legacy)
    ' ======================================================================
    utils.startTestGroup(@"sync (legacy)")

    ' Test: sync flushes legacy write
    utils.startTest(@"sync() flushes legacy write")
    sd.deleteFile(@vlLegacyFile)
    result := sd.newFile(@vlLegacyFile)
    utils.evaluateSubBool(result, @"newFile()", true)
    sd.writeString(@testContent)
    result := sd.sync()
    utils.evaluateSubBool(result, @"sync()", true)
    sd.closeFile()

    ' Test: sync with no file open
    utils.startTest(@"sync() with no file open")
    result := sd.sync()
    utils.evaluateBool(result, @"sync() no file", true)

    ' ======================================================================
    ' TEST GROUP: setDate
    ' ======================================================================
    utils.startTestGroup(@"setDate")

    ' Test: Timestamp on new file
    utils.startTest(@"setDate() sets timestamp on new file")
    sd.setDate(2026, 2, 18, 14, 30, 0)
    sd.deleteFile(@vlDateFile)
    h1 := sd.createFileNew(@vlDateFile)
    if h1 >= 0
        sd.writeHandle(h1, @testContent, strsize(@testContent))
        sd.closeFileHandle(h1)
    ' Verify timestamp via directory entry
    wrtDate := 0
    wrtTime := 0
    found := false
    idx := 0
    repeat
        pEntry := sd.readDirectory(idx)
        if pEntry == 0
            quit
        pLabel := sd.fileName()
        if strcomp(pLabel, @"VLDATE1.TXT")
            ' FAT date: bits 15-9=year-1980, 8-5=month, 4-0=day
            wrtDate := WORD[pEntry + 24]
            ' FAT time: bits 15-11=hour, 10-5=minute, 4-0=second/2
            wrtTime := WORD[pEntry + 22]
            found := true
            quit
        idx++
    debug("   found=", sdec_(found), " wrtDate=$", uhex_(wrtDate), " wrtTime=$", uhex_(wrtTime))
    utils.evaluateSubBool(found, @"file found in dir", true)
    utils.evaluateSubBool(wrtDate <> 0, @"date stamp non-zero", true)
    utils.evaluateSubBool(wrtTime <> 0, @"time stamp non-zero", true)
    ' Verify year field (bits 15-9) = 46 (2026-1980)
    result := (wrtDate >> 9) & $7F
    utils.evaluateSubValue(result, @"year field (2026-1980)", 46)

    ' Test: Midnight Jan 1, 2000
    utils.startTest(@"setDate() midnight Jan 1 2000")
    sd.setDate(2000, 1, 1, 0, 0, 0)
    sd.deleteFile(@vlDateFile2)
    h1 := sd.createFileNew(@vlDateFile2)
    if h1 >= 0
        sd.writeHandle(h1, @testContent, strsize(@testContent))
        sd.closeFileHandle(h1)
    found := false
    idx := 0
    repeat
        pEntry := sd.readDirectory(idx)
        if pEntry == 0
            quit
        pLabel := sd.fileName()
        if strcomp(pLabel, @"VLDATE2.TXT")
            wrtDate := WORD[pEntry + 24]
            wrtTime := WORD[pEntry + 22]
            found := true
            quit
        idx++
    debug("   found=", sdec_(found), " wrtDate=$", uhex_(wrtDate))
    utils.evaluateSubBool(found, @"file found in dir", true)
    ' Year=2000-1980=20, month=1, day=1
    result := (wrtDate >> 9) & $7F
    utils.evaluateSubValue(result, @"year field (2000-1980)", 20)
    ' Time at midnight should be 0
    utils.evaluateSubValue(wrtTime, @"midnight time", 0)

    ' Test: End-of-day Dec 31
    utils.startTest(@"setDate() end-of-day Dec 31")
    sd.setDate(2025, 12, 31, 23, 59, 58)
    sd.deleteFile(@vlDateFile2)
    h1 := sd.createFileNew(@vlDateFile2)
    if h1 >= 0
        sd.writeHandle(h1, @testContent, strsize(@testContent))
        sd.closeFileHandle(h1)
    found := false
    idx := 0
    repeat
        pEntry := sd.readDirectory(idx)
        if pEntry == 0
            quit
        pLabel := sd.fileName()
        if strcomp(pLabel, @"VLDATE2.TXT")
            wrtDate := WORD[pEntry + 24]
            wrtTime := WORD[pEntry + 22]
            found := true
            quit
        idx++
    debug("   found=", sdec_(found), " wrtDate=$", uhex_(wrtDate), " wrtTime=$", uhex_(wrtTime))
    utils.evaluateSubBool(found, @"file found in dir", true)
    ' Year=2025-1980=45
    result := (wrtDate >> 9) & $7F
    utils.evaluateSubValue(result, @"year field (2025-1980)", 45)
    ' Month=12
    result := (wrtDate >> 5) & $0F
    utils.evaluateSubValue(result, @"month field (12)", 12)
    ' Hour=23, minute=59, second/2=29
    result := (wrtTime >> 11) & $1F
    utils.evaluateSubValue(result, @"hour field (23)", 23)

    ' Test: setDate via V3 createFileNew
    utils.startTest(@"setDate() timestamp on V3 createFileNew")
    sd.setDate(2026, 6, 15, 10, 0, 0)
    sd.deleteFile(@vlDateFile)
    h1 := sd.createFileNew(@vlDateFile)
    if h1 >= 0
        sd.writeHandle(h1, @testContent, strsize(@testContent))
        sd.closeFileHandle(h1)
    found := false
    idx := 0
    repeat
        pEntry := sd.readDirectory(idx)
        if pEntry == 0
            quit
        pLabel := sd.fileName()
        if strcomp(pLabel, @"VLDATE1.TXT")
            wrtDate := WORD[pEntry + 24]
            found := true
            quit
        idx++
    debug("   found=", sdec_(found), " wrtDate=$", uhex_(wrtDate))
    utils.evaluateSubBool(found, @"file found in dir", true)
    ' Year=2026-1980=46, month=6
    result := (wrtDate >> 9) & $7F
    utils.evaluateSubValue(result, @"V3 year field", 46)
    result := (wrtDate >> 5) & $0F
    utils.evaluateSubValue(result, @"V3 month field", 6)

    ' Test: setDate on new directory
    utils.startTest(@"setDate() timestamp on new directory")
    sd.setDate(2026, 3, 1, 8, 0, 0)
    sd.newDirectory(@vlDateDir)
    found := false
    idx := 0
    repeat
        pEntry := sd.readDirectory(idx)
        if pEntry == 0
            quit
        pLabel := sd.fileName()
        if strcomp(pLabel, @"VLDTDIR")
            wrtDate := WORD[pEntry + 24]
            found := true
            quit
        idx++
    debug("   found=", sdec_(found), " wrtDate=$", uhex_(wrtDate))
    utils.evaluateSubBool(found, @"dir found in listing", true)
    ' Year=2026-1980=46, month=3
    result := (wrtDate >> 9) & $7F
    utils.evaluateSubValue(result, @"dir year field", 46)
    result := (wrtDate >> 5) & $0F
    utils.evaluateSubValue(result, @"dir month field", 3)

    ' ======================================================================
    ' TEST GROUP: VBR Access (via readSectorRaw)
    '   NOTE: readVBRRaw() is broken - it calls readSector() from the calling
    '   cog but SPI is on the worker cog. Use readSectorRaw() as workaround.
    ' ======================================================================
    utils.startTestGroup(@"VBR Access via readSectorRaw")

    ' Read MBR (sector 0) to find VBR sector
    utils.startTest(@"Read MBR to find VBR sector")
    bytefill(@vbrBuf, 0, 512)
    result := sd.readSectorRaw(0, @vbrBuf)
    utils.evaluateBool(result, @"readSectorRaw(0)", true)

    ' Get VBR sector from partition table (offset $1C6 = 454, 4-byte LE)
    utils.startTest(@"MBR partition table has valid VBR sector")
    vbrSector := LONG[@vbrBuf + $1C6]
    debug("   VBR sector: ", udec_(vbrSector))
    utils.evaluateSubBool(vbrSector > 0, @"VBR sector > 0", true)
    utils.evaluateSubBool(vbrSector < 100_000, @"VBR sector reasonable", true)

    ' Read VBR sector
    utils.startTest(@"VBR has boot signature $AA55")
    bytefill(@vbrBuf, 0, 512)
    result := sd.readSectorRaw(vbrSector, @vbrBuf)
    if result
        result := WORD[@vbrBuf + $1FE]
        utils.evaluateSingleValueHex(result, @"boot signature", MBR_SIGNATURE)
    else
        utils.evaluateBool(false, @"VBR read failed", true)

    ' Test: Bytes per sector == 512
    utils.startTest(@"VBR bytes-per-sector == 512")
    result := WORD[@vbrBuf + $0B]
    utils.evaluateSingleValue(result, @"bytes per sector", 512)

    ' Test: OEM name is readable (8 bytes at offset 3)
    utils.startTest(@"VBR OEM name is readable")
    ' OEM name is 8 bytes at offset 3, should be printable ASCII
    result := true
    repeat idx from 0 to 7
        if vbrBuf[$03 + idx] < $20 or vbrBuf[$03 + idx] > $7E
            result := false
            quit
    debug("   OEM: ", lstr_(@vbrBuf + $03, 8))
    utils.evaluateBool(result, @"OEM name printable", true)

    ' ======================================================================
    ' Cleanup and Summary
    ' ======================================================================
    cleanupTestFiles()

    sd.unmount()

    utils.ShowTestEndCounts()

    debug(" ")
    debug("END_SESSION")

PRI cleanupTestFiles()
' Delete all test files

    sd.deleteFile(@vlTestFile1)
    sd.deleteFile(@vlTestFile2)
    sd.deleteFile(@vlTestFile3)
    sd.deleteFile(@vlSyncFile)
    sd.deleteFile(@vlDateFile)
    sd.deleteFile(@vlDateFile2)
    sd.deleteFile(@vlLegacyFile)
    sd.deleteFile(@vlDateDir)

PRI strncmp(p1, p2, n) : match | i
' Compare first n bytes of two strings

    match := true
    repeat i from 0 to n - 1
        if BYTE[p1][i] <> BYTE[p2][i]
            match := false
            quit


con { license }

{{
  =================================================================================================

  Terms of Use: MIT License

  Copyright (c) 2026 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

  =================================================================================================
}}
