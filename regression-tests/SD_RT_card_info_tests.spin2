{Spin2_v45}
'' =================================================================================================
''
''   File....... SD_RT_card_info_tests.spin2
''   Purpose.... Certify struct-based access to driver API methods (matches demo shell pattern)
''   Authors.... Claude + Stephen M Moraco
''   Started.... FEB 2026
''
'' =================================================================================================
''
''   Uses struct LOCALS exactly as do_card_info() does:
''     - sd.cid_t cid  (local struct instance)
''     - sd.scr_t scr  (local struct instance)
''     - cid.mid, cid.pnm, cid.psn[0], cid.prv, cid.mdt[0] (struct field access)
''     - ^sd.scr_t pointer parameter (struct pointer in PRI method)
''
''   For each struct, displays BOTH raw bytes and struct field values side-by-side
''   to detect any offset mismatch between packed bytes and field accessors.
''
''   All output via debug() only - no serial singleton.
''   Tests both unmounted (initCardOnly) and mounted paths.
''
''   Usage: ./run_test.sh ../regression-tests/SD_RT_card_info_tests.spin2
''
'' =================================================================================================

CON

    _CLKFREQ        = 270_000_000

    ' P2 Edge module SD slot pins
    SD_CS   = 60
    SD_MOSI = 59
    SD_MISO = 58
    SD_SCK  = 61

    MBR_SIGNATURE = $AA55

'' Enable full driver features for register reads
#PRAGMA EXPORTDEF SD_INCLUDE_ALL

OBJ
    sd : "SD_card_driver"

DAT

    ' Sector buffer for MBR/VBR reads
    sect_buf      BYTE    0[512]

    ' SD Status buffer (ACMD13 - 64 bytes)
    sdst_buf      BYTE    0[64]

    ' Parsed field buffers
    pnm_buf       BYTE    0[6]         ' Product name (5 chars + null)
    oemBuf        BYTE    0[9]         ' OEM name (8 chars + null)

    ' Test counters
    pass_count    LONG    0
    fail_count    LONG    0

    ' Manufacturer lookup table (MID byte, then name string, null-terminated)
    midTable      BYTE    $01, "Panasonic", 0
                  BYTE    $02, "Toshiba", 0
                  BYTE    $03, "SanDisk", 0
                  BYTE    $1B, "Samsung", 0
                  BYTE    $27, "Phison", 0
                  BYTE    $28, "Lexar", 0
                  BYTE    $41, "Kingston", 0
                  BYTE    $74, "Transcend", 0
                  BYTE    $82, "Sony", 0
                  BYTE    $AD, "Longsys/Lexar", 0
                  BYTE    $FE, "PNY OEM", 0
                  BYTE    $FF             ' end sentinel

    ' Card type strings
    ctSDSC        BYTE    "SDSC", 0
    ctSDHC        BYTE    "SDHC", 0
    ctSDXC        BYTE    "SDXC", 0

    ' Filesystem type strings
    fsFAT12       BYTE    "FAT12", 0
    fsFAT16       BYTE    "FAT16", 0
    fsFAT32       BYTE    "FAT32", 0
    fsExFAT       BYTE    "exFAT", 0
    fsLinux       BYTE    "Linux", 0
    fsGPT         BYTE    "GPT", 0
    fsEmpty       BYTE    "Empty", 0
    fsUnknown     BYTE    "???", 0


PUB go() | result

    debug(" ")
    debug("============================================================")
    debug("  SD Card Info - Struct Local Certification Test")
    debug("  Uses struct locals exactly as do_card_info() does")
    debug("============================================================")
    debug(" ")

    pass_count := 0
    fail_count := 0

    ' ========================================
    ' PHASE 1: UNMOUNTED (initCardOnly)
    ' ========================================
    debug("=== PHASE 1: UNMOUNTED (initCardOnly) ===")
    debug(" ")

    result := sd.initCardOnly(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    if not result
        debug("FATAL: initCardOnly() failed - cannot proceed")
        debug("END_SESSION")
        return

    debug("initCardOnly: OK")
    debug(" ")

    testStructAccess()
    generateTwoLineDisplay()

    ' ========================================
    ' PHASE 2: MOUNTED (RAW -> FILESYSTEM)
    ' ========================================
    debug(" ")
    debug("=== PHASE 2: MOUNTED (mount upgrade) ===")
    debug(" ")

    result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    if not result
        debug("mount() failed (error=", sdec_(sd.error()), ") - skipping mounted tests")
        fail_count++
    else
        debug("mount: OK (MODE_RAW -> MODE_FILESYSTEM upgrade)")
        debug(" ")
        testStructAccess()
        generateTwoLineDisplay()

    ' ========================================
    ' SUMMARY
    ' ========================================
    debug(" ")
    debug("============================================================")
    debug("  Results: Pass=", udec_(pass_count), "  Fail=", udec_(fail_count))
    debug("============================================================")
    debug(" ")
    debug("END_SESSION")


PRI testStructAccess() | sd.cid_t cid, sd.scr_t scr, result, ocr, sectors, spiHz, i
'' Test CID and SCR using struct locals - the EXACT pattern do_card_info() uses.
'' Compares struct field access against raw byte access to detect offset errors.

    ' === CID TEST: struct local ===
    debug("--- Test: readCIDRaw() into struct local ---")
    bytefill(@cid, $EE, 16)
    result := sd.readCIDRaw(@cid)
    if result
        debug("  readCIDRaw: OK")

        ' Display raw bytes at @cid for reference
        debug("  Raw @cid: ", uhex_byte_(BYTE[@cid+0]), " ", uhex_byte_(BYTE[@cid+1]), " ", uhex_byte_(BYTE[@cid+2]), " ", uhex_byte_(BYTE[@cid+3]), " ", uhex_byte_(BYTE[@cid+4]), " ", uhex_byte_(BYTE[@cid+5]), " ", uhex_byte_(BYTE[@cid+6]), " ", uhex_byte_(BYTE[@cid+7]))
        debug("            ", uhex_byte_(BYTE[@cid+8]), " ", uhex_byte_(BYTE[@cid+9]), " ", uhex_byte_(BYTE[@cid+10]), " ", uhex_byte_(BYTE[@cid+11]), " ", uhex_byte_(BYTE[@cid+12]), " ", uhex_byte_(BYTE[@cid+13]), " ", uhex_byte_(BYTE[@cid+14]), " ", uhex_byte_(BYTE[@cid+15]))

        ' Verify buffer was written
        if BYTE[@cid] == $EE and BYTE[@cid+1] == $EE
            debug("  FAIL: Buffer unchanged (sentinel $EE)")
            fail_count++
        else
            ' === CRITICAL: Compare struct fields vs raw bytes ===
            debug("  --- Struct field vs raw byte comparison ---")
            debug("  cid.mid      = $", uhex_byte_(cid.mid),       "  raw[0]  = $", uhex_byte_(BYTE[@cid+0]),  "  ", zstr_(cid.mid == BYTE[@cid+0] ? @"MATCH" : @"MISMATCH"))
            debug("  cid.oid[0]   = $", uhex_byte_(cid.oid[0]),    "  raw[1]  = $", uhex_byte_(BYTE[@cid+1]),  "  ", zstr_(cid.oid[0] == BYTE[@cid+1] ? @"MATCH" : @"MISMATCH"))
            debug("  cid.oid[1]   = $", uhex_byte_(cid.oid[1]),    "  raw[2]  = $", uhex_byte_(BYTE[@cid+2]),  "  ", zstr_(cid.oid[1] == BYTE[@cid+2] ? @"MATCH" : @"MISMATCH"))
            debug("  cid.pnm[0]   = $", uhex_byte_(cid.pnm[0]),   "  raw[3]  = $", uhex_byte_(BYTE[@cid+3]),  "  ", zstr_(cid.pnm[0] == BYTE[@cid+3] ? @"MATCH" : @"MISMATCH"))
            debug("  cid.pnm[4]   = $", uhex_byte_(cid.pnm[4]),   "  raw[7]  = $", uhex_byte_(BYTE[@cid+7]),  "  ", zstr_(cid.pnm[4] == BYTE[@cid+7] ? @"MATCH" : @"MISMATCH"))
            debug("  cid.prv      = $", uhex_byte_(cid.prv),       "  raw[8]  = $", uhex_byte_(BYTE[@cid+8]),  "  ", zstr_(cid.prv == BYTE[@cid+8] ? @"MATCH" : @"MISMATCH"))
            debug("  cid.psn[0]   = $", uhex_byte_(cid.psn[0]),    "  raw[9]  = $", uhex_byte_(BYTE[@cid+9]),  "  ", zstr_(cid.psn[0] == BYTE[@cid+9] ? @"MATCH" : @"MISMATCH"))
            debug("  cid.psn[3]   = $", uhex_byte_(cid.psn[3]),    "  raw[12] = $", uhex_byte_(BYTE[@cid+12]), "  ", zstr_(cid.psn[3] == BYTE[@cid+12] ? @"MATCH" : @"MISMATCH"))
            debug("  cid.mdt[0]   = $", uhex_byte_(cid.mdt[0]),    "  raw[13] = $", uhex_byte_(BYTE[@cid+13]), "  ", zstr_(cid.mdt[0] == BYTE[@cid+13] ? @"MATCH" : @"MISMATCH"))
            debug("  cid.mdt[1]   = $", uhex_byte_(cid.mdt[1]),    "  raw[14] = $", uhex_byte_(BYTE[@cid+14]), "  ", zstr_(cid.mdt[1] == BYTE[@cid+14] ? @"MATCH" : @"MISMATCH"))
            debug("  cid.crc      = $", uhex_byte_(cid.crc),       "  raw[15] = $", uhex_byte_(BYTE[@cid+15]), "  ", zstr_(cid.crc == BYTE[@cid+15] ? @"MATCH" : @"MISMATCH"))
            pass_count++
    else
        debug("  readCIDRaw: FAILED")
        fail_count++
    debug(" ")

    ' === SCR TEST: struct local ===
    debug("--- Test: readSCRRaw() into struct local ---")
    bytefill(@scr, $EE, 8)
    result := sd.readSCRRaw(@scr)
    if result
        debug("  readSCRRaw: OK")

        ' Display raw bytes at @scr
        debug("  Raw @scr: ", uhex_byte_(BYTE[@scr+0]), " ", uhex_byte_(BYTE[@scr+1]), " ", uhex_byte_(BYTE[@scr+2]), " ", uhex_byte_(BYTE[@scr+3]), " ", uhex_byte_(BYTE[@scr+4]), " ", uhex_byte_(BYTE[@scr+5]), " ", uhex_byte_(BYTE[@scr+6]), " ", uhex_byte_(BYTE[@scr+7]))

        if BYTE[@scr] == $EE and BYTE[@scr+1] == $EE
            debug("  FAIL: Buffer unchanged (sentinel $EE)")
            fail_count++
        else
            ' === Compare struct fields vs raw bytes ===
            debug("  --- Struct field vs raw byte comparison ---")
            debug("  scr.sdSpec      = $", uhex_byte_(scr.sdSpec),      "  raw[0] = $", uhex_byte_(BYTE[@scr+0]), "  ", zstr_(scr.sdSpec == BYTE[@scr+0] ? @"MATCH" : @"MISMATCH"))
            debug("  scr.sdSecurity  = $", uhex_byte_(scr.sdSecurity),  "  raw[1] = $", uhex_byte_(BYTE[@scr+1]), "  ", zstr_(scr.sdSecurity == BYTE[@scr+1] ? @"MATCH" : @"MISMATCH"))
            debug("  scr.sdSpec3Ext  = $", uhex_byte_(scr.sdSpec3Ext),  "  raw[2] = $", uhex_byte_(BYTE[@scr+2]), "  ", zstr_(scr.sdSpec3Ext == BYTE[@scr+2] ? @"MATCH" : @"MISMATCH"))
            debug("  scr.sdSpecXLo   = $", uhex_byte_(scr.sdSpecXLo),   "  raw[3] = $", uhex_byte_(BYTE[@scr+3]), "  ", zstr_(scr.sdSpecXLo == BYTE[@scr+3] ? @"MATCH" : @"MISMATCH"))

            ' Test struct pointer parameter (matches getSDSpecVersion)
            debug("  getSDSpecVersion(@scr) = ", zstr_(getSDSpecVersion(@scr)))
            pass_count++
    else
        debug("  readSCRRaw: FAILED")
        fail_count++
    debug(" ")

    ' === Other API tests (unchanged) ===
    debug("--- Test: getOCR() ---")
    ocr := sd.getOCR()
    debug("  OCR: $", uhex_long_(ocr))
    if ocr <> 0
        debug("  CCS=", udec_((ocr >> 30) & 1), " (", zstr_((ocr >> 30) & 1 ? @ctSDHC : @ctSDSC), ")")
        pass_count++
    else
        debug("  FAIL: OCR is zero")
        fail_count++

    debug("--- Test: cardSizeSectors() ---")
    sectors := sd.cardSizeSectors()
    debug("  Sectors: ", udec_(sectors), " (", udec_(sectors / 2048), " MB)")
    if sectors > 0
        pass_count++
    else
        fail_count++

    debug("--- Test: getSPIFrequency() ---")
    spiHz := sd.getSPIFrequency()
    debug("  SPI: ", udec_(spiHz / 1_000_000), ".", udec_((spiHz / 100_000) // 10), " MHz")
    if spiHz > 0
        pass_count++
    else
        fail_count++

    debug("--- Test: readSectorRaw(0) MBR ---")
    result := sd.readSectorRaw(0, @sect_buf)
    if WORD[@sect_buf + $1FE] == MBR_SIGNATURE
        debug("  MBR: valid, type=$", uhex_byte_(sect_buf[$1C2]), " start=", udec_(LONG[@sect_buf + $1C6]))
        pass_count++
    else
        debug("  MBR: INVALID signature")
        fail_count++
    debug(" ")

    ' === ACMD13 SD STATUS TEST ===
    debug("--- Test: readSDStatusRaw() ACMD13 ---")
    bytefill(@sdst_buf, $EE, 64)
    result := sd.readSDStatusRaw(@sdst_buf)
    if result
        debug("  readSDStatusRaw: OK (64 bytes)")

        ' Hex dump of SD Status (4 rows of 16 bytes)
        debug("  SD Status raw:")
        debug("    [00-0F]: ", uhex_byte_(sdst_buf[0]), " ", uhex_byte_(sdst_buf[1]), " ", uhex_byte_(sdst_buf[2]), " ", uhex_byte_(sdst_buf[3]), " ", uhex_byte_(sdst_buf[4]), " ", uhex_byte_(sdst_buf[5]), " ", uhex_byte_(sdst_buf[6]), " ", uhex_byte_(sdst_buf[7]), " ", uhex_byte_(sdst_buf[8]), " ", uhex_byte_(sdst_buf[9]), " ", uhex_byte_(sdst_buf[10]), " ", uhex_byte_(sdst_buf[11]), " ", uhex_byte_(sdst_buf[12]), " ", uhex_byte_(sdst_buf[13]), " ", uhex_byte_(sdst_buf[14]), " ", uhex_byte_(sdst_buf[15]))
        debug("    [10-1F]: ", uhex_byte_(sdst_buf[16]), " ", uhex_byte_(sdst_buf[17]), " ", uhex_byte_(sdst_buf[18]), " ", uhex_byte_(sdst_buf[19]), " ", uhex_byte_(sdst_buf[20]), " ", uhex_byte_(sdst_buf[21]), " ", uhex_byte_(sdst_buf[22]), " ", uhex_byte_(sdst_buf[23]), " ", uhex_byte_(sdst_buf[24]), " ", uhex_byte_(sdst_buf[25]), " ", uhex_byte_(sdst_buf[26]), " ", uhex_byte_(sdst_buf[27]), " ", uhex_byte_(sdst_buf[28]), " ", uhex_byte_(sdst_buf[29]), " ", uhex_byte_(sdst_buf[30]), " ", uhex_byte_(sdst_buf[31]))
        debug("    [20-2F]: ", uhex_byte_(sdst_buf[32]), " ", uhex_byte_(sdst_buf[33]), " ", uhex_byte_(sdst_buf[34]), " ", uhex_byte_(sdst_buf[35]), " ", uhex_byte_(sdst_buf[36]), " ", uhex_byte_(sdst_buf[37]), " ", uhex_byte_(sdst_buf[38]), " ", uhex_byte_(sdst_buf[39]), " ", uhex_byte_(sdst_buf[40]), " ", uhex_byte_(sdst_buf[41]), " ", uhex_byte_(sdst_buf[42]), " ", uhex_byte_(sdst_buf[43]), " ", uhex_byte_(sdst_buf[44]), " ", uhex_byte_(sdst_buf[45]), " ", uhex_byte_(sdst_buf[46]), " ", uhex_byte_(sdst_buf[47]))
        debug("    [30-3F]: ", uhex_byte_(sdst_buf[48]), " ", uhex_byte_(sdst_buf[49]), " ", uhex_byte_(sdst_buf[50]), " ", uhex_byte_(sdst_buf[51]), " ", uhex_byte_(sdst_buf[52]), " ", uhex_byte_(sdst_buf[53]), " ", uhex_byte_(sdst_buf[54]), " ", uhex_byte_(sdst_buf[55]), " ", uhex_byte_(sdst_buf[56]), " ", uhex_byte_(sdst_buf[57]), " ", uhex_byte_(sdst_buf[58]), " ", uhex_byte_(sdst_buf[59]), " ", uhex_byte_(sdst_buf[60]), " ", uhex_byte_(sdst_buf[61]), " ", uhex_byte_(sdst_buf[62]), " ", uhex_byte_(sdst_buf[63]))

        ' Decode key fields
        debug("  SPEED_CLASS (byte 8):      $", uhex_byte_(sdst_buf[8]), " = Class ", udec_(decodeSpeedClass(sdst_buf[8])))
        debug("  UHS_SPEED_GRADE (byte 14): $", uhex_byte_(sdst_buf[14] >> 4), " = U", udec_(sdst_buf[14] >> 4))
        debug("  VIDEO_SPEED_CLASS (byte 15): ", udec_(sdst_buf[15]), " = V", udec_(sdst_buf[15]))

        ' Sanity checks
        if sdst_buf[8] <= $04
            debug("  Speed Class sanity: PASS (value <= $04)")
            pass_count++
        else
            debug("  Speed Class sanity: FAIL (value $", uhex_byte_(sdst_buf[8]), " > $04)")
            fail_count++

        if (sdst_buf[14] >> 4) == 0 or (sdst_buf[14] >> 4) == 1 or (sdst_buf[14] >> 4) == 3
            debug("  UHS Grade sanity: PASS (value is 0, 1, or 3)")
            pass_count++
        else
            debug("  UHS Grade sanity: FAIL (value $", uhex_byte_(sdst_buf[14] >> 4), " not 0/1/3)")
            fail_count++
    else
        debug("  readSDStatusRaw: FAILED")
        fail_count++
    debug(" ")


PRI generateTwoLineDisplay() | sd.cid_t cid, sd.scr_t scr, ...
                                ocr, sizeMB, spiHz, psn, mdtYear, mdtMonth, ...
                                pnm[2], p_mfr, p_type, p_spec, p_fs, i, ...
                                sdstOk, speedClass, uhsGrade, videoClass
'' Generate two-line display using struct locals - EXACTLY as do_card_info() does.
'' This is the code path we're certifying.

    debug(" ")
    debug("--- Two-Line Display (struct locals) ---")

    ' Read registers into struct locals (same as do_card_info)
    sd.readCIDRaw(@cid)
    sd.readSCRRaw(@scr)
    ocr := sd.getOCR()
    sizeMB := sd.cardSizeSectors() / 2048
    spiHz := sd.getSPIFrequency()

    ' Parse CID using struct field access (same as do_card_info)
    bytemove(@pnm, @cid.pnm, 5)
    BYTE[@pnm + 5] := 0

    psn := (cid.psn[0] << 24) | (cid.psn[1] << 16) | (cid.psn[2] << 8) | cid.psn[3]

    mdtYear := 2000 + ((cid.mdt[0] & $0F) << 4) + ((cid.mdt[1] >> 4) & $0F)
    mdtMonth := cid.mdt[1] & $0F

    ' Look up strings (same as do_card_info)
    p_mfr := lookupMID(cid.mid)
    p_type := getCardType(ocr, sizeMB)
    p_spec := getSDSpecVersion(@scr)
    p_fs := detectFilesystem()

    ' Read OEM name
    readOEMName()

    ' Read SD Status (ACMD13) for speed class info
    sdstOk := sd.readSDStatusRaw(@sdst_buf)
    if sdstOk
        speedClass := decodeSpeedClass(sdst_buf[8])
        uhsGrade := sdst_buf[14] >> 4
        videoClass := sdst_buf[15]
    else
        speedClass := 0
        uhsGrade := 0
        videoClass := 0

    ' Display individual values
    debug("  p_mfr   = [", zstr_(p_mfr), "]")
    debug("  pnm     = [", zstr_(@pnm), "]")
    debug("  p_type  = [", zstr_(p_type), "]")
    if sizeMB < 1024
        debug("  size    = ", udec_(sizeMB), " MB")
    else
        debug("  size    = ", udec_(sizeMB / 1024), " GB")
    debug("  p_fs    = [", zstr_(p_fs), "]")
    debug("  p_spec  = [", zstr_(p_spec), "]")
    debug("  prv     = ", udec_(cid.prv >> 4), ".", udec_(cid.prv & $0F))
    debug("  psn     = $", uhex_long_(psn))
    debug("  mdt     = ", udec_(mdtYear), "/", udec_(mdtMonth))
    debug("  spiHz   = ", udec_(spiHz / 1_000_000), ".", udec_((spiHz / 100_000) // 10), " MHz")
    debug("  oem     = [", zstr_(@oemBuf), "]")

    ' Combined display
    debug(" ")
    debug("--- EXPECTED OUTPUT ---")
    if sizeMB < 1024
        debug("L1: ", zstr_(p_mfr), " ", zstr_(@pnm), " ", zstr_(p_type), " ", udec_(sizeMB), "MB [", zstr_(p_fs), "] ", zstr_(p_spec), " rev", udec_(cid.prv >> 4), ".", udec_(cid.prv & $0F), " SN:", uhex_long_(psn), " ", udec_(mdtYear), "/", udec_(mdtMonth))
    else
        debug("L1: ", zstr_(p_mfr), " ", zstr_(@pnm), " ", zstr_(p_type), " ", udec_(sizeMB / 1024), "GB [", zstr_(p_fs), "] ", zstr_(p_spec), " rev", udec_(cid.prv >> 4), ".", udec_(cid.prv & $0F), " SN:", uhex_long_(psn), " ", udec_(mdtYear), "/", udec_(mdtMonth))
    if sdstOk
        debug("L2: Class ", udec_(speedClass), ", U", udec_(uhsGrade), ", V", udec_(videoClass), ", SPI ", udec_(spiHz / 1_000_000), " MHz  [", zstr_(@oemBuf), "]")
    else
        debug("L2: SPI ", udec_(spiHz / 1_000_000), " MHz  [", zstr_(@oemBuf), "]  (ACMD13 unavailable)")
    debug("--- END ---")
    debug(" ")


PRI getSDSpecVersion(^sd.scr_t p_scr) : p_version | sdSpec, spec3, spec4, specX
'' Decode SD spec version - uses ^sd.scr_t pointer (same as demo shell)

    sdSpec := p_scr.sdSpec & $0F
    spec3 := (p_scr.sdSpec3Ext >> 7) & 1
    spec4 := (p_scr.sdSpec3Ext >> 2) & 1
    specX := ((p_scr.sdSpec3Ext & $03) << 2) | ((p_scr.sdSpecXLo >> 6) & $03)

    if sdSpec < 2
        return @"SD 1.x"
    if spec3 == 0
        return @"SD 2.0"
    if spec4 == 0
        return @"SD 3.x"
    if specX == 0
        return @"SD 4.x"
    if specX == 1
        return @"SD 5.x"
    if specX == 2
        return @"SD 6.x"
    return @"SD >6.x"


PRI lookupMID(mid) : p_name | p, entryMID

    p := @midTable
    repeat
        entryMID := BYTE[p]
        if entryMID == $FF
            return @"Unknown"
        if entryMID == mid
            return p + 1
        p++
        repeat while BYTE[p] <> 0
            p++
        p++


PRI getCardType(ocr, sizeMB) : p_type

    if (ocr & (1 << 30)) == 0
        return @ctSDSC
    if sizeMB > 32768
        return @ctSDXC
    return @ctSDHC


PRI detectFilesystem() : p_fsName | pType

    sd.readSectorRaw(0, @sect_buf)
    if WORD[@sect_buf + $1FE] <> MBR_SIGNATURE
        return @fsUnknown

    pType := sect_buf[$1C2]
    case pType
        $00 : return @fsEmpty
        $01 : return @fsFAT12
        $04, $06, $0E : return @fsFAT16
        $0B, $0C : return @fsFAT32
        $07 : return @fsExFAT
        $83 : return @fsLinux
        $EE : return @fsGPT
        other : return @fsUnknown


PRI readOEMName() | partStart, i

    sd.readSectorRaw(0, @sect_buf)
    if WORD[@sect_buf + $1FE] == MBR_SIGNATURE
        partStart := LONG[@sect_buf + $1C6]
        if partStart > 0
            sd.readSectorRaw(partStart, @sect_buf)
            bytemove(@oemBuf, @sect_buf + 3, 8)
            oemBuf[8] := 0
            i := 7
            repeat while i >= 0 and oemBuf[i] == " "
                oemBuf[i] := 0
                i--
        else
            bytemove(@oemBuf, @"n/a", 4)
    else
        bytemove(@oemBuf, @"n/a", 4)


PRI decodeSpeedClass(classByte) : speedClass
' Decode SD Status SPEED_CLASS byte to integer speed class.
'
' @param classByte - Raw byte from SD Status byte[8]
' @returns speedClass - Speed class value (0, 2, 4, 6, or 10)

    case classByte
        $00 : return 0
        $01 : return 2
        $02 : return 4
        $03 : return 6
        $04 : return 10
        other : return 0


CON { license }
{{

 -------------------------------------------------------------------------------------------------
  MIT License

  Copyright (c) 2026 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 =================================================================================================
}}
