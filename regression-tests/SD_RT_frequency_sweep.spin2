'' =================================================================================================
''
''   File....... SD_RT_frequency_sweep.spin2
''   Purpose.... Sweep sysclk frequencies to find failure boundaries for streamer timing
''   Author..... Claude + Stephen M Moraco
''   Started.... JAN 2026
''
'' =================================================================================================
''
''   This test dynamically changes sysclk frequency using clkset() to find exactly where
''   the V2 driver's multi-block operations fail. The goal is to identify timing-sensitive
''   frequency ranges and quantization boundaries.
''
''   Test Matrix (from SYSCLK-TIMING-ANALYSIS.md):
''     320 MHz - hp=7, PASS (baseline verified)
''     310 MHz - hp=7
''     305 MHz - hp=7 (boundary, hp changes 7->6 below this)
''     300 MHz - hp=6, exact 25 MHz SPI
''     295 MHz - hp=6
''     290 MHz - hp=6
''     280 MHz - hp=6
''     270 MHz - hp=6, FAIL (verified)
''     260 MHz - hp=6
''     255 MHz - hp=6 (boundary, hp changes 6->5 below this)
''     250 MHz - hp=5, HDMI target
''     240 MHz - hp=5
''     200 MHz - hp=4, exact division
''
''   The test runs writeSectorsRaw(8) + readSectorsRaw(8) and checks data integrity.
''   This is the exact operation that fails at 270 MHz.
''
'' =================================================================================================

CON

    ' Start at 320 MHz for initial mount
    _CLKFREQ        = 270_000_000

    ' P2 Edge module SD slot pins
    SD_CS   = 60
    SD_MOSI = 59
    SD_MISO = 58
    SD_SCK  = 61

    ' Test parameters
    TEST_SECTOR_BASE = 200_100          ' Different from other tests to avoid collisions
    TEST_COUNT       = 8                ' 8 sectors = 4KB
    SECTOR_SIZE      = 512

    ' Frequency test points (in MHz)
    #0, FREQ_320, FREQ_310, FREQ_305, FREQ_300, FREQ_295, FREQ_290
    #6, FREQ_280, FREQ_270, FREQ_260, FREQ_255, FREQ_250, FREQ_240
    #12, FREQ_220, FREQ_200, FREQ_COUNT

OBJ
    sd : "SD_card_driver"

DAT
    ' Test frequencies in Hz
    freq_table      long    320_000_000     ' FREQ_320 - hp=7, baseline
                    long    310_000_000     ' FREQ_310 - hp=7
                    long    305_000_000     ' FREQ_305 - hp=7 (boundary)
                    long    300_000_000     ' FREQ_300 - hp=6, exact 25 MHz
                    long    295_000_000     ' FREQ_295 - hp=6
                    long    290_000_000     ' FREQ_290 - hp=6
                    long    280_000_000     ' FREQ_280 - hp=6
                    long    270_000_000     ' FREQ_270 - hp=6 (known fail)
                    long    260_000_000     ' FREQ_260 - hp=6
                    long    255_000_000     ' FREQ_255 - hp=6 (boundary)
                    long    250_000_000     ' FREQ_250 - hp=5, HDMI target
                    long    240_000_000     ' FREQ_240 - hp=5
                    long    220_000_000     ' FREQ_220 - hp=5
                    long    200_000_000     ' FREQ_200 - hp=4, exact

    ' Expected half_period for each frequency (for reference)
    hp_table        byte    7, 7, 7         ' 320, 310, 305
                    byte    6, 6, 6, 6, 6, 6, 6   ' 300-255 range
                    byte    5, 5, 5         ' 250, 240, 220
                    byte    4               ' 200

    ' Results storage: 0=untested, 1=PASS, 2=FAIL
    results         byte    0[FREQ_COUNT]

VAR
    BYTE    write_buf[TEST_COUNT * SECTOR_SIZE]
    BYTE    read_buf[TEST_COUNT * SECTOR_SIZE]
    LONG    pass_count
    LONG    fail_count

PUB go() | result, freq_idx, test_freq, errors, hp

    debug(" ")
    debug("============================================================")
    debug("  SD Frequency Sweep Test (V2 Driver)")
    debug("============================================================")
    debug("  Purpose: Find sysclk frequencies where streamer timing fails")
    debug("  Test: writeSectorsRaw(8) + readSectorsRaw(8) + verify")
    debug(" ")

    pass_count := 0
    fail_count := 0

    ' Mount at 320 MHz first (known working)
    debug("Initial mount at 320 MHz...")
    result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    if result == false
        debug("ERROR: Initial mount failed!")
        debug("END_SESSION")
        return

    debug("Card mounted successfully")
    debug(" ")

    ' Fill write buffer with test pattern
    fillTestPattern()

    ' Run baseline test at 320 MHz
    debug("--- BASELINE TEST @ 320 MHz ---")
    errors := runTest(320_000_000)
    if errors == 0
        debug("  -> PASS (baseline verified)")
        results[FREQ_320] := 1
        pass_count++
    else
        debug("  -> FAIL: ", udec_(errors), " errors at baseline - ABORTING")
        debug("END_SESSION")
        return

    debug(" ")
    debug("============================================================")
    debug("  FREQUENCY SWEEP")
    debug("============================================================")

    ' Sweep through all test frequencies
    repeat freq_idx from 1 to FREQ_COUNT - 1
        test_freq := long[@freq_table][freq_idx]
        hp := byte[@hp_table][freq_idx]

        debug(" ")
        debug("--- ", udec_(test_freq / 1_000_000), " MHz (hp=", udec_(hp), ") ---")

        ' Change system clock
        changeFrequency(test_freq)

        ' Small delay for clock to stabilize
        waitms(10)

        ' Verify frequency change
        debug("  clkfreq = ", udec_(clkfreq))

        ' Run the critical test
        errors := runTest(test_freq)

        if errors == 0
            debug("  -> PASS")
            results[freq_idx] := 1
            pass_count++
        else
            debug("  -> FAIL: ", udec_(errors), " byte errors")
            results[freq_idx] := 2
            fail_count++

    ' Return to 320 MHz for summary
    changeFrequency(320_000_000)
    waitms(10)

    ' Print summary
    debug(" ")
    debug("============================================================")
    debug("  FREQUENCY SWEEP RESULTS")
    debug("============================================================")
    debug(" ")
    debug("  Freq    hp   Result")
    debug("  ------  ---  ------")

    repeat freq_idx from 0 to FREQ_COUNT - 1
        test_freq := long[@freq_table][freq_idx]
        hp := byte[@hp_table][freq_idx]
        case results[freq_idx]
            1: debug("  ", udec_long_(test_freq / 1_000_000), " MHz  ", udec_(hp), "   PASS")
            2: debug("  ", udec_long_(test_freq / 1_000_000), " MHz  ", udec_(hp), "   FAIL")
            other: debug("  ", udec_long_(test_freq / 1_000_000), " MHz  ", udec_(hp), "   ???")

    debug(" ")
    debug("  Total: ", udec_(pass_count), " PASS, ", udec_(fail_count), " FAIL")
    debug(" ")

    ' Identify boundaries
    debug("============================================================")
    debug("  BOUNDARY ANALYSIS")
    debug("============================================================")
    analyzeBoundaries()

    debug(" ")
    debug("END_SESSION")


PRI fillTestPattern() | i
    '' Fill write buffer with deterministic pattern
    '' Pattern: each byte = (sector_num * 17 + byte_offset) & $FF
    repeat i from 0 to (TEST_COUNT * SECTOR_SIZE) - 1
        write_buf[i] := ((i / SECTOR_SIZE) * 17 + (i // SECTOR_SIZE)) & $FF


PRI runTest(freq) : errors | written, readCt, i, sector
    '' Run the critical test: writeSectorsRaw + readSectorsRaw + verify
    '' This is exactly what fails at 270 MHz
    '' Returns number of byte errors (0 = pass)

    errors := 0
    sector := TEST_SECTOR_BASE

    ' Write 8 sectors
    written := sd.writeSectorsRaw(sector, TEST_COUNT, @write_buf)
    if written <> TEST_COUNT
        debug("  writeSectorsRaw returned ", udec_(written))
        return -1  ' Indicate complete failure

    ' Clear read buffer
    bytefill(@read_buf, $00, TEST_COUNT * SECTOR_SIZE)

    ' Read 8 sectors
    readCt := sd.readSectorsRaw(sector, TEST_COUNT, @read_buf)
    if readCt <> TEST_COUNT
        debug("  readSectorsRaw returned ", udec_(readCt))
        return -1  ' Indicate complete failure

    ' Verify all bytes
    repeat i from 0 to (TEST_COUNT * SECTOR_SIZE) - 1
        if read_buf[i] <> write_buf[i]
            if errors < 3
                debug("  byte ", udec_(i), ": exp=$", uhex_byte_(write_buf[i]), " got=$", uhex_byte_(read_buf[i]))
            errors++

    return errors


PRI changeFrequency(target_freq) | xi, div, mode
    '' Change system clock to target frequency using PLL
    '' We use the same crystal (20 MHz) and adjust PLL multiplier

    ' Calculate PLL settings for target frequency
    ' P2 uses: sysclk = xtalfreq * pll_mult / div
    ' With 20 MHz crystal:
    '   320 MHz = 20 * 16 / 1
    '   310 MHz = 20 * 31 / 2
    '   305 MHz = 20 * 61 / 4 (approximation)
    '   300 MHz = 20 * 15 / 1
    '   etc.

    ' For simplicity, use RCFAST-based calculations
    ' Actually, we need to be careful here. Let me use the proper clkset approach.

    ' The P2 clkset value encodes: [31:24]=XDIV, [23:16]=MULT, [15:8]=POST, [7:0]=MODE
    ' Mode $FC = PLL enabled, XI enabled

    case target_freq
        320_000_000:
            ' 20 MHz * 16 = 320 MHz
            clkset(%1_000001_0000001111_10_11, target_freq)
        310_000_000:
            ' 20 MHz * 31 / 2 = 310 MHz
            clkset(%1_000001_0000011110_10_11, target_freq)
        305_000_000:
            ' 20 MHz * 61 / 4 = 305 MHz (close)
            clkset(%1_000010_0000111100_10_11, target_freq)
        300_000_000:
            ' 20 MHz * 15 = 300 MHz
            clkset(%1_000001_0000001110_10_11, target_freq)
        295_000_000:
            ' 20 MHz * 59 / 4 = 295 MHz (close)
            clkset(%1_000010_0000111010_10_11, target_freq)
        290_000_000:
            ' 20 MHz * 29 / 2 = 290 MHz
            clkset(%1_000001_0000011100_10_11, target_freq)
        280_000_000:
            ' 20 MHz * 14 = 280 MHz
            clkset(%1_000001_0000001101_10_11, target_freq)
        270_000_000:
            ' 20 MHz * 27 / 2 = 270 MHz
            clkset(%1_000001_0000011010_10_11, target_freq)
        260_000_000:
            ' 20 MHz * 13 = 260 MHz
            clkset(%1_000001_0000001100_10_11, target_freq)
        255_000_000:
            ' 20 MHz * 51 / 4 = 255 MHz (close)
            clkset(%1_000010_0000110010_10_11, target_freq)
        250_000_000:
            ' 20 MHz * 25 / 2 = 250 MHz
            clkset(%1_000001_0000011000_10_11, target_freq)
        240_000_000:
            ' 20 MHz * 12 = 240 MHz
            clkset(%1_000001_0000001011_10_11, target_freq)
        220_000_000:
            ' 20 MHz * 11 = 220 MHz
            clkset(%1_000001_0000001010_10_11, target_freq)
        200_000_000:
            ' 20 MHz * 10 = 200 MHz
            clkset(%1_000001_0000001001_10_11, target_freq)


PRI analyzeBoundaries() | i, prev_result, curr_result, prev_freq, curr_freq, prev_hp, curr_hp
    '' Identify where PASS->FAIL and FAIL->PASS transitions occur

    prev_result := results[0]
    prev_freq := long[@freq_table][0] / 1_000_000
    prev_hp := byte[@hp_table][0]

    repeat i from 1 to FREQ_COUNT - 1
        curr_result := results[i]
        curr_freq := long[@freq_table][i] / 1_000_000
        curr_hp := byte[@hp_table][i]

        if prev_result <> curr_result and prev_result > 0 and curr_result > 0
            if prev_result == 1 and curr_result == 2
                debug("  PASS->FAIL boundary: ", udec_(prev_freq), "-", udec_(curr_freq), " MHz")
                if prev_hp <> curr_hp
                    debug("    (hp boundary: ", udec_(prev_hp), "->", udec_(curr_hp), ")")
            elseif prev_result == 2 and curr_result == 1
                debug("  FAIL->PASS boundary: ", udec_(prev_freq), "-", udec_(curr_freq), " MHz")
                if prev_hp <> curr_hp
                    debug("    (hp boundary: ", udec_(prev_hp), "->", udec_(curr_hp), ")")

        prev_result := curr_result
        prev_freq := curr_freq
        prev_hp := curr_hp
