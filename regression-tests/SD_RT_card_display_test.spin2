{Spin2_v49}
'' =================================================================================================
''
''   File....... SD_RT_card_display_test.spin2
''   Purpose.... Test do_card_info() fstr output with actual SD card driver + data
''   Authors.... Claude + Stephen M Moraco
''   Started.... FEB 2026
''
'' =================================================================================================
''
''   Tests whether fstr6/fstr5/fstr3 produce correct output when:
''     - SD card driver is loaded (with worker cog)
''     - Card is mounted (real register data)
''     - Struct locals (sd.cid_t, sd.scr_t) are used
''     - lookupMID with @@WORD[] DAT table
''     - detectFilesystem with sector reads into buf2
''     - VBR OEM name extraction from partition boot record
''
''   This replicates the EXACT do_card_info() code from SD_demo_shell.spin2
''   but runs non-interactively for headless testing.
''
''   Usage: ./run_test.sh ../regression-tests/SD_RT_card_display_test.spin2
''
'' =================================================================================================

CON

  CLK_FREQ = 270_000_000
  _clkfreq = CLK_FREQ

  BR_TERM  = 2_000_000

  ' P2 Edge module SD slot pins
  SD_CS    = 60
  SD_SCK   = 61
  SD_MOSI  = 59
  SD_MISO  = 58

  MBR_SIGNATURE = $AA55

#PRAGMA EXPORTDEF SD_INCLUDE_ALL


OBJ

  sd     : "micro_sd_fat32_fs"
  serial : "isp_serial_singleton"


DAT

  ' Sector buffer for MBR/VBR reads
  buf2            byte    0[512]

  ' Manufacturer lookup table - word pairs: MID, pointer to name (same as demo shell)
  midTable
              word    $02, @midKioxia
              word    $03, @midSanDisk
              word    $09, @midATP
              word    $1B, @midSamsung
              word    $1D, @midADATA
              word    $27, @midPhison
              word    $28, @midLexar
              word    $41, @midKingston
              word    $45, @midTeam
              word    $6F, @midHiksemi
              word    $74, @midGigastone
              word    $82, @midSony
              word    $9C, @midAngelbird
              word    $9F, @midSharedOEM
              word    $AD, @midLongsys
              word    $00, 0                                           ' end sentinel

  midKioxia       byte    "Kioxia", 0
  midSanDisk      byte    "SanDisk", 0
  midATP          byte    "ATP", 0
  midSamsung      byte    "Samsung", 0
  midADATA        byte    "ADATA", 0
  midPhison       byte    "Phison", 0
  midLexar        byte    "Lexar", 0
  midKingston     byte    "Kingston", 0
  midTeam         byte    "TEAM", 0
  midHiksemi      byte    "Hiksemi", 0
  midGigastone    byte    "Gigastone", 0
  midSony         byte    "Sony", 0
  midAngelbird    byte    "Angelbird", 0
  midSharedOEM    byte    "OEM", 0
  midLongsys      byte    "Longsys", 0
  midUnknown      byte    "MID:$", 0

  ' Filesystem type strings
  fsUnknown       byte    "Unknown", 0
  fsFAT32         byte    "FAT32", 0
  fsFAT16         byte    "FAT16", 0
  fsFAT12         byte    "FAT12", 0
  fsEmpty         byte    "Empty", 0

  ' Card type strings
  ctSDSC          byte    "SDSC", 0
  ctSDHC          byte    "SDHC", 0
  ctSDXC          byte    "SDXC", 0

  ' Unknown MID formatting buffer
  midBuf          byte    0[8]


PUB go() | result

  serial.start(BR_TERM)
  waitms(100)

  serial.fstr0(@"============================================================\r\n")
  serial.fstr0(@"  Card Display Test\r\n")
  serial.fstr0(@"  Tests fstr6/5/3 with SD driver + real card data\r\n")
  serial.fstr0(@"============================================================\r\n")
  serial.fstr0(@" \r\n")

  ' Mount the card
  serial.fstr0(@"=== Mounting card ===\r\n")
  result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
  if (not result)
    serial.fstr1(@"Mount FAILED, error: %d\r\n", sd.error())
    serial.fstr0(@"END_SESSION\r\n")
    return

  serial.fstr0(@"Mount OK\r\n")
  serial.fstr0(@" \r\n")

  ' Run the do_card_info logic
  serial.fstr0(@"=== do_card_info output ===\r\n")
  testCardInfo()
  serial.fstr0(@" \r\n")

  ' Unmount
  sd.unmount()

  serial.fstr0(@"============================================================\r\n")
  serial.fstr0(@"  Card display test complete\r\n")
  serial.fstr0(@"============================================================\r\n")
  serial.fstr0(@"END_SESSION\r\n")


PRI testCardInfo() | sd.cid_t cid, sd.scr_t scr, ...
                     ocr, sizeMB, spiHz, psn, mdtYear, mdtMonth, ...
                     pnm[2], p_mfr, p_type, p_spec, p_fs, ...
                     oemBuf[3], partStart, i, pPart

'' Exact replica of do_card_info() display logic from SD_demo_shell.spin2

  ' Read card registers into struct locals
  sd.readCIDRaw(@cid)
  sd.readSCRRaw(@scr)
  ocr := sd.getOCR()
  sizeMB := sd.cardSizeSectors() / 2048
  spiHz := sd.getSPIFrequency()

  ' Parse CID: product name (5 bytes, null-terminated)
  bytemove(@pnm, @cid.pnm, 5)
  BYTE[@pnm + 5] := 0

  ' Parse CID: serial number (4 bytes big-endian -> 32-bit LONG)
  psn := (cid.psn[0] << 24) | (cid.psn[1] << 16) | (cid.psn[2] << 8) | cid.psn[3]

  ' Parse CID: manufacturing date
  mdtYear := 2000 + ((cid.mdt[0] & $0F) << 4) + ((cid.mdt[1] >> 4) & $0F)
  mdtMonth := cid.mdt[1] & $0F

  ' Look up descriptive strings
  p_mfr := lookupMID(cid.mid)
  p_type := getCardType(ocr, sizeMB)
  p_spec := getSDSpecVersion(@scr)
  p_fs := detectFilesystem()

  ' Print individual values first (diagnostic)
  serial.fstr0(@"--- Individual values ---\r\n")
  serial.fstr1(@"  p_mfr:  [%s]\r\n", p_mfr)
  serial.fstr1(@"  @pnm:   [%s]\r\n", @pnm)
  serial.fstr1(@"  p_type: [%s]\r\n", p_type)
  serial.fstr1(@"  p_fs:   [%s]\r\n", p_fs)
  serial.fstr1(@"  p_spec: [%s]\r\n", p_spec)
  serial.fstr2(@"  sizeMB: %d (%dGB)\r\n", sizeMB, sizeMB / 1024)
  serial.fstr1(@"  spiHz:  %d\r\n", spiHz)
  serial.fstr0(@" \r\n")

  ' Read VBR OEM name from partition boot record
  sd.readSectorRaw(0, @buf2)
  if WORD[@buf2 + $1FE] == MBR_SIGNATURE
    pPart := @buf2 + $1BE
    partStart := LONG[pPart + 8]
    if partStart > 0
      sd.readSectorRaw(partStart, @buf2)
      bytemove(@oemBuf, @buf2 + 3, 8)
      BYTE[@oemBuf + 8] := 0
      ' Trim trailing spaces
      i := 7
      repeat while i >= 0 AND BYTE[@oemBuf + i] == " "
        BYTE[@oemBuf + i] := 0
        i--
    else
      bytemove(@oemBuf, @"n/a", 4)
  else
    bytemove(@oemBuf, @"n/a", 4)

  serial.fstr1(@"  oemBuf: [%s]\r\n", @oemBuf)
  serial.fstr0(@" \r\n")

  ' === THE OUTPUT: exact do_card_info format strings ===
  serial.fstr0(@"--- Two-line card display ---\r\n")

  ' Line 1 part A: Mfr Product Type Size [FS] Spec
  if sizeMB < 1024
    serial.fstr6(@"%s %s %s %dMB [%s] %s", p_mfr, @pnm, p_type, sizeMB, p_fs, p_spec)
  else
    serial.fstr6(@"%s %s %s %dGB [%s] %s", p_mfr, @pnm, p_type, sizeMB / 1024, p_fs, p_spec)

  ' Line 1 part B: rev SN date
  serial.fstr5(@" rev%d.%d SN:%.8x %d/%.2d\r\n", cid.prv >> 4, cid.prv & $0F, psn, mdtYear, mdtMonth)

  ' Line 2: SPI frequency and OEM name
  serial.fstr3(@"SPI %d.%d MHz  [%s]\r\n", spiHz / 1_000_000, (spiHz / 100_000) // 10, @oemBuf)


PRI lookupMID(mid) : p_name | p, entryMID

'' Look up manufacturer name from MID byte.
'' Returns pointer to name string, or "MID:$NN" for unknown.

  p := @midTable
  repeat
    entryMID := WORD[p]
    if entryMID == $00
      ' Unknown - format hex into buffer and return
      bytemove(@midBuf, @midUnknown, 6)
      midBuf[5] := hexDigit(mid >> 4)
      midBuf[6] := hexDigit(mid & $0F)
      midBuf[7] := 0
      return @midBuf
    if entryMID == mid
      return @@WORD[p + 2]
    p += 4


PRI hexDigit(nibble) : ch

'' Convert 0-15 to ASCII hex digit

  if nibble < 10
    return "0" + nibble
  return "A" + nibble - 10


PRI getCardType(ocr, sizeMB) : p_type

'' Determine card type from OCR CCS bit and capacity.

  if (ocr & (1 << 30)) == 0
    return @ctSDSC
  if sizeMB > 32768
    return @ctSDXC
  return @ctSDHC


PRI getSDSpecVersion(^sd.scr_t p_scr) : p_version | sdSpec, spec3, spec4, specX

'' Decode SD spec version from SCR register struct.

  sdSpec := p_scr.sdSpec & $0F
  spec3 := (p_scr.sdSpec3Ext >> 7) & 1
  spec4 := (p_scr.sdSpec3Ext >> 2) & 1
  specX := ((p_scr.sdSpec3Ext & $03) << 2) | ((p_scr.sdSpecXLo >> 6) & $03)

  if sdSpec < 2
    return @"SD 1.x"
  if spec3 == 0
    return @"SD 2.0"
  if spec4 == 0
    return @"SD 3.x"
  if specX == 0
    return @"SD 4.x"
  if specX == 1
    return @"SD 5.x"
  if specX == 2
    return @"SD 6.x"
  if specX == 3
    return @"SD 7.x"
  if specX == 4
    return @"SD 8.x"
  if specX == 5
    return @"SD 9.x"
  return @"SD ??"


PRI detectFilesystem() : p_fsName | pType

'' Read MBR sector 0 to determine filesystem type from partition type byte.
'' Uses buf2 for the read. Returns pointer to filesystem name string.

  sd.readSectorRaw(0, @buf2)

  ' Check MBR signature
  if WORD[@buf2 + $1FE] <> MBR_SIGNATURE
    return @fsUnknown

  pType := BYTE[@buf2 + $1C2]

  case pType
    $00 : return @fsEmpty
    $01 : return @fsFAT12
    $04, $06, $0E : return @fsFAT16
    $0B, $0C : return @fsFAT32
    other : return @fsUnknown
