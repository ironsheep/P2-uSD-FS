'' =================================================================================================
''
''   File....... SD_RT_seek_tests.spin2
''   Purpose.... This object exercises seek operations and random access reading
''   Author..... Stephen M Moraco
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... JAN 2026
''   Updated.... 16 JAN 2026
''
'' =================================================================================================

CON

     _CLKFREQ        = 270_000_000

     ' Pin configuration for P2 Edge with SD card
     SD_CS   = 60
     SD_MOSI = 59
     SD_MISO = 58
     SD_SCK  = 61

     TEST_FILE_SIZE = 2048    ' 4 sectors worth

OBJ
    sd    : "SD_card_driver"
    utils : "SD_RT_utilities"

DAT

' Test filename
testSeek        BYTE    "RTSEEK.BIN", 0
testEmpty       BYTE    "RTEMPTY.BIN", 0

' Buffers
writeBuffer     BYTE    0[TEST_FILE_SIZE]
readBuffer      BYTE    0[64]

PUB go() | result, bytesRead, idx, fileSize, expectedByte, actualByte
'' Main entry point for seek operation regression tests
''
'' Tests seek operations and random access reading

    debug(" ")
    debug("==============================================")
    debug("  SD Card Driver - Seek Tests")
    debug("==============================================")

    ' Mount the card first
    result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    if result == false
        debug("ERROR: Could not mount SD card!")
        debug("END_SESSION")
        return

    ' Show card info
    debug(" ")
    debug("* SD Card Information:")
    debug("   Volume Label: ", zstr_(sd.volumeLabel()))
    debug("   Free Space: ", udec(sd.freeSpace()), " sectors")

    ' Clean up any existing test file
    sd.deleteFile(@testSeek)

    ' ----------------------------------
    ' Create test file with known pattern
    ' ----------------------------------
    utils.startTestGroup(@"Create Test File")

    ' Fill buffer with pattern: each byte = position & $FF (setup)
    repeat idx from 0 to TEST_FILE_SIZE - 1
        writeBuffer[idx] := idx & $FF
    debug("  Buffer filled with position pattern (0-255 repeating)")

    utils.startTest(@"Create test file with 2048 bytes")
    result := sd.newFile(@testSeek)
    utils.evaluateBool(result, @"newFile()", true)

    ' Write test data and close (setup)
    sd.write(@writeBuffer, TEST_FILE_SIZE)
    sd.closeFile()
    debug("  Wrote ", udec_(TEST_FILE_SIZE), " bytes")

    utils.startTest(@"Verify file size")
    result := sd.openFile(@testSeek)
    fileSize := sd.fileSize()
    utils.evaluateSingleValue(fileSize, @"fileSize()", TEST_FILE_SIZE)
    sd.closeFile()

    ' ----------------------------------
    ' TEST GROUP: Basic seek operations
    ' ----------------------------------
    utils.startTestGroup(@"Basic Seek Operations")

    utils.startTest(@"Open file for seek tests")
    result := sd.openFile(@testSeek)
    utils.evaluateBool(result, @"openFile()", true)

    utils.startTest(@"seek(0) - beginning of file")
    result := sd.seek(0)
    utils.evaluateBool(result, @"seek(0)", true)

    utils.startTest(@"Read byte at position 0")
    bytesRead := sd.read(@readBuffer, 1)
    utils.evaluateSingleValue(readBuffer[0], @"byte at 0", 0)

    utils.startTest(@"seek(100) - position 100")
    result := sd.seek(100)
    utils.evaluateBool(result, @"seek(100)", true)

    utils.startTest(@"Read byte at position 100")
    bytesRead := sd.read(@readBuffer, 1)
    utils.evaluateSingleValue(readBuffer[0], @"byte at 100", 100)

    utils.startTest(@"seek(255) - position 255")
    result := sd.seek(255)
    utils.evaluateBool(result, @"seek(255)", true)

    utils.startTest(@"Read byte at position 255")
    bytesRead := sd.read(@readBuffer, 1)
    utils.evaluateSingleValue(readBuffer[0], @"byte at 255", 255)

    utils.startTest(@"seek(256) - position 256 (wraps to 0 in pattern)")
    result := sd.seek(256)
    utils.evaluateBool(result, @"seek(256)", true)

    utils.startTest(@"Read byte at position 256")
    bytesRead := sd.read(@readBuffer, 1)
    utils.evaluateSingleValue(readBuffer[0], @"byte at 256", 0)  ' 256 & $FF = 0

    sd.closeFile()

    ' ----------------------------------
    ' TEST GROUP: Cross-sector seeks
    ' ----------------------------------
    utils.startTestGroup(@"Cross-Sector Seeks")

    utils.startTest(@"Open file")
    result := sd.openFile(@testSeek)
    utils.evaluateBool(result, @"openFile()", true)

    ' Sector boundary is at 512 bytes
    utils.startTest(@"seek(511) - last byte of first sector")
    result := sd.seek(511)
    utils.evaluateBool(result, @"seek(511)", true)

    utils.startTest(@"Read byte at 511")
    bytesRead := sd.read(@readBuffer, 1)
    utils.evaluateSingleValue(readBuffer[0], @"byte at 511", 511 & $FF)

    utils.startTest(@"seek(512) - first byte of second sector")
    result := sd.seek(512)
    utils.evaluateBool(result, @"seek(512)", true)

    utils.startTest(@"Read byte at 512")
    bytesRead := sd.read(@readBuffer, 1)
    utils.evaluateSingleValue(readBuffer[0], @"byte at 512", 512 & $FF)

    utils.startTest(@"seek(1023) - last byte of second sector")
    result := sd.seek(1023)
    utils.evaluateBool(result, @"seek(1023)", true)

    utils.startTest(@"Read byte at 1023")
    bytesRead := sd.read(@readBuffer, 1)
    utils.evaluateSingleValue(readBuffer[0], @"byte at 1023", 1023 & $FF)

    utils.startTest(@"seek(1024) - first byte of third sector")
    result := sd.seek(1024)
    utils.evaluateBool(result, @"seek(1024)", true)

    utils.startTest(@"Read byte at 1024")
    bytesRead := sd.read(@readBuffer, 1)
    utils.evaluateSingleValue(readBuffer[0], @"byte at 1024", 1024 & $FF)

    sd.closeFile()

    ' ----------------------------------
    ' TEST GROUP: Random access pattern
    ' ----------------------------------
    utils.startTestGroup(@"Random Access Pattern")

    utils.startTest(@"Open file")
    result := sd.openFile(@testSeek)
    utils.evaluateBool(result, @"openFile()", true)

    utils.startTest(@"Random seeks and reads")
    utils.setCheckCountPerTest(2)

    ' Test several random positions
    testSeekPosition(1500)
    testSeekPosition(200)
    testSeekPosition(1999)
    testSeekPosition(0)
    testSeekPosition(750)
    testSeekPosition(2000)
    testSeekPosition(512)
    testSeekPosition(1024)

    sd.closeFile()

    ' ----------------------------------
    ' TEST GROUP: readByte() with position
    ' ----------------------------------
    utils.startTestGroup(@"readByte() Random Access")

    utils.startTest(@"Open file")
    result := sd.openFile(@testSeek)
    utils.evaluateBool(result, @"openFile()", true)

    utils.startTest(@"readByte(0)")
    actualByte := sd.readByte(0)
    utils.evaluateSingleValue(actualByte, @"readByte(0)", 0)

    utils.startTest(@"readByte(100)")
    actualByte := sd.readByte(100)
    utils.evaluateSingleValue(actualByte, @"readByte(100)", 100)

    utils.startTest(@"readByte(512)")
    actualByte := sd.readByte(512)
    utils.evaluateSingleValue(actualByte, @"readByte(512)", 512 & $FF)

    utils.startTest(@"readByte(1000)")
    actualByte := sd.readByte(1000)
    utils.evaluateSingleValue(actualByte, @"readByte(1000)", 1000 & $FF)

    sd.closeFile()

    ' ----------------------------------
    ' TEST GROUP: Seek beyond EOF
    ' ----------------------------------
    utils.startTestGroup(@"Seek Edge Cases")

    utils.startTest(@"Open file")
    result := sd.openFile(@testSeek)
    utils.evaluateBool(result, @"openFile()", true)

    utils.startTest(@"seek() beyond EOF should fail")
    result := sd.seek(TEST_FILE_SIZE + 100)
    utils.evaluateBool(result, @"seek(beyond EOF)", false)

    utils.startTest(@"seek() to exact EOF should succeed")
    result := sd.seek(TEST_FILE_SIZE - 1)
    utils.evaluateBool(result, @"seek(EOF-1)", true)

    utils.startTest(@"Read at EOF position")
    bytesRead := sd.read(@readBuffer, 1)
    utils.evaluateSingleValue(readBuffer[0], @"byte at EOF-1", (TEST_FILE_SIZE - 1) & $FF)

    sd.closeFile()

    ' ----------------------------------
    ' TEST GROUP: Sequential vs seek read
    ' ----------------------------------
    utils.startTestGroup(@"Sequential vs Seek Read Comparison")

    utils.startTest(@"Open file")
    result := sd.openFile(@testSeek)
    utils.evaluateBool(result, @"openFile()", true)

    utils.startTest(@"Sequential read first 10 bytes")
    utils.setCheckCountPerTest(10)
    bytesRead := sd.read(@readBuffer, 10)
    repeat idx from 0 to 9
        utils.evaluateSubValue(readBuffer[idx], @"sequential byte", idx)

    utils.startTest(@"Seek back and re-read")
    sd.seek(0)
    utils.setCheckCountPerTest(10)
    bytesRead := sd.read(@readBuffer, 10)
    repeat idx from 0 to 9
        utils.evaluateSubValue(readBuffer[idx], @"re-read byte", idx)

    sd.closeFile()

    ' ----------------------------------
    ' TEST GROUP: Seek Boundary Conditions
    ' ----------------------------------
    utils.startTestGroup(@"Seek Boundary Conditions")

    ' Test: Seek to position 0 returns to absolute start
    utils.startTest(@"Seek to position 0 returns to absolute start")
    result := sd.openFile(@testSeek)
    if result
        ' First read to move position forward
        sd.read(@readBuffer, 50)
        ' Now seek back to 0
        result := sd.seek(0)
        utils.evaluateSubBool(result, @"seek(0)", true)
        ' Read first byte - verifies we're at position 0
        bytesRead := sd.read(@readBuffer, 1)
        utils.evaluateSubValue(readBuffer[0], @"first byte", 0)
        sd.closeFile()

    ' Test: Seek to exact EOF and verify read returns 0
    utils.startTest(@"Seek to exact EOF position")
    result := sd.openFile(@testSeek)
    if result
        ' Seek to exact end (file size position)
        result := sd.seek(TEST_FILE_SIZE)
        ' This should succeed - seeking to EOF is valid
        ' (seeking past EOF is what fails)
        debug("  seek(", udec_(TEST_FILE_SIZE), ") = ", sdec_(result))
        ' Try to read - should get 0 bytes
        bytesRead := sd.read(@readBuffer, 10)
        utils.evaluateSingleValue(bytesRead, @"read at EOF", 0)
        sd.closeFile()

    ' Test: Seek in empty file
    utils.startTest(@"Seek in empty file behavior")
    sd.deleteFile(@testEmpty)
    result := sd.newFile(@testEmpty)
    if result
        sd.closeFile()  ' Create 0-byte file
    result := sd.openFile(@testEmpty)
    if result
        ' Try seek(0) in empty file - should succeed
        result := sd.seek(0)
        utils.evaluateSubBool(result, @"seek(0) in empty", true)
        ' Try to read - should get 0 bytes
        bytesRead := sd.read(@readBuffer, 1)
        utils.evaluateSubValue(bytesRead, @"read from empty", 0)
        ' Try seek(1) in empty file - should fail (beyond EOF)
        result := sd.seek(1)
        utils.evaluateSubBool(result == false, @"seek(1) in empty fails", true)
        sd.closeFile()
    sd.deleteFile(@testEmpty)

    ' ----------------------------------
    ' Cleanup
    ' ----------------------------------
    debug(" ")
    debug("* Cleaning up test file...")
    sd.deleteFile(@testSeek)

    ' Unmount
    sd.unmount()

    ' ----------------------------------
    ' Summary
    ' ----------------------------------
    utils.ShowTestEndCounts()

    debug(" ")
    debug("* Seek Tests Complete")
    debug("END_SESSION")


PRI testSeekPosition(position) | result, bytesRead, expectedByte
' Helper to test seek to a position and verify content
'
' @param position - file position to seek to and verify

    result := sd.seek(position)
    expectedByte := position & $FF
    bytesRead := sd.read(@readBuffer, 1)
    utils.evaluateSubBool(result, @"seek()", true)
    utils.evaluateSubValue(readBuffer[0], @"byte value", expectedByte)
    debug("  Position ", udec_(position), ": expected $", uhex_(expectedByte), " got $", uhex_(readBuffer[0]))


con { license }

{{
  =================================================================================================

  Terms of Use: MIT License

  Copyright (c) 2026 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  =================================================================================================
}}
