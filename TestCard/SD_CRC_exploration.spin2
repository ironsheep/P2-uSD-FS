'' =================================================================================================
''
''   File....... SD_CRC_exploration.spin2
''   Purpose.... Crack the GETCRC algorithm relationship
''   Author..... Stephen M Moraco
''   Started.... 31 JAN 2026
''
'' =================================================================================================

CON

    _CLKFREQ = 320_000_000

DAT

'' CRC-16-CCITT LOOKUP TABLE
crc16_table     WORD    $0000, $1021, $2042, $3063, $4084, $50a5, $60c6, $70e7
                WORD    $8108, $9129, $a14a, $b16b, $c18c, $d1ad, $e1ce, $f1ef
                WORD    $1231, $0210, $3273, $2252, $52b5, $4294, $72f7, $62d6
                WORD    $9339, $8318, $b37b, $a35a, $d3bd, $c39c, $f3ff, $e3de
                WORD    $2462, $3443, $0420, $1401, $64e6, $74c7, $44a4, $5485
                WORD    $a56a, $b54b, $8528, $9509, $e5ee, $f5cf, $c5ac, $d58d
                WORD    $3653, $2672, $1611, $0630, $76d7, $66f6, $5695, $46b4
                WORD    $b75b, $a77a, $9719, $8738, $f7df, $e7fe, $d79d, $c7bc
                WORD    $48c4, $58e5, $6886, $78a7, $0840, $1861, $2802, $3823
                WORD    $c9cc, $d9ed, $e98e, $f9af, $8948, $9969, $a90a, $b92b
                WORD    $5af5, $4ad4, $7ab7, $6a96, $1a71, $0a50, $3a33, $2a12
                WORD    $dbfd, $cbdc, $fbbf, $eb9e, $9b79, $8b58, $bb3b, $ab1a
                WORD    $6ca6, $7c87, $4ce4, $5cc5, $2c22, $3c03, $0c60, $1c41
                WORD    $edae, $fd8f, $cdec, $ddcd, $ad2a, $bd0b, $8d68, $9d49
                WORD    $7e97, $6eb6, $5ed5, $4ef4, $3e13, $2e32, $1e51, $0e70
                WORD    $ff9f, $efbe, $dfdd, $cffc, $bf1b, $af3a, $9f59, $8f78
                WORD    $9188, $81a9, $b1ca, $a1eb, $d10c, $c12d, $f14e, $e16f
                WORD    $1080, $00a1, $30c2, $20e3, $5004, $4025, $7046, $6067
                WORD    $83b9, $9398, $a3fb, $b3da, $c33d, $d31c, $e37f, $f35e
                WORD    $02b1, $1290, $22f3, $32d2, $4235, $5214, $6277, $7256
                WORD    $b5ea, $a5cb, $95a8, $8589, $f56e, $e54f, $d52c, $c50d
                WORD    $34e2, $24c3, $14a0, $0481, $7466, $6447, $5424, $4405
                WORD    $a7db, $b7fa, $8799, $97b8, $e75f, $f77e, $c71d, $d73c
                WORD    $26d3, $36f2, $0691, $16b0, $6657, $7676, $4615, $5634
                WORD    $d94c, $c96d, $f90e, $e92f, $99c8, $89e9, $b98a, $a9ab
                WORD    $5844, $4865, $7806, $6827, $18c0, $08e1, $3882, $28a3
                WORD    $cb7d, $db5c, $eb3f, $fb1e, $8bf9, $9bd8, $abbb, $bb9a
                WORD    $4a75, $5a54, $6a37, $7a16, $0af1, $1ad0, $2ab3, $3a92
                WORD    $fd2e, $ed0f, $dd6c, $cd4d, $bdaa, $ad8b, $9de8, $8dc9
                WORD    $7c26, $6c07, $5c64, $4c45, $3ca2, $2c83, $1ce0, $0cc1
                WORD    $ef1f, $ff3e, $cf5d, $df7c, $af9b, $bfba, $8fd9, $9ff8
                WORD    $6e17, $7e36, $4e55, $5e74, $2e93, $3eb2, $0ed1, $1ef0

test_byte       BYTE    0
test_sector     BYTE    0[512]

'' Byte bit-reversal table
byte_rev_table  BYTE    $00, $80, $40, $C0, $20, $A0, $60, $E0, $10, $90, $50, $D0, $30, $B0, $70, $F0
                BYTE    $08, $88, $48, $C8, $28, $A8, $68, $E8, $18, $98, $58, $D8, $38, $B8, $78, $F8
                BYTE    $04, $84, $44, $C4, $24, $A4, $64, $E4, $14, $94, $54, $D4, $34, $B4, $74, $F4
                BYTE    $0C, $8C, $4C, $CC, $2C, $AC, $6C, $EC, $1C, $9C, $5C, $DC, $3C, $BC, $7C, $FC
                BYTE    $02, $82, $42, $C2, $22, $A2, $62, $E2, $12, $92, $52, $D2, $32, $B2, $72, $F2
                BYTE    $0A, $8A, $4A, $CA, $2A, $AA, $6A, $EA, $1A, $9A, $5A, $DA, $3A, $BA, $7A, $FA
                BYTE    $06, $86, $46, $C6, $26, $A6, $66, $E6, $16, $96, $56, $D6, $36, $B6, $76, $F6
                BYTE    $0E, $8E, $4E, $CE, $2E, $AE, $6E, $EE, $1E, $9E, $5E, $DE, $3E, $BE, $7E, $FE
                BYTE    $01, $81, $41, $C1, $21, $A1, $61, $E1, $11, $91, $51, $D1, $31, $B1, $71, $F1
                BYTE    $09, $89, $49, $C9, $29, $A9, $69, $E9, $19, $99, $59, $D9, $39, $B9, $79, $F9
                BYTE    $05, $85, $45, $C5, $25, $A5, $65, $E5, $15, $95, $55, $D5, $35, $B5, $75, $F5
                BYTE    $0D, $8D, $4D, $CD, $2D, $AD, $6D, $ED, $1D, $9D, $5D, $DD, $3D, $BD, $7D, $FD
                BYTE    $03, $83, $43, $C3, $23, $A3, $63, $E3, $13, $93, $53, $D3, $33, $B3, $73, $F3
                BYTE    $0B, $8B, $4B, $CB, $2B, $AB, $6B, $EB, $1B, $9B, $5B, $DB, $3B, $BB, $7B, $FB
                BYTE    $07, $87, $47, $C7, $27, $A7, $67, $E7, $17, $97, $57, $D7, $37, $B7, $77, $F7
                BYTE    $0F, $8F, $4F, $CF, $2F, $AF, $6F, $EF, $1F, $9F, $5F, $DF, $3F, $BF, $7F, $FF


PUB go() | table_crc, getcrc_raw, getcrc_base, i, b, xor_val, transform, manual_lsb_rev

    debug(" ")
    debug("==============================================")
    debug("  GETCRC Algorithm Cracker")
    debug("==============================================")
    debug(" ")

    ' ============================================================
    ' KEY INSIGHT: GETCRC returns base + contribution
    ' For byte $00: base = $0F87 (with poly $8408)
    ' For byte $01: result = $8B8F = $0F87 ^ $8408
    ' ============================================================

    debug("OBSERVATION: GETCRC has a BASE value")
    debug("===================================")

    getcrc_base := GETCRC(@test_byte, $8408, 1)                                 ' test_byte = 0
    debug("GETCRC($8408, $00) = $", uhex_(getcrc_base & $FFFF), " (BASE)")

    test_byte := $01
    getcrc_raw := GETCRC(@test_byte, $8408, 1) & $FFFF
    debug("GETCRC($8408, $01) = $", uhex_(getcrc_raw))
    debug("$8B8F ^ $0F87 = $", uhex_(getcrc_raw ^ getcrc_base), " (should be $8408)")

    test_byte := $80
    getcrc_raw := GETCRC(@test_byte, $8408, 1) & $FFFF
    debug("GETCRC($8408, $80) = $", uhex_(getcrc_raw))
    debug("$1E0E ^ $0F87 = $", uhex_(getcrc_raw ^ getcrc_base))

    ' ============================================================
    ' Try XOR with base value
    ' ============================================================
    debug(" ")
    debug("XOR with BASE approach:")
    debug("======================")

    repeat i from 0 to 7
        case i
            0: b := $00
            1: b := $01
            2: b := $02
            3: b := $04
            4: b := $08
            5: b := $10
            6: b := $40
            7: b := $80

        test_byte := b
        table_crc := word[@crc16_table][b]
        getcrc_raw := GETCRC(@test_byte, $8408, 1) & $FFFF
        xor_val := getcrc_raw ^ getcrc_base

        ' Also compute manual LSB
        manual_lsb_rev := (manualCRC_LSB_byte(b) REV 31) >> 16

        debug("$", uhex_byte_(b), ": tbl=$", uhex_(table_crc), " getcrc=$", uhex_(getcrc_raw), " xor_base=$", uhex_(xor_val), " lsb_rev=$", uhex_(manual_lsb_rev))

    ' ============================================================
    ' KEY DISCOVERY: Try different polynomial formats
    ' Maybe need $11021 (17-bit with implicit x^16 term)?
    ' ============================================================
    debug(" ")
    debug("Try 17-bit polynomial $11021:")
    debug("=============================")

    test_byte := $00
    getcrc_raw := GETCRC(@test_byte, $1_1021, 1)
    debug("GETCRC($11021, $00) = $", uhex_long_(getcrc_raw))

    test_byte := $01
    getcrc_raw := GETCRC(@test_byte, $1_1021, 1)
    debug("GETCRC($11021, $01) = $", uhex_long_(getcrc_raw))

    ' ============================================================
    ' Try polynomial in different bit positions
    ' ============================================================
    debug(" ")
    debug("Polynomial bit position search:")
    debug("================================")

    test_byte := $01

    ' Try poly << 0 through poly << 16
    getcrc_raw := GETCRC(@test_byte, $1021, 1) & $FFFF
    debug("$1021<<0:  getcrc=$", uhex_(getcrc_raw), " target=$1021")

    getcrc_raw := GETCRC(@test_byte, $1021 << 1, 1) & $FFFF
    debug("$1021<<1:  getcrc=$", uhex_(getcrc_raw))

    getcrc_raw := GETCRC(@test_byte, $1021 << 2, 1) & $FFFF
    debug("$1021<<2:  getcrc=$", uhex_(getcrc_raw))

    getcrc_raw := GETCRC(@test_byte, $1021 << 4, 1) & $FFFF
    debug("$1021<<4:  getcrc=$", uhex_(getcrc_raw))

    getcrc_raw := GETCRC(@test_byte, $1021 << 8, 1) & $FFFF
    debug("$1021<<8:  getcrc=$", uhex_(getcrc_raw))

    getcrc_raw := GETCRC(@test_byte, $1021 << 16, 1)
    debug("$1021<<16: getcrc=$", uhex_long_(getcrc_raw))

    ' ============================================================
    ' Try multi-byte test to see if relationship holds
    ' ============================================================
    debug(" ")
    debug("Multi-byte test (512 bytes sequential):")
    debug("=======================================")

    repeat i from 0 to 511
        test_sector[i] := i & $FF

    table_crc := calcTableCRC(@test_sector, 512)
    debug("Table CRC: $", uhex_(table_crc))

    getcrc_raw := GETCRC(@test_sector, $8408, 512)
    debug("GETCRC $8408: $", uhex_long_(getcrc_raw))

    ' Try various transforms on GETCRC result
    transform := getcrc_raw & $FFFF
    debug("  raw & FFFF = $", uhex_(transform))
    if transform == table_crc
        debug("  MATCH!")

    transform := (getcrc_raw REV 31) >> 16
    debug("  (REV 31)>>16 = $", uhex_(transform))
    if transform == table_crc
        debug("  MATCH!")

    transform := ((getcrc_raw & $FFFF) REV 31) >> 16
    debug("  ((raw & FFFF) REV 31)>>16 = $", uhex_(transform))
    if transform == table_crc
        debug("  MATCH!")

    ' XOR with zero-data CRC
    bytefill(@test_sector, 0, 512)
    getcrc_base := GETCRC(@test_sector, $8408, 512)
    debug("Base (512 zeros): $", uhex_long_(getcrc_base))

    repeat i from 0 to 511
        test_sector[i] := i & $FF
    getcrc_raw := GETCRC(@test_sector, $8408, 512)

    transform := (getcrc_raw ^ getcrc_base) & $FFFF
    debug("  (raw ^ base) & FFFF = $", uhex_(transform))
    if transform == table_crc
        debug("  MATCH!")

    debug(" ")
    debug("END_SESSION")


PRI manualCRC_LSB_byte(b) : crc | j
    '' LSB-first CRC for single byte
    crc := b
    repeat j from 0 to 7
        if crc & 1
            crc := (crc >> 1) ^ $8408
        else
            crc := crc >> 1


PRI calcTableCRC(pData, len) : crc | i, idx, b
    '' Table-based CRC-16-CCITT (known good)
    crc := 0
    repeat i from 0 to len - 1
        b := byte[pData + i]
        idx := ((crc >> 8) ^ b) & $FF
        crc := ((crc << 8) & $FF00) ^ word[@crc16_table][idx]


DAT
{{
  Terms of use: MIT License
}}
