'' =================================================================================================
''
''   File....... SD_pasm_streamer_test.spin2
''   Purpose.... Prove streamer mechanism with pure PASM cog
''   Author..... Claude + Stephen M Moraco
''   Started.... JAN 2026
''
'' =================================================================================================
''
''   This test isolates the streamer mechanism from Spin/inline-PASM complexity.
''
''   Approach:
''   1. Use v2 driver's initCardOnly() to initialize card and configure smart pins
''   2. Launch pure PASM cog to handle CMD17 + streamer read
''   3. PASM cog writes directly to hub buffer
''   4. Spin verifies data after PASM cog completes
''
''   This proves whether the streamer mechanism works when there's NO Spin interpreter
''   involvement in the critical transfer section.
''
'' =================================================================================================

CON

    _CLKFREQ        = 320_000_000

    ' P2 Edge module SD slot
    SD_CS   = 60
    SD_MOSI = 59
    SD_MISO = 58
    SD_SCK  = 61

    ' Test sector (known pattern from SD_write_test_patterns.spin2)
    TEST_SECTOR     = 100_000

    ' SPI timing - matches v2 driver at 25 MHz
    SPI_HALF_PERIOD = 7             ' ~22.8 MHz actual

    ' Status flags
    STATUS_IDLE     = 0
    STATUS_READY    = 1
    STATUS_BUSY     = 2
    STATUS_DONE     = 3
    STATUS_ERROR    = 4

OBJ
    sd : "SD_card_driver_v2"

VAR
    ' Shared parameters for PASM cog (must be contiguous)
    LONG    pasm_status             ' [0] Status flag
    LONG    pasm_sector             ' [4] Sector to read
    LONG    pasm_cs                 ' [8] CS pin
    LONG    pasm_mosi               ' [12] MOSI pin
    LONG    pasm_miso               ' [16] MISO pin
    LONG    pasm_sck                ' [20] SCK pin
    LONG    pasm_buf_ptr            ' [24] Pointer to hub buffer
    LONG    pasm_error              ' [28] Error code
    LONG    pasm_debug1             ' [32] Debug value 1
    LONG    pasm_debug2             ' [36] Debug value 2

    LONG    cog_id
    BYTE    hub_buffer[512]         ' Hub buffer for sector data

PUB go() | result

    debug(" ")
    debug("======================================================")
    debug("  PASM Streamer Test - Isolated Mechanism")
    debug("======================================================")
    debug(" ")

    ' Initialize card using v2 driver (configures smart pins)
    debug("Step 1: Initialize card with v2 driver...")
    result := sd.initCardOnly(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    if result == false
        debug("ERROR: Card init failed!")
        debug("END_SESSION")
        return
    debug("  Card initialized successfully")
    debug(" ")

    ' Clear hub buffer with known pattern
    bytefill(@hub_buffer, $AA, 512)

    ' Setup parameters for PASM cog
    pasm_status := STATUS_READY
    pasm_sector := TEST_SECTOR
    pasm_cs := SD_CS
    pasm_mosi := SD_MOSI
    pasm_miso := SD_MISO
    pasm_sck := SD_SCK
    pasm_buf_ptr := @hub_buffer
    pasm_error := 0
    pasm_debug1 := 0
    pasm_debug2 := 0

    debug("Step 2: Starting PASM cog for sector read...")
    debug("  Sector: ", udec_(TEST_SECTOR))
    debug("  Buffer: $", uhex_long_(@hub_buffer))

    ' Start the PASM cog
    cog_id := cogspin(NEWCOG, @pasm_reader, @pasm_status)
    if cog_id < 0
        debug("ERROR: Failed to start PASM cog")
        debug("END_SESSION")
        return
    debug("  PASM cog ", udec_(cog_id), " started")

    ' Wait for PASM cog to complete
    debug("  Waiting for completion...")
    repeat
        case pasm_status
            STATUS_DONE:
                quit
            STATUS_ERROR:
                debug("ERROR: PASM cog reported error: $", uhex_byte_(pasm_error))
                debug("  Debug1: $", uhex_long_(pasm_debug1))
                debug("  Debug2: $", uhex_long_(pasm_debug2))
                cogstop(cog_id)
                debug("END_SESSION")
                return
        waitms(1)

    debug("  PASM cog completed")
    debug("  Debug1: $", uhex_long_(pasm_debug1))
    debug("  Debug2: $", uhex_long_(pasm_debug2))
    cogstop(cog_id)

    ' Display captured data
    debug(" ")
    debug("Step 3: Examining captured data...")
    debug("First 32 bytes:")
    debug("  ", uhex_byte_array_(@hub_buffer, 16))
    debug("  ", uhex_byte_array_(@hub_buffer[16], 16))

    debug("Last 32 bytes:")
    debug("  ", uhex_byte_array_(@hub_buffer[480], 16))
    debug("  ", uhex_byte_array_(@hub_buffer[496], 16))

    ' Check for $AA (unchanged = streamer didn't write here)
    debug(" ")
    debug("Checking if buffer was modified...")
    if hub_buffer[0] == $AA and hub_buffer[511] == $AA
        debug("  PROBLEM: Buffer still contains $AA - streamer didn't write!")
    elseif hub_buffer[0] == $AA
        debug("  PROBLEM: Start of buffer unchanged, end modified - partial write?")
    elseif hub_buffer[511] == $AA
        debug("  PROBLEM: End of buffer unchanged, start modified - partial write?")
    else
        debug("  OK: Buffer was modified by streamer")

    ' Verify expected pattern
    debug(" ")
    debug("Expected (sector 100000): $A0 $A0 $A0 $A0 $DE $AD $BE $EF")
    debug("Actual:                   $", uhex_byte_(hub_buffer[0]), " $", uhex_byte_(hub_buffer[1]), " $", uhex_byte_(hub_buffer[2]), " $", uhex_byte_(hub_buffer[3]), " $", uhex_byte_(hub_buffer[4]), " $", uhex_byte_(hub_buffer[5]), " $", uhex_byte_(hub_buffer[6]), " $", uhex_byte_(hub_buffer[7]))

    if hub_buffer[0] == $A0 and hub_buffer[4] == $DE and hub_buffer[5] == $AD
        debug(" ")
        debug("*** SUCCESS: Data matches expected pattern! ***")
    else
        debug(" ")
        debug("*** MISMATCH: Data does not match expected ***")

    debug(" ")
    debug("======================================================")
    debug("END_SESSION")


DAT
'' ═══════════════════════════════════════════════════════════════════════════
'' PASM COG - Pure PASM sector reader
'' Assumes smart pins already configured by v2 driver
'' Handles: CS assert, CMD17, wait for $FE, streamer, CRC, CS deassert
'' ═══════════════════════════════════════════════════════════════════════════

                org     0

pasm_reader
                ' Get pointer to shared parameters (passed in PTRA)
                mov     parm_base, ptra

                ' Load parameters from hub
                rdlong  rd_status, parm_base            ' [0] status (not used, we write it)
                add     parm_base, #4
                rdlong  rd_sector, parm_base            ' [4] sector number
                add     parm_base, #4
                rdlong  rd_cs, parm_base                ' [8] CS pin
                add     parm_base, #4
                rdlong  rd_mosi, parm_base              ' [12] MOSI pin
                add     parm_base, #4
                rdlong  rd_miso, parm_base              ' [16] MISO pin
                add     parm_base, #4
                rdlong  rd_sck, parm_base               ' [20] SCK pin
                add     parm_base, #4
                rdlong  rd_buf, parm_base               ' [24] hub buffer pointer
                mov     parm_base, ptra                 ' Restore base pointer

                ' Set status to BUSY
                mov     tmp, #STATUS_BUSY
                wrlong  tmp, parm_base

                ' ══════════════════════════════════════════════════════════════
                ' ASSERT CS (active LOW)
                ' ══════════════════════════════════════════════════════════════
                drvl    rd_cs

                ' Send 8 dummy clocks
                call    #send_ff

                ' ══════════════════════════════════════════════════════════════
                ' SEND CMD17 (READ_SINGLE_BLOCK)
                ' Format: 01 | cmd[5:0] | arg[31:0] | crc[6:0] | 1
                ' ══════════════════════════════════════════════════════════════

                ' Byte 0: 0x40 | 17 = 0x51
                mov     tx_data, #$51
                call    #send_byte

                ' Bytes 1-4: sector number (MSB first)
                ' For SDHC cards, sector = block number directly
                mov     tx_data, rd_sector
                shr     tx_data, #24
                and     tx_data, #$FF
                call    #send_byte

                mov     tx_data, rd_sector
                shr     tx_data, #16
                and     tx_data, #$FF
                call    #send_byte

                mov     tx_data, rd_sector
                shr     tx_data, #8
                and     tx_data, #$FF
                call    #send_byte

                mov     tx_data, rd_sector
                and     tx_data, #$FF
                call    #send_byte

                ' Byte 5: CRC (dummy for SPI mode)
                mov     tx_data, #$FF
                call    #send_byte

                ' ══════════════════════════════════════════════════════════════
                ' WAIT FOR R1 RESPONSE (expect 0x00 for success)
                ' ══════════════════════════════════════════════════════════════
                mov     retry_cnt, ##10000
.wait_r1
                call    #recv_byte
                cmp     rx_data, #$FF           wz
        if_nz   jmp     #.got_r1
                djnz    retry_cnt, #.wait_r1
                mov     err_code, #1                    ' Timeout waiting for R1
                jmp     #.error

.got_r1
                ' Store R1 in debug1
                mov     tmp, parm_base
                add     tmp, #32
                wrlong  rx_data, tmp

                cmp     rx_data, #$00           wz
        if_nz   mov     err_code, rx_data               ' R1 error
        if_nz   jmp     #.error

                ' ══════════════════════════════════════════════════════════════
                ' WAIT FOR $FE DATA START TOKEN
                ' ══════════════════════════════════════════════════════════════
                mov     retry_cnt, ##500000             ' Long timeout
.wait_fe
                call    #recv_byte
                cmp     rx_data, #$FE           wz
        if_z    jmp     #.got_fe
                cmp     rx_data, #$FF           wz
        if_nz   mov     err_code, rx_data               ' Error token
        if_nz   jmp     #.error
                djnz    retry_cnt, #.wait_fe
                mov     err_code, #2                    ' Timeout waiting for $FE
                jmp     #.error

.got_fe
                ' ══════════════════════════════════════════════════════════════
                ' STREAMER BULK TRANSFER: 512 bytes from MISO to hub
                ' This is the critical section we're testing
                ' ══════════════════════════════════════════════════════════════

                ' Calculate NCO frequency
                ' xfrq = $4000_0000 / spi_half_period
                mov     xfrq, ##$4000_0000
                mov     tmp, #SPI_HALF_PERIOD
                qdiv    xfrq, tmp
                getqx   xfrq

                ' Store xfrq in debug2 for verification
                mov     tmp, parm_base
                add     tmp, #36
                wrlong  xfrq, tmp

                ' Set streamer NCO rate
                setxfrq xfrq

                ' Setup WRFAST to write to hub buffer
                wrfast  #0, rd_buf

                ' Streamer mode: X_1P_1DAC1_WFBYTE | (miso_pin << 17) | bit_count
                ' X_1P_1DAC1_WFBYTE = $C000_0000
                ' bit_count = 512 * 8 = 4096 = $1000
                mov     strm_mode, ##$C000_0000
                mov     tmp, rd_miso
                shl     tmp, #17
                or      strm_mode, tmp
                or      strm_mode, ##$1000              ' 4096 bits

                ' Clock count: 512 * 8 * 2 = 8192 transitions
                mov     clk_cnt, ##8192

                ' Initial phase for alignment
                mov     init_ph, ##$8000_0000
                sub     init_ph, xfrq

                ' START THE TRANSFER
                ' Order: wypin starts clock, waitx aligns, xinit starts streamer
                wypin   clk_cnt, rd_sck                 ' Start clock
                waitx   #3                              ' Small alignment delay
                xinit   strm_mode, init_ph              ' Start streamer
                waitxfi                                 ' Wait for streamer complete

                ' ══════════════════════════════════════════════════════════════
                ' READ AND DISCARD CRC (2 bytes)
                ' ══════════════════════════════════════════════════════════════
                call    #recv_byte
                call    #recv_byte

                ' ══════════════════════════════════════════════════════════════
                ' DESELECT CARD
                ' ══════════════════════════════════════════════════════════════
                drvh    rd_cs

                ' Send 8 dummy clocks with CS high
                call    #send_ff

                ' ══════════════════════════════════════════════════════════════
                ' SUCCESS
                ' ══════════════════════════════════════════════════════════════
                mov     tmp, #STATUS_DONE
                wrlong  tmp, parm_base
                jmp     #.halt

.error
                ' Write error status
                mov     tmp, #STATUS_ERROR
                wrlong  tmp, parm_base
                mov     tmp, parm_base
                add     tmp, #28
                wrlong  err_code, tmp
                ' Fall through to halt

.halt
                jmp     #.halt


'' ═══════════════════════════════════════════════════════════════════════════
'' SUBROUTINES: SPI byte transfer using smart pins
'' ═══════════════════════════════════════════════════════════════════════════

send_ff
                mov     tx_data, #$FF
                ' Fall through

send_byte
                ' Send tx_data (8 bits) and receive into rx_data
                ' Smart pins already configured by v2 driver

                ' Prepare TX data: shift to MSB and reverse for SPI
                shl     tx_data, #24
                rev     tx_data

                ' Configure MOSI for 8-bit start-stop mode, load data
                wxpin   #$27, rd_mosi                   ' 8 bits
                wypin   tx_data, rd_mosi
                drvl    rd_mosi                         ' Enable TX

                ' Configure MISO for 8-bit receive
                wxpin   #$27, rd_miso                   ' 8 bits
                akpin   rd_miso                         ' Clear pending
                dirh    rd_miso                         ' Enable

                ' Generate 16 clock transitions
                wypin   #16, rd_sck

                ' Wait for MISO receive complete
.wait_rx        testp   rd_miso                 wz
        if_nz   jmp     #.wait_rx

                ' Read received data
                rdpin   rx_data, rd_miso
                rev     rx_data
                zerox   rx_data, #7

                ret


recv_byte
                mov     tx_data, #$FF
                jmp     #send_byte


'' ═══════════════════════════════════════════════════════════════════════════
'' VARIABLES
'' ═══════════════════════════════════════════════════════════════════════════

parm_base       res     1
rd_status       res     1
rd_sector       res     1
rd_cs           res     1
rd_mosi         res     1
rd_miso         res     1
rd_sck          res     1
rd_buf          res     1
tx_data         res     1
rx_data         res     1
tmp             res     1
retry_cnt       res     1
err_code        res     1
xfrq            res     1
strm_mode       res     1
clk_cnt         res     1
init_ph         res     1

                fit     496

