'' =================================================================================================
''
''   File....... SD_write_test_patterns.spin2
''   Purpose.... Write known patterns to test sectors using bit-bang driver (no filesystem mount)
''   Author..... Claude + Stephen M Moraco
''   Started.... JAN 2026
''
'' =================================================================================================
''
''   This utility writes known patterns to 5 consecutive test sectors for streamer debugging.
''   Uses the proven bit-bang driver with initCardOnly() - NO filesystem mount needed.
''
''   Each sector has:
''     - Head marker (bytes 0-7): Sector ID + pattern identifier + DEADBEEF
''     - Fill pattern (bytes 8-503): Pattern-specific data
''     - Tail marker (bytes 504-511): CAFEBABE + pattern + sector ID
''
''   Test Sectors (consecutive for multi-sector testing, in free space):
''     Sector 100000: Pattern A - Sequential bytes with boundary markers
''     Sector 100001: Pattern B - Alternating AA 55 with boundary markers
''     Sector 100002: Pattern C - All FF (except markers)
''     Sector 100003: Pattern D - All 00 (except markers)
''     Sector 100004: Pattern E - Incrementing with sector offset
''
''   After writing, reads back in REVERSE ORDER to verify correct sector addressing.
''
'' =================================================================================================

CON

    _CLKFREQ        = 320_000_000

    ' Pin configuration for LA instrumented card slot
    SD_CS   = 20
    SD_MOSI = 19
    SD_MISO = 18
    SD_SCK  = 21

    ' Test sector numbers (in free space area, safe for 64GB+ cards)
    TEST_SECTOR_BASE = 100_000
    TEST_SECTOR_A   = 100_000   ' Sequential pattern
    TEST_SECTOR_B   = 100_001   ' Alternating AA/55
    TEST_SECTOR_C   = 100_002   ' All FF
    TEST_SECTOR_D   = 100_003   ' All 00
    TEST_SECTOR_E   = 100_004   ' Incrementing with offset

    NUM_TEST_SECTORS = 5

OBJ
    sd : "SD_card_driver"

VAR
    BYTE    write_buf[512]
    BYTE    read_buf[512]

PUB go() | result, i, sector, errors

    debug(" ")
    debug("======================================================")
    debug("  SD Test Pattern Writer (raw sector access)")
    debug("======================================================")
    debug(" ")

    ' Initialize card only (no filesystem mount - we're doing raw sector access)
    debug("Initializing SD card...")
    result := sd.initCardOnly(SD_CS, SD_MOSI, SD_MISO, SD_SCK)
    if result == false
        debug("ERROR: Card init failed!")
        debug("END_SESSION")
        return

    debug("Card initialized successfully")
    debug(" ")

    ' ========================================
    ' PHASE 1: Write all test patterns
    ' ========================================
    debug("--- PHASE 1: Writing test patterns ---")
    debug(" ")

    ' Write Pattern A: Sequential bytes
    sector := TEST_SECTOR_A
    debug("Writing Pattern A (sequential) to sector ", udec_(sector), "...")
    repeat i from 0 to 511
        write_buf[i] := i & $FF
    addBoundaryMarkers(sector, $A0)
    if not writeAndShowMarkers(sector)
        debug("ABORT: Write failed")
        debug("END_SESSION")
        return

    ' Write Pattern B: Alternating AA/55
    sector := TEST_SECTOR_B
    debug("Writing Pattern B (AA/55) to sector ", udec_(sector), "...")
    repeat i from 0 to 511
        write_buf[i] := (i & 1) ? $55 : $AA
    addBoundaryMarkers(sector, $B0)
    if not writeAndShowMarkers(sector)
        debug("ABORT: Write failed")
        debug("END_SESSION")
        return

    ' Write Pattern C: All FF (except markers)
    sector := TEST_SECTOR_C
    debug("Writing Pattern C (all FF) to sector ", udec_(sector), "...")
    bytefill(@write_buf, $FF, 512)
    addBoundaryMarkers(sector, $C0)
    if not writeAndShowMarkers(sector)
        debug("ABORT: Write failed")
        debug("END_SESSION")
        return

    ' Write Pattern D: All 00 (except markers)
    sector := TEST_SECTOR_D
    debug("Writing Pattern D (all 00) to sector ", udec_(sector), "...")
    bytefill(@write_buf, $00, 512)
    addBoundaryMarkers(sector, $D0)
    if not writeAndShowMarkers(sector)
        debug("ABORT: Write failed")
        debug("END_SESSION")
        return

    ' Write Pattern E: Incrementing with sector offset
    sector := TEST_SECTOR_E
    debug("Writing Pattern E (offset) to sector ", udec_(sector), "...")
    repeat i from 0 to 511
        write_buf[i] := (i + $E0) & $FF          ' Offset by $E0 to distinguish from pattern A
    addBoundaryMarkers(sector, $E0)
    if not writeAndShowMarkers(sector)
        debug("ABORT: Write failed")
        debug("END_SESSION")
        return

    debug(" ")
    debug("All patterns written!")
    debug(" ")

    ' ========================================
    ' PHASE 2: Read back in REVERSE order
    ' ========================================
    debug("--- PHASE 2: Verify by reading in REVERSE order ---")
    debug(" ")

    errors := 0

    ' Read Pattern E first (was written last)
    sector := TEST_SECTOR_E
    debug("Reading sector ", udec_(sector), " (expect pattern E=$E0)...")
    if not verifyPattern(sector, $E0)
        errors++

    ' Read Pattern D
    sector := TEST_SECTOR_D
    debug("Reading sector ", udec_(sector), " (expect pattern D=$D0)...")
    if not verifyPattern(sector, $D0)
        errors++

    ' Read Pattern C
    sector := TEST_SECTOR_C
    debug("Reading sector ", udec_(sector), " (expect pattern C=$C0)...")
    if not verifyPattern(sector, $C0)
        errors++

    ' Read Pattern B
    sector := TEST_SECTOR_B
    debug("Reading sector ", udec_(sector), " (expect pattern B=$B0)...")
    if not verifyPattern(sector, $B0)
        errors++

    ' Read Pattern A last (was written first)
    sector := TEST_SECTOR_A
    debug("Reading sector ", udec_(sector), " (expect pattern A=$A0)...")
    if not verifyPattern(sector, $A0)
        errors++

    debug(" ")
    debug("======================================================")
    if errors == 0
        debug("  SUCCESS: All 5 sectors verified correctly!")
    else
        debug("  FAILED: ", udec_(errors), " sector(s) had errors")
    debug("======================================================")
    debug(" ")
    debug("END_SESSION")

PRI addBoundaryMarkers(sector, patternId) | secLow
    '' Add head and tail boundary markers to write_buf
    '' Head (bytes 0-7): sector#, sector#, pattern, pattern, DE AD BE EF
    '' Tail (bytes 504-511): CA FE BA BE, pattern, pattern, sector#, sector#

    secLow := sector & $FF

    ' Head marker (bytes 0-7)
    write_buf[0] := secLow
    write_buf[1] := secLow
    write_buf[2] := patternId
    write_buf[3] := patternId
    write_buf[4] := $DE
    write_buf[5] := $AD
    write_buf[6] := $BE
    write_buf[7] := $EF

    ' Tail marker (bytes 504-511)
    write_buf[504] := $CA
    write_buf[505] := $FE
    write_buf[506] := $BA
    write_buf[507] := $BE
    write_buf[508] := patternId
    write_buf[509] := patternId
    write_buf[510] := secLow
    write_buf[511] := secLow

PRI writeAndShowMarkers(sector) : result

    result := sd.writeSectorRaw(sector, @write_buf)
    if result
        debug("  Written - Head: $", uhex_byte_(write_buf[0]), " $", uhex_byte_(write_buf[2]), " $", uhex_byte_(write_buf[4]), uhex_byte_(write_buf[5]))
        debug("          - Tail: $", uhex_byte_(write_buf[508]), " $", uhex_byte_(write_buf[510]), " $", uhex_byte_(write_buf[504]), uhex_byte_(write_buf[505]))
    else
        debug("  WRITE FAILED!")

PRI verifyPattern(sector, expectedPattern) : success | secLow
    '' Read sector and verify boundary markers match expected pattern
    '' Returns true if verified OK, false if mismatch

    success := true
    secLow := sector & $FF

    sd.readSectorRaw(sector, @read_buf)

    ' Check head marker
    debug("  Head: $", uhex_byte_(read_buf[0]), " $", uhex_byte_(read_buf[2]), " $", uhex_byte_(read_buf[4]), uhex_byte_(read_buf[5]))

    if read_buf[0] <> secLow or read_buf[1] <> secLow
        debug("  ERROR: Sector ID mismatch! Expected $", uhex_byte_(secLow), ", got $", uhex_byte_(read_buf[0]))
        success := false

    if read_buf[2] <> expectedPattern or read_buf[3] <> expectedPattern
        debug("  ERROR: Pattern ID mismatch! Expected $", uhex_byte_(expectedPattern), ", got $", uhex_byte_(read_buf[2]))
        success := false

    if read_buf[4] <> $DE or read_buf[5] <> $AD or read_buf[6] <> $BE or read_buf[7] <> $EF
        debug("  ERROR: Head magic mismatch! Expected DEADBEEF")
        success := false

    ' Check tail marker
    debug("  Tail: $", uhex_byte_(read_buf[508]), " $", uhex_byte_(read_buf[510]), " $", uhex_byte_(read_buf[504]), uhex_byte_(read_buf[505]))

    if read_buf[504] <> $CA or read_buf[505] <> $FE or read_buf[506] <> $BA or read_buf[507] <> $BE
        debug("  ERROR: Tail magic mismatch! Expected CAFEBABE")
        success := false

    if read_buf[508] <> expectedPattern or read_buf[509] <> expectedPattern
        debug("  ERROR: Tail pattern mismatch!")
        success := false

    if read_buf[510] <> secLow or read_buf[511] <> secLow
        debug("  ERROR: Tail sector ID mismatch!")
        success := false

    if success
        debug("  VERIFIED OK")
    else
        debug("  VERIFICATION FAILED")
