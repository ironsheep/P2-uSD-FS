'' =================================================================================================
''
''   File....... SD_CRC_validation.spin2
''   Purpose.... Validate CRC-16 implementation in V3 SD card driver
''   Author..... Stephen M Moraco
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... JAN 2026
''   Updated.... 30 JAN 2026
''
'' =================================================================================================
''
'' This test validates CRC-16-CCITT using P2's GETCRC hardware instruction.
'' The V3 driver now calculates and validates CRC on all read/write operations.
''
'' CRC-16-CCITT Algorithm:
''   - Polynomial: $1021 (MSB-first) / $8408 (reflected for P2 GETCRC)
''   - Initial value: $0000
''   - P2 GETCRC processes LSB-first, result is bit-reversed for MSB-first
''
'' Test proves:
''   - READ CRC: Driver calculates CRC of received data, matches card's CRC
''   - WRITE CRC: Driver calculates CRC of data and sends it (card accepts)
''
'' =================================================================================================

CON

     _CLKFREQ        = 320_000_000

     ' Pin configuration for P2 Edge module SD slot
     SD_CS   = 60
     SD_MOSI = 59
     SD_MISO = 58
     SD_SCK  = 61

     SECTOR_SIZE = 512

OBJ
    sd    : "SD_card_driver_v3"

DAT

sector_buffer   BYTE    0[SECTOR_SIZE]    ' Buffer for sector data
test_pattern    BYTE    0[SECTOR_SIZE]    ' Test pattern for writes

PUB go() | result, i, recv_crc, calc_crc, sent_crc, matches, mismatches

    debug(" ")
    debug("==============================================")
    debug("  SD Card CRC-16 Validation Test (V3 Driver)")
    debug("==============================================")

    ' Mount the SD card
    debug(" ")
    debug("Mounting SD card...")
    result := sd.mount(SD_CS, SD_MOSI, SD_MISO, SD_SCK)

    if not result
        debug("ERROR: Mount failed!")
        debug("END_SESSION")
        return

    debug("Mount successful")
    debug(" ")

    ' ══════════════════════════════════════════════════════════════════════════
    ' TEST 1: Validate CRC on sector READS
    ' ══════════════════════════════════════════════════════════════════════════
    debug("TEST 1: CRC Validation on Sector Reads")
    debug("---------------------------------------")
    debug("Reading multiple sectors, comparing received vs calculated CRC...")
    debug(" ")

    ' Read several sectors - driver validates CRC automatically
    repeat i from 0 to 4
        result := sd.readSectorRaw(i, @sector_buffer)
        if result                                                               ' true/-1 on success
            recv_crc := sd.getLastReceivedCRC()
            calc_crc := sd.getLastCalculatedCRC()
            if recv_crc == calc_crc
                debug("  Sector ", udec_(i), ": recv=$", uhex_(recv_crc), " calc=$", uhex_(calc_crc), " MATCH")
            else
                debug("  Sector ", udec_(i), ": recv=$", uhex_(recv_crc), " calc=$", uhex_(calc_crc), " MISMATCH")
        else
            debug("  Sector ", udec_(i), ": READ FAILED")

    ' Show cumulative statistics
    matches := sd.getCRCMatchCount()
    mismatches := sd.getCRCMismatchCount()
    debug(" ")
    debug("Read CRC Statistics:")
    debug("  Matches: ", udec_(matches))
    debug("  Mismatches: ", udec_(mismatches))

    if mismatches > 0
        debug("  WARNING: CRC mismatches detected!")
    else
        debug("  All read CRCs validated successfully")

    ' ══════════════════════════════════════════════════════════════════════════
    ' TEST 2: Validate CRC on sector WRITES
    ' ══════════════════════════════════════════════════════════════════════════
    debug(" ")
    debug("TEST 2: CRC Validation on Sector Writes")
    debug("----------------------------------------")
    debug("Writing test pattern, driver sends calculated CRC...")
    debug(" ")

    ' Create a test pattern
    repeat i from 0 to 511
        test_pattern[i] := i & $FF

    ' Write to a high sector number (safe area)
    result := sd.writeSectorRaw(10000, @test_pattern)
    if result
        sent_crc := sd.getLastSentCRC()
        debug("  Write sector 10000: CRC sent = $", uhex_(sent_crc), " - ACCEPTED")
    else
        debug("  Write sector 10000: FAILED")

    ' Read it back to verify
    result := sd.readSectorRaw(10000, @sector_buffer)
    if result                                                                   ' true/-1 on success
        recv_crc := sd.getLastReceivedCRC()
        calc_crc := sd.getLastCalculatedCRC()
        debug("  Read back sector 10000: recv=$", uhex_(recv_crc), " calc=$", uhex_(calc_crc))

        ' Verify data matches
        result := 0
        repeat i from 0 to 511
            if sector_buffer[i] <> test_pattern[i]
                result++
        if result == 0
            debug("  Data verification: All 512 bytes match - SUCCESS")
        else
            debug("  Data verification: ", udec_(result), " bytes differ - FAILED")
    else
        debug("  Read back sector 10000: FAILED")

    ' ══════════════════════════════════════════════════════════════════════════
    ' SUMMARY
    ' ══════════════════════════════════════════════════════════════════════════
    debug(" ")
    debug("==============================================")
    debug("FINAL RESULTS")
    debug("==============================================")
    matches := sd.getCRCMatchCount()
    mismatches := sd.getCRCMismatchCount()
    debug("  Total CRC matches: ", udec_(matches))
    debug("  Total CRC mismatches: ", udec_(mismatches))

    if mismatches == 0
        debug(" ")
        debug("SUCCESS: All CRC validations passed!")
        debug("  - Read CRCs: Calculated values match card's CRCs")
        debug("  - Write CRCs: Card accepted our calculated CRCs")
    else
        debug(" ")
        debug("FAILURE: CRC validation errors detected")

    debug(" ")
    debug("=== Test Complete ===")
    debug("END_SESSION")


DAT
{{
  Terms of use: MIT License

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
}}

